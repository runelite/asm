#LyX 2.0 created this file. For more info see http://www.lyx.org/
\lyxformat 413
\begin_document
\begin_header
\textclass scrbook
\begin_preamble
\usepackage{lmodern}

\usepackage[
pdfauthor={Eric Bruneton},
pdftitle={ASM 3.0 A Java bytecode engineering library},
pdfcreator={pdftex},
pdfsubject={ASM 3.0},
pdfkeywords={Java,bytecode}
]{hyperref}

%\usepackage{showidx}

%\special{pdf: pagesize width 18.0truecm height 24truecm}

\renewenvironment{lyxcode}
{\begin{footnotesize}\par\begin{list}{}{
\setlength{\listparindent}{0pt}
\raggedright
\setlength{\itemsep}{0pt}
\setlength{\parsep}{0pt}
\normalfont\ttfamily\fontseries{l}\selectfont}%
 \item[]}
{\end{list}\end{footnotesize}}
\end_preamble
\options headsepline, footsepline, idxtotoc
\use_default_options false
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\float_placement h
\paperfontsize default
\spacing single
\use_hyperref false
\papersize custom
\use_geometry true
\use_amsmath 1
\use_esint 0
\use_mhchem 0
\use_mathdots 1
\cite_engine basic
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\use_refstyle 0
\index Index
\shortcut idx
\color #008000
\end_index
\paperwidth 18cm
\paperheight 24cm
\leftmargin 3cm
\topmargin 2.5cm
\rightmargin 2cm
\bottommargin 3cm
\secnumdepth 3
\tocdepth 3
\paragraph_separation skip
\defskip medskip
\quotes_language english
\papercolumns 1
\papersides 2
\paperpagestyle headings
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
ASM 4.0
\begin_inset Newline newline
\end_inset

A Java bytecode engineering library
\end_layout

\begin_layout Author
Eric Bruneton
\end_layout

\begin_layout Date
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Uppertitleback
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

Copyright 
\backslash
copyright~2007, 2011 Eric Bruneton
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

All rights reserved.
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Redistribution and use in source (L
\backslash
kern-.1667em
\backslash
lower.25em
\backslash
hbox{Y}
\backslash
kern-.125emX
\backslash
@ format) and compiled forms (
\backslash
LaTeX, PDF, PostScript, HTML, RTF, etc), with or without modification, are
 permitted provided that the following conditions are met:
\end_layout

\begin_layout Plain Layout


\backslash
begin{enumerate}
\end_layout

\begin_layout Plain Layout


\backslash
item Redistributions of source code (L
\backslash
kern-.1667em
\backslash
lower.25em
\backslash
hbox{Y}
\backslash
kern-.125emX
\backslash
@ format) must retain the above copyright notice, this list of conditions
 and the following disclaimer.
\end_layout

\begin_layout Plain Layout


\backslash
item Redistributions in compiled form (converted to 
\backslash
LaTeX, PDF, PostScript, HTML, RTF, and other formats) must reproduce the
 above copyright notice, this list of conditions and the following disclaimer
 in the documentation and/or other materials provided with the distribution.
\end_layout

\begin_layout Plain Layout


\backslash
item The name of the author may not be used to endorse or promote products
 derived from this documentation without specific prior written permission.
\end_layout

\begin_layout Plain Layout


\backslash
end{enumerate}
\end_layout

\begin_layout Plain Layout

THIS DOCUMENTATION IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
 OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS DOCUMENTATION,
 EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
\end_layout

\end_inset


\end_layout

\begin_layout Lowertitleback
Version 2.0, September 2011
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
pagenumbering{roman}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
cleardoublepage
\backslash
pagenumbering{arabic}
\end_layout

\end_inset


\end_layout

\begin_layout Chapter
Introduction
\end_layout

\begin_layout Section
Motivations
\end_layout

\begin_layout Standard
Program analysis, generation and transformation are useful techniques that
 can be used in many situations:
\end_layout

\begin_layout Itemize
Program analysis, which can range from a simple syntaxic parsing to a full
 semantic analysis, can be used to find potential bugs in applications,
 to detect unused code, to reverse engineer code, etc.
\end_layout

\begin_layout Itemize
Program generation is used in compilers.
 This include traditional compilers, but also stub or skeleton compilers
 used for distributed programming, Just in Time compilers, etc.
\end_layout

\begin_layout Itemize
Program transformation can be used to optimize or obfuscate programs, to
 insert debugging or performance monitoring code into applications, for
 aspect oriented programming, etc.
\end_layout

\begin_layout Standard
All these techniques can be used for any programming language, but this
 is more or less easy to do, depending on the language.
 In the case of Java they can be used on Java source code or on compiled
 Java classes.
 One of the advantages of working on compiled classes is that, obviously,
 the source code is not needed.
 Program transformations can therefore be used on any applications, including
 closed source and commercial ones.
 Another advantage of working on compiled code is that it becomes possible
 to analyze, generate or transform classes at runtime, just before they
 are loaded into the Java Virtual Machine (generating and compiling source
 code at runtime is possible, but this is really slow and requires a full
 Java compiler).
 The advantage is that tools such as stub compilers or aspect weavers become
 transparent to users.
 
\end_layout

\begin_layout Standard
Due to the many possible usages of program analysis, generation and transformati
on techniques, many tools to analyze, generate and transform programs have
 been implemented, for many languages, Java included.
 ASM is one of these tools for the Java language, designed for 
\emph on
runtime
\emph default
 -- but also offline -- class generation and transformation.
 The ASM
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
the ASM name does not mean anything: it is just a reference to the 
\family typewriter
__asm__
\family default
 keyword in C, which allows some functions to be implemented in assembly
 language.
\end_layout

\end_inset

 library was therefore designed to work on 
\emph on
compiled
\emph default
 Java classes.
 It was also designed to be as 
\emph on
fast
\emph default
 and as 
\emph on
small
\emph default
 as possible.
 Being as fast as possible is important in order not to slow down too much
 the applications that use ASM at runtime, for dynamic class generation
 or transformation.
 And being as small as possible is important in order to be used in memory
 constrained environments, and to avoid bloating the size of small applications
 or libraries using ASM.
\end_layout

\begin_layout Standard
ASM is not the only tool for generating and transforming compiled Java classes,
 but it is one of the most recent and efficient.
 It can be downloaded from 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
url{http://asm.objectweb.org}
\end_layout

\end_inset

.
 Its main advantages are the following:
\end_layout

\begin_layout Itemize
It has a simple, well designed and modular API that is easy to use.
\end_layout

\begin_layout Itemize
It is well documented and has an associated Eclipse plugin.
\end_layout

\begin_layout Itemize
It provides support for the latest Java version, Java 7.
\end_layout

\begin_layout Itemize
It is small, fast, and very robust.
\end_layout

\begin_layout Itemize
Its large user community can provide support for new users.
\end_layout

\begin_layout Itemize
Its open source license allows you to use it in almost any way you want.
\end_layout

\begin_layout Section
Overview
\end_layout

\begin_layout Subsection
Scope
\end_layout

\begin_layout Standard
The goal of the ASM library is to generate, transform and analyze compiled
 Java classes, represented as byte arrays (as they are stored on disk and
 loaded in the Java Virtual Machine).
 For this purpose ASM provides tools to read, write and transform such byte
 arrays by using higher level concepts than bytes, such as numeric constants,
 strings, Java identifiers, Java types, Java class structure elements, etc.
 Note that the scope of the ASM library is strictly limited to reading,
 writing, transforming and analyzing classes.
 In particular the class loading process is out of scope.
\end_layout

\begin_layout Subsection
Model
\end_layout

\begin_layout Standard
The ASM library provides two APIs for generating and transforming compiled
 classes: the core API
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
core API
\end_layout

\end_inset

 provides an 
\emph on
event based
\emph default
 representation
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
classes!event based representation
\end_layout

\end_inset

 of classes, while the tree API
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
tree API
\end_layout

\end_inset

 provides an 
\emph on
object based
\emph default
 representation
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
classes!object based representation
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
With the event based model a class is represented with a sequence of events,
 each event representing an element of the class, such as its header, a
 field, a method declaration, an instruction, etc.
 The event based API defines the set of possible events and the order in
 which they must occur, and provides a class parser that generates one event
 per element that is parsed, as well as a class writer that generates compiled
 classes from sequences of such events.
\end_layout

\begin_layout Standard
With the object based model a class is represented with a tree of objects,
 each object representing a part of the class, such as the class itself,
 a field, a method, an instruction, etc.
 and each object having references to the objects that represent its constituent
s.
 The object based API provides a way to convert a sequence of events representin
g a class to the object tree representing the same class and, vice versa,
 to convert an object tree to the equivalent event sequence.
 In other words the object based API is built on top of the event based
 API.
\end_layout

\begin_layout Standard
These two APIs can be compared to the Simple API for XML (SAX) and Document
 Object Model (DOM) APIs for XML documents: the event based API is similar
 to SAX, while the object based API is similar to DOM.
 The object based API is built on top of the event based one, like DOM can
 be provided on top of SAX.
\end_layout

\begin_layout Standard
ASM provides both APIs because there is no best API.
 Indeed each API has its own advantages and drawbacks:
\end_layout

\begin_layout Itemize
The event based API is faster and requires less memory than the object based
 API, since there is no need to create and store in memory a tree of objects
 representing the class (the same difference also exists between SAX and
 DOM).
\end_layout

\begin_layout Itemize
However implementing class transformations can be more difficult with the
 event based API, since only one element of the class is available at any
 given time (the element that corresponds to the current event), while the
 whole class is available in memory with the object based API.
 
\end_layout

\begin_layout Standard
Note that the two APIs manage only one class at a time, and independently
 of the others: no information about the class hierarchy is maintained,
 and if a class transformation affects other classes, it is up to the user
 to modify these other classes.
\end_layout

\begin_layout Subsection
Architecture
\end_layout

\begin_layout Standard
ASM applications have a strong architectural aspect.
 Indeed the event based API is organized around event producers (the class
 parser), event consumers (the class writer) and various predefined event
 filters, to which user defined producers, consumers and filters can be
 added.
 Using this API is therefore a two step process:
\end_layout

\begin_layout Itemize
assembling event producer, filter and consumer components into possibly
 complex architectures,
\end_layout

\begin_layout Itemize
and then starting the event producers to run the generation or transformation
 process.
\end_layout

\begin_layout Standard
The object based API also has an architectural aspect: indeed class generator
 or transformer components that operate on object trees can be composed,
 the links between them representing the order of transformations.
\end_layout

\begin_layout Standard
Although most component architectures in typical ASM applications are quite
 simple, it is possible to imagine complex architectures like the following,
 where arrows represent event based or object based communications between
 class parsers, writers or transformers, with possible conversions between
 the event based and object based representations anywhere in the chain
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
transformation chain
\end_layout

\end_inset

:
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename figures/complexchain.eps
	scale 80

\end_inset


\end_layout

\begin_layout Section
Organization
\end_layout

\begin_layout Standard
The ASM library is organized in several packages that are distributed in
 several 
\family typewriter
jar
\family default
 files:
\end_layout

\begin_layout Itemize
the 
\family typewriter
org.objectweb.asm
\family default
 and 
\family typewriter
org.objectweb.asm.signature
\family default
 packages define the event based API and provide the class parser and writer
 components.
 They are contained in the 
\family typewriter
asm.jar
\family default
 archive.
\end_layout

\begin_layout Itemize
the 
\family typewriter
org.objectweb.asm.util
\family default
 package, in the 
\family typewriter
asm-util.jar
\family default
 archive, provides various tools based on the core API that can be used
 during the development and debuging of ASM applications.
\end_layout

\begin_layout Itemize
the 
\family typewriter
org.objectweb.asm.commons
\family default
 package provides several useful predefined class transformers, mostly based
 on the core API.
 It is contained in the 
\family typewriter
asm-commons.jar
\family default
 archive.
\end_layout

\begin_layout Itemize
the 
\family typewriter
org.objectweb.asm.tree
\family default
 package, in the 
\family typewriter
asm-tree.jar
\family default
 archive, defines the object based API, and provides tools to convert between
 the event based and the object based representations.
\end_layout

\begin_layout Itemize
the 
\family typewriter
org.objectweb.asm.tree.analysis
\family default
 package provides a class analysis framework and several predefined class
 analyzers, based on the tree API.
 It is contained in the 
\family typewriter
asm-analysis.jar
\family default
 archive.
\end_layout

\begin_layout Standard
This document is organized in two parts.
 The first part covers the core API, i.e.
 the 
\family typewriter
asm
\family default
, 
\family typewriter
asm-util
\family default
 and 
\family typewriter
asm-commons
\family default
 archives.
 The second part covers the tree API, i.e.
 the 
\family typewriter
asm-tree
\family default
 and 
\family typewriter
asm-analysis
\family default
 archives.
 Each part contains at least one chapter for the API related to classes,
 one chapter for the API related to methods, and one chapter for the API
 related to annotations, generic types, etc.
 Each chapter covers the programming interfaces as well as the related tools
 and predefined components.
 The source code of all the examples is available on the 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
href{http://asm.objectweb.org}{ASM web site}
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
This organization makes it easier to introduce class file features progressively
, but sometimes required to spread the presentation of a single ASM class
 in several sections.
 It is therefore recommanded to read this document in sequential order.
 For a reference guide about the ASM API, please use the 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
href{http://asm.objectweb.org/asm30/javadoc/user/overview-summary.html}{Javadoc}
\end_layout

\end_inset

.
\end_layout

\begin_layout Subsubsection*
Typographic conventions
\end_layout

\begin_layout Standard

\emph on
Italic
\emph default
 is used for emphasizing elements in a sentence.
\end_layout

\begin_layout Standard

\family typewriter
Constant width
\family default
 is used for code fragments.
\end_layout

\begin_layout Standard

\family typewriter
\series bold
Bold constant width
\family default
\series default
 is used for emphasizing code elements.
 
\end_layout

\begin_layout Standard

\family typewriter
\emph on
Italic constant width
\family default
\emph default
 is used for variable parts in code and for labels.
\end_layout

\begin_layout Section
Acknowledgments
\end_layout

\begin_layout Standard
I would like to thank Fran√ßois Horn for his valuable remarks during the
 elaboration of this document, which greatly improved its structure and
 readability.
\end_layout

\begin_layout Part
Core API
\end_layout

\begin_layout Chapter
Classes
\begin_inset CommandInset label
LatexCommand label
name "cha:Classes"

\end_inset


\end_layout

\begin_layout Standard
This chapter explains how to generate and transform compiled Java classes
 with the core ASM API.
 It starts with a presentation of compiled classes and then presents the
 corresponding ASM interfaces, components and tools to generate and transform
 them, with many illustrative examples.
 The content of methods, annotations and generics are explained in the next
 chapters.
\end_layout

\begin_layout Section
Structure
\end_layout

\begin_layout Subsection
Overview
\begin_inset CommandInset label
LatexCommand label
name "sub:Class-Structure-Overview"

\end_inset


\end_layout

\begin_layout Standard
The overall structure
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
classes!overall structure
\end_layout

\end_inset

 of a compiled class is quite simple.
 Indeed, unlike natively compiled applications, a compiled class retains
 the structural information and almost all the symbols from the source code.
 In fact a compiled class contains:
\end_layout

\begin_layout Itemize
A section describing the modifiers (such as 
\family typewriter
public
\family default
 or 
\family typewriter
private
\family default
), the name, the super class, the interfaces and the annotations of the
 class.
\end_layout

\begin_layout Itemize
One section per field declared in this class.
 Each section describes the modifiers, the name, the type and the annotations
 of a field.
\end_layout

\begin_layout Itemize
One section per method 
\emph on
and constructor
\emph default
 declared in this class.
 Each section describes the modifiers, the name, the return and parameter
 types, and the annotations of a method.
 It also contains the compiled code of the method, in the form of a sequence
 of Java bytecode instructions.
\end_layout

\begin_layout Standard
There are however some differences between source and compiled classes:
\end_layout

\begin_layout Itemize
A compiled class describes only one class, while a source file can contain
 several classes.
 For instance a source file describing a class with one inner class is compiled
 in two class files: one for the main class and one for the inner class.
 However the main class file contains 
\emph on
references
\emph default
 to its inner classes, and inner classes defined inside methods contain
 a 
\emph on
reference
\emph default
 to their enclosing method.
\end_layout

\begin_layout Itemize
A compiled class does not contain comments, of course, but can contain class,
 field, method and code 
\emph on
attributes
\emph default

\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
attributes
\end_layout

\end_inset

 that can be used to associate additional information to these elements.
 Since the introduction of annotations in Java 5, which can be used for
 the same purpose, attributes have become mostly useless.
\end_layout

\begin_layout Itemize
A compiled class does not contain a 
\family typewriter
package
\family default
 and 
\family typewriter
import
\family default
 section, so all type names must be fully qualified.
\end_layout

\begin_layout Standard
Another very important structural difference is that a compiled class contains
 a 
\emph on
constant pool
\emph default

\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
constant pool
\end_layout

\end_inset

 section.
 This pool is an array containing all the numeric, string and type constants
 that appear in the class.
 These constants are defined only once, in the constant pool section, and
 are referenced by their index in all other sections of the class file.
 Hopefully ASM hides all the details related to the constant pool, so you
 will not have to bother about it.
 Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Overall-structure-of-class-file"

\end_inset

 summarizes the overall structure of a compiled class.
 The exact structure is described in the Java Virtual Machine Specification,
 section 4.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="14" columns="2">
<features tabularvalignment="middle">
<column alignment="left" valignment="top" width="0">
<column alignment="left" valignment="top" width="0">
<row>
<cell multicolumn="1" alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Modifiers, name, super class, interfaces
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell multicolumn="1" alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Constant pool: numeric, string and type constants
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell multicolumn="1" alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Source file name (optional)
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell multicolumn="1" alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Enclosing class reference
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell multicolumn="1" alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Annotation*
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell multicolumn="1" alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Attribute*
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Inner class*
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Name
\end_layout

\end_inset
</cell>
</row>
<row>
<cell multicolumn="1" alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Field*
\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Modifiers, name, type
\end_layout

\end_inset
</cell>
</row>
<row>
<cell multicolumn="1" alignment="left" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Annotation*
\end_layout

\end_inset
</cell>
</row>
<row>
<cell multicolumn="1" alignment="left" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Attribute*
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Method*
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Modifiers, name, return and parameter types
\end_layout

\end_inset
</cell>
</row>
<row>
<cell multicolumn="1" alignment="left" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Annotation*
\end_layout

\end_inset
</cell>
</row>
<row>
<cell multicolumn="1" alignment="left" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Attribute*
\end_layout

\end_inset
</cell>
</row>
<row>
<cell multicolumn="1" alignment="left" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Compiled code
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Overall-structure-of-class-file"

\end_inset

Overall structure of a compiled class (* means zero or more)
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Another important difference is that Java types are represented differently
 in compiled and source classes.
 The next sections explain their representation in compiled classes.
\end_layout

\begin_layout Subsection
Internal names
\begin_inset CommandInset label
LatexCommand label
name "sub:Internal-names"

\end_inset


\end_layout

\begin_layout Standard
In many situations a type is constrained to be a class or interface type.
 For instance the super class of a class, the interfaces implemented by
 a class, or the exceptions thrown by a method cannot be primitive types
 or array types, and are necessarily class or interface types.
 These types are represented in compiled classes with 
\emph on
internal names
\emph default

\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
internal name
\end_layout

\end_inset

.
 The internal name of a class is just the fully qualified name of this class,
 where dots are replaced with slashes.
 For example the internal name of 
\family typewriter
String
\family default
 is 
\family typewriter
java/lang/String
\family default
.
\end_layout

\begin_layout Subsection
Type descriptors
\begin_inset CommandInset label
LatexCommand label
name "sub:Type-descriptors"

\end_inset


\end_layout

\begin_layout Standard
Internal names are used only for types that are constrained to be class
 or interface types.
 In all other situations, such as field types, Java types are represented
 in compiled classes with 
\emph on
type descriptors
\emph default

\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
type descriptor
\end_layout

\end_inset

 (see Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Type-descriptors"

\end_inset

).
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="12" columns="2">
<features tabularvalignment="middle">
<column alignment="left" valignment="top" width="0">
<column alignment="left" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Java type
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Type descriptor
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
boolean
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
Z
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
char
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
C
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
byte
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
B
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
short
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
S
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
int
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
I
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
float
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
F
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
long
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
J
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
double
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
D
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
Object
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
Ljava/lang/Object;
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
int[]
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
[I
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
Object[][]
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
[[Ljava/lang/Object;
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Type-descriptors"

\end_inset

Type descriptors of some Java types
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
The descriptors of the primitive types are single characters: 
\family typewriter
Z
\family default
 for 
\family typewriter
boolean
\family default
, 
\family typewriter
C
\family default
 for 
\family typewriter
char
\family default
, 
\family typewriter
B
\family default
 for 
\family typewriter
byte
\family default
, 
\family typewriter
S
\family default
 for 
\family typewriter
short
\family default
, 
\family typewriter
I
\family default
 for 
\family typewriter
int
\family default
, 
\family typewriter
F
\family default
 for 
\family typewriter
float
\family default
, 
\family typewriter
J
\family default
 for 
\family typewriter
long
\family default
 and 
\family typewriter
D
\family default
 for 
\family typewriter
double
\family default
.
 The descriptor of a class type is the internal name of this class, preceded
 by 
\family typewriter
L
\family default
 and followed by a semicolon.
 For instance the type descriptor of 
\family typewriter
String
\family default
 is 
\family typewriter
Ljava/lang/String;
\family default
.
 Finally the descriptor of an array type is a square bracket followed by
 the descriptor of the array element type.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Description
Note: in the ASM API, and unless stated otherwise, fields and method arguments
 named 
\family typewriter
desc
\family default
 are type descriptors.
 Other type arguments are internal names.
 When in doubt, recall that internal names are used for types that are constrain
ed to be class types.
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Method descriptors
\end_layout

\begin_layout Standard
A 
\emph on
method descriptor
\emph default

\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
method descriptor
\end_layout

\end_inset

 is a list of type descriptors that describe the parameter types and the
 return type of a method, in a single string.
 A method descriptor starts with a left parenthesis, followed by the type
 descriptors of each formal parameter, followed by a right parenthesis,
 followed by the type descriptor of the return type, or 
\family typewriter
V
\family default
 if the method returns 
\family typewriter
void
\family default
 (a method descriptor does not contain the method's name or the argument
 names).
 
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="5" columns="2">
<features tabularvalignment="middle">
<column alignment="left" valignment="top" width="0">
<column alignment="left" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Method declaration in source file
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Method descriptor
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
void m(int i, float f)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
(IF)V
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
int m(Object o)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
(Ljava/lang/Object;)I
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
int[] m(int i, String s)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
(ILjava/lang/String;)[I
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
Object m(int[] i)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
([I)Ljava/lang/Object;
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Sample-method-descriptors"

\end_inset

Sample method descriptors
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Once you know how type descriptors work, understanding method descriptors
 is easy.
 For instance 
\family typewriter
(I)I
\family default
 describes a method that takes one argument of type 
\family typewriter
int
\family default
, and returns an 
\family typewriter
int
\family default
.
 Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Sample-method-descriptors"

\end_inset

 gives several method descriptor examples.
\end_layout

\begin_layout Section
Interfaces and components
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
classes!core API
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Presentation
\begin_inset CommandInset label
LatexCommand label
name "sub:Classes-CoreAPI"

\end_inset


\end_layout

\begin_layout Standard
The ASM API for generating and transforming compiled classes is based on
 the 
\family typewriter
ClassVisitor
\family default
 abstract class (see Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:The-ClassVisitor-interface"

\end_inset

).
 Each method in this class corresponds to the class file structure section
 of the same name (see Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Overall-structure-of-class-file"

\end_inset

).
 Simple sections are visited with a single method call whose arguments describe
 their content, and which returns 
\family typewriter
void
\family default
.
 Sections whose content can be of arbitrary length and complexity are visited
 with a initial method call that returns an auxiliary visitor class.
 This is the case of the 
\family typewriter
visitAnnotation
\family default
, 
\family typewriter
visitField
\family default
 and 
\family typewriter
visitMethod
\family default
 methods, which return an 
\family typewriter
AnnotationVisitor
\family default
, a 
\family typewriter
FieldVisitor
\family default
 and a 
\family typewriter
MethodVisitor
\family default
 respectively.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout LyX-Code
public abstract class 
\series bold
ClassVisitor
\series default
 {
\end_layout

\begin_layout LyX-Code
  public ClassVisitor(int api);
\end_layout

\begin_layout LyX-Code
  public ClassVisitor(int api, ClassVisitor cv);
\end_layout

\begin_layout LyX-Code
  public void 
\series bold
visit
\series default
(int version, int access, String name, 
\end_layout

\begin_layout LyX-Code
      String signature, String superName, String[] interfaces);
\end_layout

\begin_layout LyX-Code
  public void 
\series bold
visitSource
\series default
(String source, String debug);
\end_layout

\begin_layout LyX-Code
  public void 
\series bold
visitOuterClass
\series default
(String owner, String name, String desc);
\end_layout

\begin_layout LyX-Code
  AnnotationVisitor 
\series bold
visitAnnotation
\series default
(String desc, boolean visible);
\end_layout

\begin_layout LyX-Code
  public void 
\series bold
visitAttribute
\series default
(Attribute attr);
\end_layout

\begin_layout LyX-Code
  public void 
\series bold
visitInnerClass
\series default
(String name, String outerName,
\end_layout

\begin_layout LyX-Code
      String innerName, int access);
\end_layout

\begin_layout LyX-Code
  public FieldVisitor 
\series bold
visitField
\series default
(int access, String name, String desc,
\end_layout

\begin_layout LyX-Code
      String signature, Object value);
\end_layout

\begin_layout LyX-Code
  public MethodVisitor 
\series bold
visitMethod
\series default
(int access, String name, String desc,
\end_layout

\begin_layout LyX-Code
      String signature, String[] exceptions);
\end_layout

\begin_layout LyX-Code
  void 
\series bold
visitEnd
\series default
();
\end_layout

\begin_layout LyX-Code
}
\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:The-ClassVisitor-interface"

\end_inset

The 
\family typewriter
ClassVisitor
\family default

\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
ClassVisitor@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
texttt{ClassVisitor}
\end_layout

\end_inset


\end_layout

\end_inset

 class
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
The same principles are used recursively for these auxiliary classes.
 For example each method in the 
\family typewriter
FieldVisitor
\family default
 abstract class (see Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:The-FieldVisitor-interface"

\end_inset

) corresponds to the class file sub structure of the same name, and 
\family typewriter
visitAnnotation
\family default
 returns an auxiliary 
\family typewriter
AnnotationVisitor
\family default
, as in 
\family typewriter
ClassVisitor
\family default
.
 The creation and usage of these auxiliary visitors is explained in the
 next chapters: indeed this chapter is restricted to simple problems that
 can be solved with the 
\family typewriter
ClassVisitor
\family default
 class alone.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout LyX-Code
public abstract class 
\series bold
FieldVisitor
\series default
 {
\end_layout

\begin_layout LyX-Code
  public FieldVisitor(int api);
\end_layout

\begin_layout LyX-Code
  public FieldVisitor(int api, FieldVisitor fv);
\end_layout

\begin_layout LyX-Code
  public AnnotationVisitor 
\series bold
visitAnnotation
\series default
(String desc, boolean visible);
\end_layout

\begin_layout LyX-Code
  public void 
\series bold
visitAttribute
\series default
(Attribute attr);
\end_layout

\begin_layout LyX-Code
  public void 
\series bold
visitEnd
\series default
();
\end_layout

\begin_layout LyX-Code
}
\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:The-FieldVisitor-interface"

\end_inset

The 
\family typewriter
FieldVisitor
\family default

\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
FieldVisitor@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
texttt{FieldVisitor}
\end_layout

\end_inset


\end_layout

\end_inset

 class
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
The methods of the 
\family typewriter
ClassVisitor
\family default
 class must be called in the following order, specified in the Javadoc of
 this class:
\end_layout

\begin_layout LyX-Code

\family typewriter
visit
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

{
\backslash
normalfont~}
\end_layout

\end_inset

visitSource
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

{
\backslash
normalfont?~}
\end_layout

\end_inset

visitOuterClass
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

{
\backslash
normalfont?~(~}
\end_layout

\end_inset

visitAnnotation
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

{
\backslash
normalfont~|~}
\end_layout

\end_inset

visitAttribute
\family default

\begin_inset ERT
status collapsed

\begin_layout Plain Layout

{
\backslash
normalfont~)*}
\end_layout

\end_inset


\end_layout

\begin_layout LyX-Code

\family typewriter
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

{
\backslash
normalfont(~}
\end_layout

\end_inset

visitInnerClass
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

{
\backslash
normalfont~|~}
\end_layout

\end_inset

visitField
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

{
\backslash
normalfont~|~}
\end_layout

\end_inset

visitMethod
\family default

\begin_inset ERT
status collapsed

\begin_layout Plain Layout

{
\backslash
normalfont~)*}
\end_layout

\end_inset


\end_layout

\begin_layout LyX-Code

\family typewriter
visitEnd
\end_layout

\begin_layout Standard
This means that 
\family typewriter
visit
\family default
 must be called first, followed by at most one call to 
\family typewriter
visitSource
\family default
, followed by at most one call to 
\family typewriter
visitOuterClass
\family default
, followed by any number of calls in any order to 
\family typewriter
visitAnnotation
\family default
 and 
\family typewriter
visitAttribute
\family default
, followed by any number of calls in any order to 
\family typewriter
visitInnerClass
\family default
, 
\family typewriter
visitField
\family default
 and 
\family typewriter
visitMethod
\family default
, and terminated by a single call to 
\family typewriter
visitEnd
\family default
.
\end_layout

\begin_layout Standard
ASM provides three core components based on the 
\family typewriter
ClassVisitor
\family default
 API to generate and transform classes:
\end_layout

\begin_layout Itemize
The 
\family typewriter
ClassReader
\family default

\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
ClassReader@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
texttt{ClassReader}
\end_layout

\end_inset


\end_layout

\end_inset

 class parses a compiled class given as a byte array, and calls the correspondin
g 
\family typewriter
visit
\emph on
Xxx
\family default
\emph default
 methods on the 
\family typewriter
ClassVisitor
\family default
 instance passed as argument to its 
\family typewriter
accept
\family default
 method.
 It can be seen as an event producer.
\end_layout

\begin_layout Itemize
The 
\family typewriter
ClassWriter
\family default

\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
ClassWriter@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
texttt{ClassWriter}
\end_layout

\end_inset


\end_layout

\end_inset

 class is a subclass of the 
\family typewriter
ClassVisitor
\family default
 abstract class that builds compiled classes directly in binary form.
 It produces as output a byte array containing the compiled class, which
 can be retrieved with the 
\family typewriter
toByteArray
\family default
 method.
 It can be seen as an event consumer.
\end_layout

\begin_layout Itemize
The 
\family typewriter
ClassVisitor
\family default
 class delegates all the method calls it receives to another 
\family typewriter
ClassVisitor
\family default
 instance.
 It can be seen as an event filter.
\end_layout

\begin_layout Standard
The next sections show with concrete examples how these components can be
 used to generate and transform classes.
\end_layout

\begin_layout Subsection
Parsing classes
\begin_inset CommandInset label
LatexCommand label
name "sub:Parsing-classes-coreAPI"

\end_inset


\end_layout

\begin_layout Standard
The only required component to parse
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
classes!parsing
\end_layout

\end_inset

 an existing class is the 
\family typewriter
ClassReader
\family default
 component.
 Let's take an example to illustrate this.
 Suppose that we would like to print the content of a class, in a similar
 way as the 
\family typewriter
javap
\family default
 tool.
 The first step is to write a subclass of the 
\family typewriter
ClassVisitor
\family default
 class that prints information about the classes it visits.
 Here is a possible, overly simplified implementation:
\end_layout

\begin_layout LyX-Code
public class 
\series bold
ClassPrinter
\series default
 extends 
\series bold
ClassVisitor
\series default
 {
\end_layout

\begin_layout LyX-Code
  public ClassPrinter() {
\end_layout

\begin_layout LyX-Code
    super(ASM4);
\end_layout

\begin_layout LyX-Code
  }
\end_layout

\begin_layout LyX-Code
  public void visit(int version, int access, String name,
\end_layout

\begin_layout LyX-Code
      String signature, String superName, String[] interfaces) {
\end_layout

\begin_layout LyX-Code
    
\series bold
System.out.println(name + " extends " + superName + " {");
\end_layout

\begin_layout LyX-Code
  }
\end_layout

\begin_layout LyX-Code
  public void visitSource(String source, String debug) {
\end_layout

\begin_layout LyX-Code
  }
\end_layout

\begin_layout LyX-Code
  public void visitOuterClass(String owner, String name, String desc) {
\end_layout

\begin_layout LyX-Code
  }
\end_layout

\begin_layout LyX-Code
  public AnnotationVisitor visitAnnotation(String desc,
\end_layout

\begin_layout LyX-Code
      boolean visible) {
\end_layout

\begin_layout LyX-Code
    return null;
\end_layout

\begin_layout LyX-Code
  }
\end_layout

\begin_layout LyX-Code
  public void visitAttribute(Attribute attr) {
\end_layout

\begin_layout LyX-Code
  }
\end_layout

\begin_layout LyX-Code
  public void visitInnerClass(String name, String outerName,
\end_layout

\begin_layout LyX-Code
      String innerName, int access) {
\end_layout

\begin_layout LyX-Code
  }
\end_layout

\begin_layout LyX-Code
  public FieldVisitor visitField(int access, String name, String desc,
\end_layout

\begin_layout LyX-Code
      String signature, Object value) {
\end_layout

\begin_layout LyX-Code
    
\series bold
System.out.println("    " + desc + " " + name);
\end_layout

\begin_layout LyX-Code
    return null;
\end_layout

\begin_layout LyX-Code
  }
\end_layout

\begin_layout LyX-Code
  public MethodVisitor visitMethod(int access, String name,
\end_layout

\begin_layout LyX-Code
      String desc, String signature, String[] exceptions) {
\end_layout

\begin_layout LyX-Code
    
\series bold
System.out.println("    " + name + desc);
\end_layout

\begin_layout LyX-Code
    return null;
\end_layout

\begin_layout LyX-Code
  }
\end_layout

\begin_layout LyX-Code
  public void visitEnd() {
\end_layout

\begin_layout LyX-Code
    
\series bold
System.out.println("}");
\end_layout

\begin_layout LyX-Code
  }
\end_layout

\begin_layout LyX-Code
}
\end_layout

\begin_layout Standard
The second step is to combine this 
\family typewriter
ClassPrinter
\family default
 with a 
\family typewriter
ClassReader
\family default
 component, so that the events produced by the 
\family typewriter
ClassReader
\family default
 are consumed by our 
\family typewriter
ClassPrinter
\family default
:
\end_layout

\begin_layout LyX-Code
ClassPrinter cp = new ClassPrinter();
\end_layout

\begin_layout LyX-Code
ClassReader cr = new ClassReader("java.lang.Runnable");
\end_layout

\begin_layout LyX-Code
cr.accept(cp, 0);
\end_layout

\begin_layout Standard
The second line creates a 
\family typewriter
ClassReader
\family default
 to parse the 
\family typewriter
Runnable
\family default
 class.
 The 
\family typewriter
accept
\family default
 method called at the last line parses the 
\family typewriter
Runnable
\family default
 class bytecode and calls the corresponding 
\family typewriter
ClassVisitor
\family default
 methods on 
\family typewriter
cp
\family default
.
 The result is the following output:
\end_layout

\begin_layout LyX-Code
java/lang/Runnable extends java/lang/Object {
\end_layout

\begin_layout LyX-Code
    run()V
\end_layout

\begin_layout LyX-Code
}
\end_layout

\begin_layout Standard
Note that there are several ways to construct
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
ClassReader@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
texttt{ClassReader}!constructors
\end_layout

\end_inset


\end_layout

\end_inset

 a 
\family typewriter
ClassReader
\family default
 instance.
 The class that must be read can be specified by name, as above, or by value,
 as a byte array or as an 
\family typewriter
InputStream
\family default
.
 An input stream to read the content of a class can be obtained with the
 
\family typewriter
ClassLoader
\family default
's 
\family typewriter
getResourceAsStream
\family default
 method with:
\end_layout

\begin_layout LyX-Code

\shape slanted
cl
\shape default
.getResourceAsStream(
\shape slanted
classname
\shape default
.replace('.', '/') + ".class");
\end_layout

\begin_layout Subsection
Generating classes
\begin_inset CommandInset label
LatexCommand label
name "sub:Generating-classes-CoreAPI"

\end_inset


\end_layout

\begin_layout Standard
The only required component to generate
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
classes!generating
\end_layout

\end_inset

 a class is the 
\family typewriter
ClassWriter
\family default
 component.
 Let's take an example to illustrate this.
 Consider the following interface:
\end_layout

\begin_layout LyX-Code
package pkg;
\end_layout

\begin_layout LyX-Code
public interface Comparable extends Mesurable {
\end_layout

\begin_layout LyX-Code
  int LESS = -1;
\end_layout

\begin_layout LyX-Code
  int EQUAL = 0;
\end_layout

\begin_layout LyX-Code
  int GREATER = 1;
\end_layout

\begin_layout LyX-Code
  int compareTo(Object o);
\end_layout

\begin_layout LyX-Code
}
\end_layout

\begin_layout Standard
It can be generated with six method calls to a 
\family typewriter
ClassVisitor
\family default
:
\end_layout

\begin_layout LyX-Code
ClassWriter cw = 
\series bold
new ClassWriter(0)
\series default
;
\end_layout

\begin_layout LyX-Code
cw.
\series bold
visit
\series default
(V1_5, ACC_PUBLIC + ACC_ABSTRACT + ACC_INTERFACE,
\end_layout

\begin_layout LyX-Code
    "pkg/Comparable", null, "java/lang/Object",
\end_layout

\begin_layout LyX-Code
    new String[] { "pkg/Mesurable" });
\end_layout

\begin_layout LyX-Code
cw.
\series bold
visitField
\series default
(ACC_PUBLIC + ACC_FINAL + ACC_STATIC, "LESS", "I",
\end_layout

\begin_layout LyX-Code
    null, new Integer(-1)).visitEnd();
\end_layout

\begin_layout LyX-Code
cw.
\series bold
visitField
\series default
(ACC_PUBLIC + ACC_FINAL + ACC_STATIC, "EQUAL", "I",
\end_layout

\begin_layout LyX-Code
    null, new Integer(0)).visitEnd();
\end_layout

\begin_layout LyX-Code
cw.
\series bold
visitField
\series default
(ACC_PUBLIC + ACC_FINAL + ACC_STATIC, "GREATER", "I",
\end_layout

\begin_layout LyX-Code
    null, new Integer(1)).visitEnd();
\end_layout

\begin_layout LyX-Code
cw.
\series bold
visitMethod
\series default
(ACC_PUBLIC + ACC_ABSTRACT, "compareTo",
\end_layout

\begin_layout LyX-Code
    "(Ljava/lang/Object;)I", null, null).visitEnd();
\end_layout

\begin_layout LyX-Code
cw.
\series bold
visitEnd
\series default
();
\end_layout

\begin_layout LyX-Code
byte[] b = cw.
\series bold
toByteArray
\series default
();
\end_layout

\begin_layout Standard
The first line creates a 
\family typewriter
ClassWriter
\family default
 instance that will actually build the byte array representation of the
 class (the constructor argument is explained in the next chapter).
\end_layout

\begin_layout Standard
The call to the 
\family typewriter
visit
\family default
 method defines the class header.
 The 
\family typewriter
V1_5
\family default
 argument is a constant defined, like all other ASM constants, in the ASM
 
\family typewriter
Opcodes
\family default

\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
Opcodes@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
texttt{Opcodes}
\end_layout

\end_inset


\end_layout

\end_inset

 interface.
 It specifies the class version, Java 1.5.
 The 
\family typewriter
ACC_
\emph on
XXX
\family default
\emph default
 constants are flags that correspond to Java modifiers.
 Here we specify that the class is an interface, and that it is 
\family typewriter
public
\family default
 and 
\family typewriter
abstract
\family default
 (because it cannot be instantiated).
 The next argument specifies the class name, in internal form (see section
 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Internal-names"

\end_inset

).
 Recall that compiled classes do not contain a package or import section,
 so all class names must be fully qualified.
 The next argument corresponds to generics (see section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Generics"

\end_inset

).
 In our case it is 
\family typewriter
null
\family default
 because the interface is not parameterized by a type variable.
 The fifth argument is the super class, in internal form (interface classes
 implicitly inherit from 
\family typewriter
Object
\family default
).
 The last argument is an array of the interfaces that are extended, specified
 by their internal names.
\end_layout

\begin_layout Standard
The next three calls to 
\family typewriter
visitField
\family default
 are similar, and are used to define the three interface fields.
 The first argument is a set of flags that correspond to Java modifiers.
 Here we specify that the fields are 
\family typewriter
public
\family default
, 
\family typewriter
final
\family default
 and 
\family typewriter
static
\family default
.
 The second argument is the name of the field, as it appears in source code.
 The third argument is the type of the field, in type descriptor form.
 Here the fields are 
\family typewriter
int
\family default
 fields, whose descriptor is 
\family typewriter
I
\family default
.
 The fourth argument corresponds to generics.
 In our case it is 
\family typewriter
null
\family default
 because the field types are not using generics.
 The last argument is the field's 
\emph on
constant
\emph default

\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
fields!constant value
\end_layout

\end_inset

 value: this argument must be used only for truly constant fields, i.e.
 
\family typewriter
final
\family default
 
\family typewriter
static
\family default
 fields.
 For other fields it must be 
\family typewriter
null
\family default
.
 Since there are no annotations here, we call the 
\family typewriter
visitEnd
\family default
 method of the returned 
\family typewriter
FieldVisitor
\family default
 immediately, i.e.
 without any call to its 
\family typewriter
visitAnnotation
\family default
 or 
\family typewriter
visitAttribute
\family default
 methods.
\end_layout

\begin_layout Standard
The 
\family typewriter
visitMethod
\family default
 call is used to define the 
\family typewriter
compareTo
\family default
 method.
 Here again the first argument is a set of flags that correspond to Java
 modifiers.
 The second argument is the method name, as it appears in source code.
 The third argument is the descriptor of the method.
 The fourth argument corresponds to generics.
 In our case it is 
\family typewriter
null
\family default
 because the method is not using generics.
 The last argument is an array of the exceptions
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
exceptions!declaration
\end_layout

\end_inset

 that can be thrown by the method, specified by their internal names.
 Here it is 
\family typewriter
null
\family default
 because the method does not declare any exception.
 The 
\family typewriter
visitMethod
\family default
 method returns a 
\family typewriter
MethodVisitor
\family default
 (see Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:The-MethodVisitor-interface"

\end_inset

), which can be used to define the method's annotations and attributes,
 and most importantly the method's code.
 Here, since there are no annotations and since the method is abstract,
 we call the 
\family typewriter
visitEnd
\family default
 method of the returned 
\family typewriter
MethodVisitor
\family default
 immediately.
\end_layout

\begin_layout Standard
Finally a last call to 
\family typewriter
visitEnd
\family default
 is used to inform 
\family typewriter
cw
\family default
 that the class is finished and a call to 
\family typewriter
toByteArray
\family default
 is used to retrieve it as a byte array.
\end_layout

\begin_layout Subsubsection*
Using generated classes
\end_layout

\begin_layout Standard
The previous byte array can be stored in a 
\family typewriter
Comparable.class
\family default
 file for future use.
 Alternatively it can be loaded
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
classes!loading
\end_layout

\end_inset

 dynamically with a 
\family typewriter
ClassLoader
\family default
.
 One method is to define a 
\family typewriter
ClassLoader
\family default
 subclass whose 
\family typewriter
defineClass
\family default
 method is public:
\end_layout

\begin_layout LyX-Code
  class MyClassLoader extends ClassLoader {
\end_layout

\begin_layout LyX-Code
    public Class defineClass(String name, byte[] b) {
\end_layout

\begin_layout LyX-Code
      return defineClass(name, b, 0, b.length);
\end_layout

\begin_layout LyX-Code
    }
\end_layout

\begin_layout LyX-Code
  }
\end_layout

\begin_layout Standard
Then the generated class can be loaded directly with:
\end_layout

\begin_layout LyX-Code
Class c = myClassLoader.defineClass("pkg.Comparable", b);
\end_layout

\begin_layout Standard
Another method to load a generated class, which is probably cleaner, is
 to define a 
\family typewriter
ClassLoader
\family default
 subclass whose 
\family typewriter
findClass
\family default
 method is overridden in order to generate the requested class on the fly:
\end_layout

\begin_layout LyX-Code
class StubClassLoader extends ClassLoader {
\end_layout

\begin_layout LyX-Code
  @Override 
\end_layout

\begin_layout LyX-Code
  protected Class findClass(String name)
\end_layout

\begin_layout LyX-Code
      throws ClassNotFoundException {
\end_layout

\begin_layout LyX-Code
    if (name.endsWith("_Stub")) {
\end_layout

\begin_layout LyX-Code
      ClassWriter cw = new ClassWriter(0);
\end_layout

\begin_layout LyX-Code
      ...
\end_layout

\begin_layout LyX-Code
      byte[] b = cw.toByteArray();
\end_layout

\begin_layout LyX-Code
      return defineClass(name, b, 0, b.length);
\end_layout

\begin_layout LyX-Code
    }
\end_layout

\begin_layout LyX-Code
    return super.findClass(name);
\end_layout

\begin_layout LyX-Code
  }
\end_layout

\begin_layout LyX-Code
}
\end_layout

\begin_layout Standard
In fact the way of using your generated classes depends on the context,
 and is out of scope of the ASM API.
 If you are writing a compiler, the class generation process will be driven
 by an abstract syntax tree representing the program to be compiled, and
 the generated classes will be stored on disk.
 If you are writing a dynamic proxy class generator or aspect weaver you
 will use, in one way or another, a 
\family typewriter
ClassLoader
\family default
.
\end_layout

\begin_layout Subsection
Transforming classes
\begin_inset CommandInset label
LatexCommand label
name "sub:Transforming-classes-CoreAPI"

\end_inset


\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
classes!transforming
\end_layout

\end_inset


\end_layout

\begin_layout Standard
So far the 
\family typewriter
ClassReader
\family default
 and 
\family typewriter
ClassWriter
\family default
 components were used alone.
 The events were produced 
\begin_inset Quotes eld
\end_inset

by hand
\begin_inset Quotes erd
\end_inset

 and consumed directly by a 
\family typewriter
ClassWriter
\family default
 or, symetrically, they were produced by a 
\family typewriter
ClassReader
\family default
 and consumed 
\begin_inset Quotes eld
\end_inset

by hand
\begin_inset Quotes erd
\end_inset

, i.e.
 by a custom 
\family typewriter
ClassVisitor
\family default
 implementation.
 Things start to become really interesting when these components are used
 together.
 The first step is to direct the events produced by a 
\family typewriter
ClassReader
\family default
 to a 
\family typewriter
ClassWriter
\family default
.
 The result is that the class parsed by the class reader is reconstructed
 by the class writer:
\end_layout

\begin_layout LyX-Code
byte[] b1 = ...;
\end_layout

\begin_layout LyX-Code
ClassWriter cw = new ClassWriter(0);
\end_layout

\begin_layout LyX-Code
ClassReader cr = new ClassReader(b1);
\end_layout

\begin_layout LyX-Code
cr.accept(cw, 0);
\end_layout

\begin_layout LyX-Code
byte[] b2 = cw.toByteArray(); // b2 represents the same class as b1
\end_layout

\begin_layout Standard
This is not really interesting in itself (there are easier ways to copy
 a byte array!), but wait.
 The next step is to introduce a 
\family typewriter
ClassVisitor
\family default
 between the class reader and the class writer:
\end_layout

\begin_layout LyX-Code
byte[] b1 = ...;
\end_layout

\begin_layout LyX-Code
ClassWriter cw = new ClassWriter(0);
\end_layout

\begin_layout LyX-Code
// cv forwards all events to cw
\end_layout

\begin_layout LyX-Code

\series bold
ClassVisitor cv = new ClassVisitor(ASM4, cw) { };
\end_layout

\begin_layout LyX-Code
ClassReader cr = new ClassReader(b1);
\end_layout

\begin_layout LyX-Code
cr.accept(
\series bold
cv
\series default
, 0);
\end_layout

\begin_layout LyX-Code
byte[] b2 = cw.toByteArray(); // b2 represents the same class as b1
\end_layout

\begin_layout Standard
The architecture corresponding to the above code is depicted in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:A-transformation-chain"

\end_inset

, where components are represented with squares, and events with arrows
 (with a vertical time line as in sequence diagrams).
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename figures/chain.eps
	scale 80
	clip

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:A-transformation-chain"

\end_inset

A transformation chain
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
transformation chain
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
The result does not change, however, because the 
\family typewriter
ClassVisitor
\family default
 event filter does not filter anything.
 But it is now sufficient to filter some events, by overriding some methods,
 in order to be able to transform a class.
 For example, consider the following 
\family typewriter
ClassVisitor
\family default
 subclass:
\end_layout

\begin_layout LyX-Code
public class ChangeVersionAdapter 
\series bold
extends ClassVisitor
\series default
 {
\end_layout

\begin_layout LyX-Code
  public ChangeVersionAdapter(ClassVisitor cv) {
\end_layout

\begin_layout LyX-Code
    super(ASM4, cv);
\end_layout

\begin_layout LyX-Code
  }
\end_layout

\begin_layout LyX-Code
  @Override 
\end_layout

\begin_layout LyX-Code
  public void visit(int version, int access, String name,
\end_layout

\begin_layout LyX-Code
      String signature, String superName, String[] interfaces) {
\end_layout

\begin_layout LyX-Code
    cv.visit(
\series bold
V1_5
\series default
, access, name, signature, superName, interfaces);
\end_layout

\begin_layout LyX-Code
  }
\end_layout

\begin_layout LyX-Code
}
\end_layout

\begin_layout Standard
This class overrides only one method of the 
\family typewriter
ClassVisitor
\family default
 class.
 As a consequence all calls are forwarded unchanged to the class visitor
 
\family typewriter
cv
\family default
 passed to the constructor, except calls to the 
\family typewriter
visit
\family default
 method, which are forwarded with a modified class version number.
 The corresponding sequence diagram is shown in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:ChangeVersionAdapter"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename figures/changeversion.eps
	scale 80

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:ChangeVersionAdapter"

\end_inset

Sequence diagram for the 
\family typewriter
ChangeVersionAdapter
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
By modifying other arguments of the 
\family typewriter
visit
\family default
 method you can implement other transformations than just changing the class
 version.
 For instance you can add an interface to the list of implemented interfaces.
 It is also possible to change the name of the class, 
\emph on
but this requires much more than just changing the
\emph default
 
\family typewriter
\emph on
name
\family default
\emph default
 
\emph on
argument in the
\emph default
 
\family typewriter
\emph on
visit
\family default
\emph default
 
\emph on
method
\emph default
.
 Indeed the name of the class can appear in many different places inside
 a compiled class, and 
\emph on
all
\emph default
 these occurrences must be changed to really rename the class.
\end_layout

\begin_layout Subsubsection*
Optimization
\end_layout

\begin_layout Standard
The previous transformation changes only four bytes in the original class.
 However, with the above code, 
\family typewriter
b1
\family default
 is fully parsed and the corresponding events are used to construct 
\family typewriter
b2
\family default
 from scratch, which is not very efficient.
 It would be much more efficient to copy the parts of 
\family typewriter
b1
\family default
 that are not transformed directly into 
\family typewriter
b2
\family default
, without parsing these parts and without generating the corresponding events.
 ASM automatically performs this optimization for methods: 
\end_layout

\begin_layout Itemize
If a 
\family typewriter
ClassReader
\family default
 component detects that a 
\family typewriter
MethodVisitor
\family default
 returned by the 
\family typewriter
ClassVisitor
\family default
 passed as argument to its 
\family typewriter
accept
\family default
 method comes from a 
\family typewriter
ClassWriter
\family default
, this means that the content of this method will not be transformed, and
 will in fact not even be 
\emph on
seen
\emph default
 by the application.
\end_layout

\begin_layout Itemize
In this case the 
\family typewriter
ClassReader
\family default
 component does not parse the content of this method, does not generate
 the corresponding events, and just copies the byte array representation
 of this method in the 
\family typewriter
ClassWriter
\family default
.
\end_layout

\begin_layout Standard
This optimization
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
ClassWriter@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
texttt{ClassWriter}!constructors
\end_layout

\end_inset


\end_layout

\end_inset

 is performed by the 
\family typewriter
ClassReader
\family default
 and 
\family typewriter
ClassWriter
\family default
 components if they have a reference to each other, which can be set like
 this:
\end_layout

\begin_layout LyX-Code
byte[] b1 = ...
\end_layout

\begin_layout LyX-Code
ClassReader cr = new ClassReader(b1);
\end_layout

\begin_layout LyX-Code
ClassWriter cw = new ClassWriter(
\series bold
cr
\series default
, 0);
\end_layout

\begin_layout LyX-Code
ChangeVersionAdapter ca = new ChangeVersionAdapter(cw);
\end_layout

\begin_layout LyX-Code
cr.accept(ca, 0);
\end_layout

\begin_layout LyX-Code
byte[] b2 = cw.toByteArray();
\end_layout

\begin_layout Standard
Thanks to this optimization the above code is 
\emph on
two times
\emph default
 faster than the previous one, because 
\family typewriter
ChangeVersionAdapter
\family default
 does not transform any method.
 For common class transformations, which transform some or all methods,
 the speedup is smaller, but is still noticeable: it is indeed of the order
 of 
\begin_inset Formula $10$
\end_inset

 to 
\begin_inset Formula $20\%$
\end_inset

.
 Unfortunately this optimization requires to copy all the constants defined
 in the original class into the transformed one.
 This is not a problem for tranformations that 
\emph on
add
\emph default
 fields, methods or instructions, but this leads to bigger class files,
 compared to the unoptimized case, for transformations that 
\emph on
remove
\emph default
 or 
\emph on
rename
\emph default
 many class elements.
 It is therefore recommanded to use this optimization only for 
\begin_inset Quotes eld
\end_inset

additive
\begin_inset Quotes erd
\end_inset

 transformations.
\end_layout

\begin_layout Subsubsection*
Using transformed classes
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
classes!loading
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The transformed class 
\family typewriter
b2
\family default
 can be stored on disk or loaded with a 
\family typewriter
ClassLoader
\family default
, as described in the previous section.
 But class transformations done inside a 
\family typewriter
ClassLoader
\family default
 can only transform the classes loaded by this class loader.
 If you want to transform 
\emph on
all
\emph default
 classes you will have to put your transformation inside a 
\family typewriter
ClassFileTransformer
\family default
, as defined in the 
\family typewriter
java.lang.instrument
\family default
 package (see the documentation of this package for more details):
\end_layout

\begin_layout LyX-Code
public static void premain(String agentArgs, Instrumentation inst) {
\end_layout

\begin_layout LyX-Code
  inst.addTransformer(new ClassFileTransformer() {
\end_layout

\begin_layout LyX-Code
    public byte[] transform(ClassLoader l, String name, Class c,
\end_layout

\begin_layout LyX-Code
        ProtectionDomain d, byte[] b)
\end_layout

\begin_layout LyX-Code
        throws IllegalClassFormatException {
\end_layout

\begin_layout LyX-Code
      ClassReader cr = new ClassReader(b);
\end_layout

\begin_layout LyX-Code
      ClassWriter cw = new ClassWriter(cr, 0);
\end_layout

\begin_layout LyX-Code
      ClassVisitor cv = new ChangeVersionAdapter(cw);
\end_layout

\begin_layout LyX-Code
      cr.accept(cv, 0);
\end_layout

\begin_layout LyX-Code
      return cw.toByteArray();
\end_layout

\begin_layout LyX-Code
    }
\end_layout

\begin_layout LyX-Code
  });
\end_layout

\begin_layout LyX-Code
}
\end_layout

\begin_layout Subsection
Removing class members
\begin_inset CommandInset label
LatexCommand label
name "sub:Removing-class-members-coreAPI"

\end_inset


\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
classes!removing members
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The method used to transform the class version in the previous section can
 of course be applied to other methods of the 
\family typewriter
ClassVisitor
\family default
 class.
 For instance, by changing the 
\family typewriter
access
\family default
 or 
\family typewriter
name
\family default
 argument in the 
\family typewriter
visitField
\family default
 and 
\family typewriter
visitMethod
\family default
 methods, you can change the modifiers or the name of a field or of a method.
 Furthermore, instead of forwarding a method call with modified arguments,
 you can choose to 
\emph on
not
\emph default
 forward this call at all.
 The effect is that the corresponding class element is 
\emph on
removed
\emph default
.
\end_layout

\begin_layout Standard
For example the following class adapter removes the information about outer
 and inner classes, as well as the name of the source file from which the
 class was compiled (the resulting class remains fully functional, because
 these elements are only used for debugging purposes).
 This is done by not forwarding anything in the appropriate visit methods:
\end_layout

\begin_layout LyX-Code
public class RemoveDebugAdapter extends ClassVisitor {
\end_layout

\begin_layout LyX-Code
  public RemoveDebugAdapter(ClassVisitor cv) {
\end_layout

\begin_layout LyX-Code
    super(ASM4, cv);
\end_layout

\begin_layout LyX-Code
  }
\end_layout

\begin_layout LyX-Code
  @Override 
\end_layout

\begin_layout LyX-Code
  public void visitSource(String source, String debug) {
\end_layout

\begin_layout LyX-Code
  }
\end_layout

\begin_layout LyX-Code
  @Override
\end_layout

\begin_layout LyX-Code
  public void visitOuterClass(String owner, String name, String desc) {
\end_layout

\begin_layout LyX-Code
  }
\end_layout

\begin_layout LyX-Code
  @Override
\end_layout

\begin_layout LyX-Code
  public void visitInnerClass(String name, String outerName,
\end_layout

\begin_layout LyX-Code
      String innerName, int access) {
\end_layout

\begin_layout LyX-Code
  }
\end_layout

\begin_layout LyX-Code
}
\end_layout

\begin_layout Standard
This strategy does not work for fields and methods, because the 
\family typewriter
visitField
\family default
 and 
\family typewriter
visitMethod
\family default
 methods must return a result.
 In order to remove a field
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
fields!removing
\end_layout

\end_inset

 or method, you must not forward the method call, and return 
\family typewriter
null
\family default
 to the caller.
 For example the following class adapter removes a single method
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
methods!removing
\end_layout

\end_inset

, specified by its name and by its descriptor (the name is not sufficient
 to identify a method, because a class can contain several methods of the
 same name but with different parameters):
\end_layout

\begin_layout LyX-Code
public class RemoveMethodAdapter extends ClassVisitor {
\end_layout

\begin_layout LyX-Code
  private String mName;
\end_layout

\begin_layout LyX-Code
  private String mDesc;
\end_layout

\begin_layout LyX-Code
  public RemoveMethodAdapter(
\end_layout

\begin_layout LyX-Code
      ClassVisitor cv, String mName, String mDesc) {
\end_layout

\begin_layout LyX-Code
    super(ASM4, cv);
\end_layout

\begin_layout LyX-Code
    this.mName = mName;
\end_layout

\begin_layout LyX-Code
    this.mDesc = mDesc;
\end_layout

\begin_layout LyX-Code
  }
\end_layout

\begin_layout LyX-Code
  @Override
\end_layout

\begin_layout LyX-Code
  public MethodVisitor visitMethod(int access, String name,
\end_layout

\begin_layout LyX-Code
      String desc, String signature, String[] exceptions) {
\end_layout

\begin_layout LyX-Code
    
\series bold
if (name.equals(mName) && desc.equals(mDesc)) {
\end_layout

\begin_layout LyX-Code
 
\series bold
     // do not delegate to next visitor -> this removes the method
\end_layout

\begin_layout LyX-Code
 
\series bold
     return null;
\end_layout

\begin_layout LyX-Code
 
\series bold
   }
\end_layout

\begin_layout LyX-Code
    return cv.visitMethod(access, name, desc, signature, exceptions);
\end_layout

\begin_layout LyX-Code
  }
\end_layout

\begin_layout LyX-Code
}
\end_layout

\begin_layout Subsection
Adding class members
\begin_inset CommandInset label
LatexCommand label
name "sub:Adding-class-members-coreAPI"

\end_inset


\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
classes!adding members
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Instead of forwarding fewer calls than you receive, you can 
\begin_inset Quotes eld
\end_inset

forward
\begin_inset Quotes erd
\end_inset

 more, which has the effect of 
\emph on
adding
\emph default
 class elements.
 The new calls can be inserted at several places between the original method
 calls, provided that the order in which the various 
\family typewriter
visit
\emph on
Xxx
\family default
\emph default
 methods must be called is respected (see section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Classes-CoreAPI"

\end_inset

).
\end_layout

\begin_layout Standard
For instance, if you want to add a field
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
fields!adding
\end_layout

\end_inset

 to a class you have to insert a new call to 
\family typewriter
visitField
\family default
 between the original method calls, and you must put this new call in one
 of the visit method of your class adapter.
 You cannot do this in the 
\family typewriter
visit
\family default
 method, for example, because this may result in a call to 
\family typewriter
visitField
\family default
 followed by 
\family typewriter
visitSource
\family default
, 
\family typewriter
visitOuterClass
\family default
, 
\family typewriter
visitAnnotation
\family default
 or 
\family typewriter
visitAttribute
\family default
, which is not valid.
 You cannot put this new call in the 
\family typewriter
visitSource
\family default
, 
\family typewriter
visitOuterClass
\family default
, 
\family typewriter
visitAnnotation
\family default
 or 
\family typewriter
visitAttribute
\family default
 methods, for the same reason.
 The only possibilities are the 
\family typewriter
visitInnerClass
\family default
, 
\family typewriter
visitField
\family default
, 
\family typewriter
visitMethod
\family default
 or 
\family typewriter
visitEnd
\family default
 methods.
\end_layout

\begin_layout Standard
If you put the new call in the 
\family typewriter
visitEnd
\family default
 method the field will always be added (unless you add explicit conditions),
 because this method is always called.
 If you put it in 
\family typewriter
visitField
\family default
 or 
\family typewriter
visitMethod
\family default
, 
\emph on
several
\emph default
 fields will be added: one per field or method in the original class.
 Both solutions can make sense; it depends on what you need.
 For instance you can add a single counter field to count the invocations
 on an object, or one counter per method, to count the invocations of each
 method separately.
 
\end_layout

\begin_layout Description
Note: in fact the only truly correct solution is to add new members by making
 additional calls in the 
\family typewriter
visitEnd
\family default
 method.
 Indeed a class must not contain duplicate members, and the only way to
 be sure that a new member is unique is to compare it with all the existing
 members, which can only be done once they have all been visited, i.e.
 in the 
\family typewriter
visitEnd
\family default
 method.
 This is rather constraining.
 Using generated names that are unlikely to be used by a programmer, such
 as 
\family typewriter
_counter$
\family default
 or 
\family typewriter
_4B7F_
\family default
 is sufficient in practice to avoid duplicate members without having to
 add them in 
\family typewriter
visitEnd
\family default
.
 Note that, as discussed in the first chapter, the tree API does not have
 this limitation: it is possible to add new members at any time inside a
 transformation with this API.
\end_layout

\begin_layout Standard
In order to illustrate the above discussion, here is a class adapter that
 adds a field to a class, unless this field already exists:
\end_layout

\begin_layout LyX-Code
public class AddFieldAdapter extends ClassVisitor {
\end_layout

\begin_layout LyX-Code
  private int fAcc;
\end_layout

\begin_layout LyX-Code
  private String fName;
\end_layout

\begin_layout LyX-Code
  private String fDesc;
\end_layout

\begin_layout LyX-Code
  private boolean isFieldPresent;
\end_layout

\begin_layout LyX-Code
  public AddFieldAdapter(ClassVisitor cv, int fAcc, String fName,
\end_layout

\begin_layout LyX-Code
      String fDesc) {
\end_layout

\begin_layout LyX-Code
    super(ASM4, cv);
\end_layout

\begin_layout LyX-Code
    this.fAcc = fAcc;
\end_layout

\begin_layout LyX-Code
    this.fName = fName;
\end_layout

\begin_layout LyX-Code
    this.fDesc = fDesc;
\end_layout

\begin_layout LyX-Code
  }
\end_layout

\begin_layout LyX-Code
  @Override
\end_layout

\begin_layout LyX-Code
  public FieldVisitor visitField(int access, String name, String desc,
\end_layout

\begin_layout LyX-Code
      String signature, Object value) {
\end_layout

\begin_layout LyX-Code
    
\series bold
if (name.equals(fName)) {
\end_layout

\begin_layout LyX-Code
 
\series bold
     isFieldPresent = true;
\end_layout

\begin_layout LyX-Code
 
\series bold
   }
\end_layout

\begin_layout LyX-Code
    return cv.visitField(access, name, desc, signature, value);
\end_layout

\begin_layout LyX-Code
  }
\end_layout

\begin_layout LyX-Code
  @Override 
\end_layout

\begin_layout LyX-Code
  public void visitEnd() {
\end_layout

\begin_layout LyX-Code
    
\series bold
if (!isFieldPresent) {
\end_layout

\begin_layout LyX-Code
 
\series bold
     FieldVisitor fv = cv.visitField(fAcc, fName, fDesc, null, null);
\end_layout

\begin_layout LyX-Code
 
\series bold
     if (fv != null) {
\end_layout

\begin_layout LyX-Code
 
\series bold
       fv.visitEnd();
\end_layout

\begin_layout LyX-Code
 
\series bold
     }
\end_layout

\begin_layout LyX-Code
 
\series bold
   }
\end_layout

\begin_layout LyX-Code
    cv.visitEnd();
\end_layout

\begin_layout LyX-Code
  }
\end_layout

\begin_layout LyX-Code
}
\end_layout

\begin_layout Standard
The field is added in the 
\family typewriter
visitEnd
\family default
 method.
 The 
\family typewriter
visitField
\family default
 method is not overridden to modify existing fields or to remove a field,
 but just to detect if the field we want to add already exists or not.
 Note the 
\family typewriter
fv != null
\family default
 test in the 
\family typewriter
visitEnd
\family default
 method, before calling 
\family typewriter
fv.visitEnd()
\family default
: this is because, as we have seen in the previous section, a class visitor
 can return 
\family typewriter
null
\family default
 in 
\family typewriter
visitField
\family default
.
\end_layout

\begin_layout Subsection
Transformation chains
\begin_inset CommandInset label
LatexCommand label
name "sub:Transformation-chains"

\end_inset


\end_layout

\begin_layout Standard
So far we have seen simple transformation chains
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
transformation chain
\end_layout

\end_inset

 made of a 
\family typewriter
ClassReader
\family default
, a class adapter, and a 
\family typewriter
ClassWriter
\family default
.
 It is of course possible to use more complex chains, with 
\emph on
several
\emph default
 class adapters chained together.
 Chaining several adapters allows you to compose several independent class
 transformations in order to do complex transformations.
 Note also that a transformation chain is not necessarily linear.
 You can write a 
\family typewriter
ClassVisitor
\family default
 that forwards all the method calls it receives to several 
\family typewriter
ClassVisitor
\family default
 at the same time:
\end_layout

\begin_layout LyX-Code
public class MultiClassAdapter extends ClassVisitor {
\end_layout

\begin_layout LyX-Code
  protected 
\series bold
ClassVisitor[]
\series default
 cvs;
\end_layout

\begin_layout LyX-Code
  public MultiClassAdapter(
\series bold
ClassVisitor[]
\series default
 cvs) {
\end_layout

\begin_layout LyX-Code
    super(ASM4);
\end_layout

\begin_layout LyX-Code
    this.cvs = cvs;
\end_layout

\begin_layout LyX-Code
  }
\end_layout

\begin_layout LyX-Code
  @Override public void visit(int version, int access, String name,
\end_layout

\begin_layout LyX-Code
      String signature, String superName, String[] interfaces) {
\end_layout

\begin_layout LyX-Code
    
\series bold
for (ClassVisitor cv : cvs) {
\end_layout

\begin_layout LyX-Code
      cv.visit(version, access, name, signature, superName, interfaces);
\end_layout

\begin_layout LyX-Code
    
\series bold
}
\end_layout

\begin_layout LyX-Code
  }
\end_layout

\begin_layout LyX-Code
  ...
\end_layout

\begin_layout LyX-Code
}
\end_layout

\begin_layout Standard
Symmetrically several class adapters can delegate to the same 
\family typewriter
ClassVisitor
\family default
 (this requires some precautions to ensure, for example, that the 
\family typewriter
visit
\family default
 and 
\family typewriter
visitEnd
\family default
 methods are called exactly once on this 
\family typewriter
ClassVisitor
\family default
).
 Thus a transformation chain such as the one shown in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:A-complex-transformation-chain"

\end_inset

 is perfectly possible.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename figures/complexchain.eps
	scale 80

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:A-complex-transformation-chain"

\end_inset

A complex transformation chain
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
Tools
\begin_inset CommandInset label
LatexCommand label
name "sub:ClassTools"

\end_inset


\end_layout

\begin_layout Standard
In addition to the 
\family typewriter
ClassVisitor
\family default
 class and to the related 
\family typewriter
ClassReader
\family default
 and 
\family typewriter
ClassWriter
\family default
 components, ASM provides, in the 
\family typewriter
org.objectweb.asm.util
\family default
 package, several tools that can be useful during the development of a class
 generator or adapter, but which are not needed at runtime.
 ASM also provides a utility class for manipulating internal names, type
 descriptors and method descriptors at runtime.
 All these tools are presented below.
\end_layout

\begin_layout Subsection

\family typewriter
Type
\family default

\begin_inset CommandInset label
LatexCommand label
name "sub:Type"

\end_inset


\end_layout

\begin_layout Standard
As you have seen in the previous sections, the ASM API exposes Java types
 as they are stored in compiled classes, i.e.
 as internal names or type descriptors.
 It would be possible to expose them as they appear in source code, to make
 code more readable.
 But this would require systematic conversions between the two representations
 in 
\family typewriter
ClassReader
\family default
 and 
\family typewriter
ClassWriter
\family default
, which would degrade performances.
 This is why ASM does not transparently transform internal names and type
 descriptors to their equivalent source code form.
 However it provides the 
\family typewriter
Type
\family default
 class for doing that manually when necessary.
\end_layout

\begin_layout Standard
A 
\family typewriter
Type
\family default

\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
Type@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
texttt{Type}
\end_layout

\end_inset


\end_layout

\end_inset

 object represents a Java type, and can be constructed either from a type
 descriptor or from a 
\family typewriter
Class
\family default
 object.
 The 
\family typewriter
Type
\family default
 class also contains static variables representing the primitive types.
 For example 
\family typewriter
Type.INT_TYPE
\family default
 is the 
\family typewriter
Type
\family default
 object representing the 
\family typewriter
int
\family default
 type.
\end_layout

\begin_layout Standard
The 
\family typewriter
getInternalName
\family default

\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
internal name
\end_layout

\end_inset

 method returns the internal name of a 
\family typewriter
Type
\family default
.
 For example 
\family typewriter
Type.getType(String.class).getInternalName()
\family default
 gives the internal name of the 
\family typewriter
String
\family default
 class, i.e.
 
\family typewriter
"java/lang/String"
\family default
.
 This method must be used only for class or interface types.
 
\end_layout

\begin_layout Standard
The 
\family typewriter
getDescriptor
\family default

\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
type descriptor
\end_layout

\end_inset

 method returns the descriptor of a 
\family typewriter
Type
\family default
.
 So, for example, instead of using 
\family typewriter
"Ljava/lang/String;"
\family default
 in your code you could use 
\family typewriter
Type.getType(String.class).getDescriptor()
\family default
.
 Or, instead of using 
\family typewriter
I
\family default
, you could use 
\family typewriter
Type.INT_TYPE.getDescriptor()
\family default
.
\end_layout

\begin_layout Standard
A 
\family typewriter
Type
\family default
 object can also represent a method type.
 Such objects can be constructed either from a method descriptor or from
 a 
\family typewriter
Method
\family default
 object.
 The 
\family typewriter
getDescriptor
\family default
 method then returns the method descriptor corresponding to this type.
 In addition, the 
\family typewriter
getArgumentTypes
\family default
 and 
\family typewriter
getReturnType
\family default
 methods can be used to get the 
\family typewriter
Type
\family default
 objects corresponding to the argument types and return types of a method.
 For instance 
\family typewriter
Type.getArgumentTypes("(I)V")
\family default

\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
method descriptor
\end_layout

\end_inset

 returns an array containing the single element 
\family typewriter
Type.INT_TYPE
\family default
.
 Similarly, a call to 
\family typewriter
Type.getReturnType("(I)V")
\family default
 returns the 
\family typewriter
Type.VOID_TYPE
\family default
 object.
\end_layout

\begin_layout Subsection

\family typewriter
TraceClassVisitor
\end_layout

\begin_layout Standard
In order to check that a generated or transformed class is conforming to
 what you expect, the byte array returned by a 
\family typewriter
ClassWriter
\family default
 is not really helpful because it is unreadable by humans.
 A textual representation would be much easier to use.
 This is what the 
\family typewriter
TraceClassVisitor
\family default

\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
TraceClassVisitor@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
texttt{TraceClassVisitor}
\end_layout

\end_inset


\end_layout

\end_inset

 class provides.
 This class, as its name implies, extends the 
\family typewriter
ClassVisitor
\family default
 class, and builds a textual representation
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
classes!textual representation
\end_layout

\end_inset

 of the visited class.
 So, instead of using a 
\family typewriter
ClassWriter
\family default
 to generate your classes, you can use a 
\family typewriter
TraceClassVisitor
\family default
, in order to get a readable trace of what is actually generated.
 Or, even better, you can use both at the same time.
 Indeed the 
\family typewriter
TraceClassVisitor
\family default
 can, in addition to its default behavior, delegate all calls to its methods
 to another visitor, for instance a 
\family typewriter
ClassWriter
\family default
:
\end_layout

\begin_layout LyX-Code
ClassWriter cw = new ClassWriter(0);
\end_layout

\begin_layout LyX-Code
TraceClassVisitor cv = new TraceClassVisitor(cw, printWriter);
\end_layout

\begin_layout LyX-Code
cv.visit(...);
\end_layout

\begin_layout LyX-Code
...
\end_layout

\begin_layout LyX-Code
cv.visitEnd();
\end_layout

\begin_layout LyX-Code
byte b[] = cw.toByteArray();
\end_layout

\begin_layout Standard
This code creates a 
\family typewriter
TraceClassVisitor
\family default
 that delegates all the calls it receives to 
\family typewriter
cw
\family default
, and that prints
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
classes!printing
\end_layout

\end_inset

 a textual representation of these calls to 
\family typewriter
printWriter
\family default
.
 For example, using a 
\family typewriter
TraceClassVisitor
\family default
 in the example of section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Generating-classes-CoreAPI"

\end_inset

 would give:
\end_layout

\begin_layout LyX-Code
// class version 49.0 (49)
\end_layout

\begin_layout LyX-Code
// access flags 1537
\end_layout

\begin_layout LyX-Code
public abstract interface pkg/Comparable implements pkg/Mesurable  {
\end_layout

\begin_layout LyX-Code
  // access flags 25
\end_layout

\begin_layout LyX-Code
  public final static I LESS = -1
\end_layout

\begin_layout LyX-Code
  // access flags 25
\end_layout

\begin_layout LyX-Code
  public final static I EQUAL = 0
\end_layout

\begin_layout LyX-Code
  // access flags 25
\end_layout

\begin_layout LyX-Code
  public final static I GREATER = 1
\end_layout

\begin_layout LyX-Code
  // access flags 1025
\end_layout

\begin_layout LyX-Code
  public abstract compareTo(Ljava/lang/Object;)I
\end_layout

\begin_layout LyX-Code
}
\end_layout

\begin_layout Standard
Note that you can use a 
\family typewriter
TraceClassVisitor
\family default
 at any point in a generation or transformation chain, and not only just
 before a 
\family typewriter
ClassWriter
\family default
, in order to see what happens at this point in the chain.
 Note also that the textual representation of classes generated by this
 adapter can be used to compare classes easily, with 
\family typewriter
String.equals()
\family default
.
\end_layout

\begin_layout Subsection

\family typewriter
CheckClassAdapter
\end_layout

\begin_layout Standard
The 
\family typewriter
ClassWriter
\family default
 class does not check that its methods are called in the appropriate order
 and with valid arguments.
 It is therefore possible to generate invalid classes that will be rejected
 by the Java Virtual Machine verifier.
 In order to detect some of these errors as soon as possible, it is possible
 to use the 
\family typewriter
CheckClassAdapter
\family default

\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
CheckClassAdapter@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
texttt{CheckClassAdapter}
\end_layout

\end_inset


\end_layout

\end_inset

 class.
 Like 
\family typewriter
TraceClassVisitor
\family default
, this class extends the 
\family typewriter
ClassVisitor
\family default
 class, and delegates all calls to its method to another 
\family typewriter
ClassVisitor
\family default
, for instance a 
\family typewriter
TraceClassVisitor
\family default
 or a 
\family typewriter
ClassWriter
\family default
.
 However, instead of printing a textual representation of the visited class,
 this class checks
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
classes!checking
\end_layout

\end_inset

 that its methods are called in the appropriate order, and with valid arguments,
 before delegating to the next visitor.
 In case of errors an 
\family typewriter
IllegalStateException
\family default
 or 
\family typewriter
IllegalArgumentException
\family default
 is thrown.
\end_layout

\begin_layout Standard
In order to check a class, print a textual representation of this class,
 and finally create a byte array representation, you should use something
 like:
\end_layout

\begin_layout LyX-Code
ClassWriter cw = new ClassWriter(0);
\end_layout

\begin_layout LyX-Code
TraceClassVisitor tcv = new TraceClassVisitor(cw, printWriter);
\end_layout

\begin_layout LyX-Code

\series bold
CheckClassAdapter cv = new CheckClassAdapter(tcv);
\end_layout

\begin_layout LyX-Code
cv.visit(...);
\end_layout

\begin_layout LyX-Code
...
\end_layout

\begin_layout LyX-Code
cv.visitEnd();
\end_layout

\begin_layout LyX-Code
byte b[] = cw.toByteArray();
\end_layout

\begin_layout Standard
Note that if you chain these class visitors in a different order, the operations
 they perform will be done in a different order too.
 For example, with the following code, the checks will take place 
\emph on
after
\emph default
 the trace:
\end_layout

\begin_layout LyX-Code
ClassWriter cw = new ClassWriter(0);
\end_layout

\begin_layout LyX-Code

\series bold
CheckClassAdapter cca = new CheckClassAdapter(cw);
\end_layout

\begin_layout LyX-Code
TraceClassVisitor cv = new TraceClassVisitor(cca, printWriter);
\end_layout

\begin_layout Standard
Like with 
\family typewriter
TraceClassVisitor
\family default
, you can use a 
\family typewriter
CheckClassAdapter
\family default
 at any point in a generation or transformation chain, and not only just
 before a 
\family typewriter
ClassWriter
\family default
, in order to check classes at this point in the chain.
 
\end_layout

\begin_layout Subsection

\family typewriter
ASMifier
\end_layout

\begin_layout Standard
This class provides an alternative backend for the 
\family typewriter
TraceClassVisitor
\family default
 tool (which by default uses a 
\family typewriter
Textifier
\family default
 backend, producing the kind of output shown above).
 This backend makes each method of the 
\family typewriter
TraceClassVisitor
\family default
 class print the Java code that was used to call it.
 For instance calling the
\family typewriter
 visitEnd()
\family default
 method prints 
\family typewriter
cv.visitEnd();
\family default
.
 The result is that, when a 
\family typewriter
TraceClassVisitor
\family default
 visitor with an 
\family typewriter
ASMifier
\family default
 backend visits a class, it prints the source code to generate this class
 with ASM.
 This is useful if you use this visitor to visit an already existing class.
 For instance, if you don't know how to generate some compiled class with
 ASM, write the corresponding source code, compile it with 
\family typewriter
javac
\family default
, and visit the compiled class with the 
\family typewriter
ASMifier
\family default

\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
ASMifier@
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{ASMifier}
\end_layout

\end_inset


\end_layout

\end_inset

.
 You will get the ASM code to generate this compiled class!
\end_layout

\begin_layout Standard
The 
\family typewriter
ASMifier
\family default
 class can be used from the command line.
 For example using:
\end_layout

\begin_layout LyX-Code
java -classpath asm.jar:asm-util.jar 
\backslash

\end_layout

\begin_layout LyX-Code
     org.objectweb.asm.util.ASMifier 
\backslash

\end_layout

\begin_layout LyX-Code
     java.lang.Runnable
\end_layout

\begin_layout Standard
produces code that, after indentation, reads:
\end_layout

\begin_layout LyX-Code
package asm.java.lang;
\end_layout

\begin_layout LyX-Code
import org.objectweb.asm.*;
\end_layout

\begin_layout LyX-Code
public class RunnableDump implements Opcodes {
\end_layout

\begin_layout LyX-Code
  public static byte[] dump() throws Exception {
\end_layout

\begin_layout LyX-Code
    ClassWriter cw = new ClassWriter(0);
\end_layout

\begin_layout LyX-Code
    FieldVisitor fv;
\end_layout

\begin_layout LyX-Code
    MethodVisitor mv;
\end_layout

\begin_layout LyX-Code
    AnnotationVisitor av0;
\end_layout

\begin_layout LyX-Code
    cw.visit(V1_5, ACC_PUBLIC + ACC_ABSTRACT + ACC_INTERFACE,
\end_layout

\begin_layout LyX-Code
        "java/lang/Runnable", null, "java/lang/Object", null);
\end_layout

\begin_layout LyX-Code
    {
\end_layout

\begin_layout LyX-Code
      mv = cw.visitMethod(ACC_PUBLIC + ACC_ABSTRACT, "run", "()V",
\end_layout

\begin_layout LyX-Code
          null, null);
\end_layout

\begin_layout LyX-Code
      mv.visitEnd();
\end_layout

\begin_layout LyX-Code
    }
\end_layout

\begin_layout LyX-Code
    cw.visitEnd();
\end_layout

\begin_layout LyX-Code
    return cw.toByteArray();
\end_layout

\begin_layout LyX-Code
  }
\end_layout

\begin_layout LyX-Code
}
\end_layout

\begin_layout Chapter
Methods
\end_layout

\begin_layout Standard
This chapter explains how to generate and transform compiled methods with
 the core ASM API.
 It starts with a presentation of compiled methods and then presents the
 corresponding ASM interfaces, components and tools to generate and transform
 them, with many illustrative examples.
\end_layout

\begin_layout Section
Structure
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
methods!structure
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Inside compiled classes the code of methods is stored as a sequence of 
\emph on
bytecode
\emph default
 instructions
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
bytecode instruction
\end_layout

\end_inset

.
 In order to generate and transform classes it is fundamental to know these
 instructions and to understand how they work.
 This section gives an overview of these instructions which should be sufficient
 to start coding simple class generators and transformers.
 For a complete definition you should read the Java Virtual Machine Specificatio
n.
\end_layout

\begin_layout Subsection
Execution model
\end_layout

\begin_layout Standard
Before presenting the bytecode instructions it is necessary to present the
 Java Virtual Machine execution model.
 As you know Java code is executed inside 
\emph on
threads
\emph default
.
 Each thread has its own execution stack
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
execution stack
\end_layout

\end_inset

, which is made of 
\emph on
frames
\emph default

\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
execution frame
\end_layout

\end_inset

.
 Each frame represents a method invocation: each time a method is invoked,
 a new frame is pushed on the current thread's execution stack.
 When the method returns, either normally or because of an exception, this
 frame is popped from the execution stack and execution continues in the
 calling method (whose frame is now on top of the stack).
\end_layout

\begin_layout Standard
Each frame contains two parts: a local variables part and an operand stack
 part.
 The 
\emph on
local variables
\emph default

\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
local variables
\end_layout

\end_inset

 part contains variables that can be accessed by their index, in random
 order.
 The 
\emph on
operand stack
\emph default

\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
operand stack
\end_layout

\end_inset

 part, as its name implies, is a stack of values that are used as operands
 by bytecode instructions.
 This means that the values in this stack can only be accessed in Last In
 First Out order.
 Do not confuse the operand stack and the thread's execution stack: each
 frame in the execution stack contains its 
\emph on
own
\emph default
 operand stack.
\end_layout

\begin_layout Standard
The size of the local variables
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
local variables!size
\end_layout

\end_inset

 and operand stack
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
operand stack!size
\end_layout

\end_inset

 parts depends on the method's code.
 It is computed at compile time and is stored along with the bytecode instructio
ns in compiled classes.
 As a consequence, all the frames that correspond to the invocation of a
 given method have the same size, but frames that correspond to different
 methods can have different sizes for their local variables and operand
 stack parts.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
vspace{0.5cm}
\end_layout

\end_inset


\begin_inset Graphics
	filename figures/frames.eps
	scale 80

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
vspace{0.5cm}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:An-execution-stack"

\end_inset

An execution stack
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
execution stack
\end_layout

\end_inset

 with 3 frames
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:An-execution-stack"

\end_inset

 shows a sample execution stack with 3 frames.
 The first frame contains 3 local variables, its operand stack has a maximum
 size of 4, and it contains two values.
 The second frame contains 2 local variables, and two values in its operand
 stack.
 Finally the third frame, on top of the execution stack, contains 4 local
 variables and two operands.
\end_layout

\begin_layout Standard
When it is created, a frame is initialized with an empty stack, and its
 local variables are initialized with the target object 
\family typewriter
this
\family default
 (for non static methods) and with the method's arguments.
 For instance, calling the method 
\family typewriter
a.equals(b)
\family default
 creates a frame with an empty stack and with the first two local variables
 initialized to 
\family typewriter
a
\family default
 and 
\family typewriter
b
\family default
 (other local variables are uninitialized).
\end_layout

\begin_layout Standard
Each slot in the local variables and operand stack parts can hold any Java
 value, except 
\family typewriter
long
\family default
 and 
\family typewriter
double
\family default
 values.
 These values require two slots.
 This complicates the management of local variables: for instance the 
\begin_inset Formula $i^{th}$
\end_inset

 method argument is not necessarily stored in local variable 
\begin_inset Formula $i$
\end_inset

.
 For example, calling 
\family typewriter
Math.max(1L, 2L)
\family default
 creates a frame with the 
\family typewriter
1L
\family default
 value in the first two local variable slots, and with the value 
\family typewriter
2L
\family default
 in the third and fourth slots.
\end_layout

\begin_layout Subsection
Bytecode instructions
\begin_inset CommandInset label
LatexCommand label
name "sub:Bytecode-instructions"

\end_inset


\end_layout

\begin_layout Standard
A bytecode instruction
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
bytecode instruction
\end_layout

\end_inset

 is made of an opcode that identifies this instruction, and of a fixed number
 of arguments:
\end_layout

\begin_layout Itemize
The 
\emph on
opcode
\emph default

\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
opcode
\end_layout

\end_inset


\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
bytecode instruction!opcode
\end_layout

\end_inset

 is an unsigned byte value -- hence the bytecode name -- and is identified
 by a mnemonic symbol.
 For example the opcode value 0 is designed by the mnemonic symbol 
\family typewriter
NOP
\family default
, and corresponds to the instruction that does nothing.
 
\end_layout

\begin_layout Itemize
The 
\emph on
arguments
\emph default

\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
bytecode instruction!arguments
\end_layout

\end_inset

 are static values that define the precise instruction behavior.
 They are given just after the opcode.
 For instance the 
\family typewriter
GOTO
\family default
 
\emph on
label
\emph default
 instruction, whose opcode value is 167, takes as argument 
\emph on
label
\emph default
, a label that designates the next instruction to be executed.
 Instruction arguments must not be confused with instruction operands
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
operand
\end_layout

\end_inset


\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
bytecode instruction!operands
\end_layout

\end_inset

: argument values are statically known and are stored in the compiled code,
 while operand values come from the operand stack and are known only at
 runtime.
\end_layout

\begin_layout Standard
The bytecode instructions can be divided in two categories: a small set
 of instructions is designed to transfer values from the local variables
 to the operand stack, and vice versa; the other instructions only act on
 the operand stack: they pop some values from the stack, compute a result
 based on these values, and push it back on the stack.
\end_layout

\begin_layout Standard
The 
\family typewriter
ILOAD
\family default
, 
\family typewriter
LLOAD
\family default
, 
\family typewriter
FLOAD
\family default
, 
\family typewriter
DLOAD
\family default
, and 
\family typewriter
ALOAD
\family default
 instructions read a local variable and push its value on the operand stack.
 They take as argument the index 
\begin_inset Formula $i$
\end_inset

 of the local variable that must be read.
 
\family typewriter
ILOAD
\family default
 is used to load a 
\family typewriter
boolean
\family default
, 
\family typewriter
byte
\family default
, 
\family typewriter
char
\family default
, 
\family typewriter
short
\family default
, or 
\family typewriter
int
\family default
 local variable.
 
\family typewriter
LLOAD
\family default
, 
\family typewriter
FLOAD
\family default
 and 
\family typewriter
DLOAD
\family default
 are used to load a 
\family typewriter
long
\family default
, 
\family typewriter
float
\family default
 or 
\family typewriter
double
\family default
 value, respectively (
\family typewriter
LLOAD
\family default
 and 
\family typewriter
DLOAD
\family default
 actually load the two slots 
\begin_inset Formula $i$
\end_inset

 and 
\begin_inset Formula $i+1$
\end_inset

).
 Finally 
\family typewriter
ALOAD
\family default
 is used to load any non primitive value, i.e.
 object and array references.
 Symmetrically the 
\family typewriter
ISTORE
\family default
, 
\family typewriter
LSTORE
\family default
, 
\family typewriter
FSTORE
\family default
, 
\family typewriter
DSTORE
\family default
 and 
\family typewriter
ASTORE
\family default
 instructions pop a value from the operand stack and store it in a local
 variable designated by its index 
\family typewriter
i
\family default
.
\end_layout

\begin_layout Standard
As you can see the 
\emph on
x
\family typewriter
\emph default
LOAD
\family default
 and 
\emph on
x
\family typewriter
\emph default
STORE
\family default
 instructions are typed (in fact, as you will see below, almost all instructions
 are typed).
 This is used to ensure that no illegal conversion is done.
 Indeed it is illegal to store a value in a local variable and then to load
 it with a different type.
 For instance the 
\family typewriter
ISTORE 1 ALOAD 1
\family default
 sequence is illegal -- it would allow to store an arbitrary memory address
 in local variable 1, and to convert this address to an object reference!
 It is however perfectly legal to store in a local variable a value whose
 type differ from the type of the current value stored in this local variable.
 This means that the type of a local variable, i.e.
 the type of the value stored in this local variable, can change during
 the execution of a method.
\end_layout

\begin_layout Standard
As said above, all other bytecode instructions work on the operand stack
 only.
 They can be grouped in the following categories (see appendix 
\begin_inset CommandInset ref
LatexCommand ref
reference "app:Bytecode-instructions"

\end_inset

):
\end_layout

\begin_layout Description
Stack These instructions are used to manipulate values on the stack: 
\family typewriter
POP
\family default
 pops the value on top of the stack, 
\family typewriter
DUP
\family default
 pushes a copy of the top stack value, 
\family typewriter
SWAP
\family default
 pops two values and pushes them in the reverse order, etc.
\end_layout

\begin_layout Description
Constants These instructions push a constant value on the operand stack:
 
\family typewriter
ACONST_NULL
\family default
 pushes 
\family typewriter
null
\family default
, 
\family typewriter
ICONST_0
\family default
 pushes the int value 
\family typewriter
0
\family default
, 
\family typewriter
FCONST_0
\family default
 pushes 
\family typewriter
0f
\family default
, 
\family typewriter
DCONST_0
\family default
 pushes 
\family typewriter
0d
\family default
, 
\family typewriter
BIPUSH
\family default
 
\emph on
b
\emph default
 pushes the byte value 
\emph on
b
\emph default
, 
\family typewriter
SIPUSH
\family default
 
\emph on
s
\emph default
 pushes the short value 
\emph on
s
\emph default
, 
\family typewriter
LDC
\family default
 
\emph on
cst
\emph default
 pushes the arbitrary 
\family typewriter
int
\family default
, 
\family typewriter
float
\family default
, 
\family typewriter
long
\family default
, 
\family typewriter
double
\family default
, 
\family typewriter
String
\family default
, or 
\family typewriter
class
\family default

\begin_inset Foot
status collapsed

\begin_layout Plain Layout
this corresponds to the 
\emph on
identifier
\family typewriter
\emph default
.class
\family default
 Java syntax.
\end_layout

\end_inset

 constant 
\emph on
cst
\emph default
, etc.
\end_layout

\begin_layout Description
Arithmetic
\begin_inset space ~
\end_inset

and
\begin_inset space ~
\end_inset

logic These instructions pop numeric values from the operand stack combine
 them and push the result on the stack.
 They do not have any argument.
 
\emph on
x
\family typewriter
\emph default
ADD
\family default
, 
\emph on
x
\family typewriter
\emph default
SUB
\family default
, 
\emph on
x
\family typewriter
\emph default
MUL
\family default
, 
\emph on
x
\family typewriter
\emph default
DIV
\family default
 and 
\emph on
x
\family typewriter
\emph default
REM
\family default
 correspond to the 
\family typewriter
+
\family default
, 
\family typewriter
-
\family default
, 
\family typewriter
*
\family default
, 
\family typewriter
/
\family default
 and 
\family typewriter
%
\family default
 operations, where 
\emph on
x
\emph default
 is either 
\family typewriter
I
\family default
, 
\family typewriter
L
\family default
, 
\family typewriter
F
\family default
 or 
\family typewriter
D
\family default
.
 Similarly there are other instructions corresponding to 
\family typewriter
<<
\family default
, 
\family typewriter
>>
\family default
, 
\family typewriter
>>>
\family default
, 
\family typewriter
\noun on
|
\family default
\noun default
, 
\family typewriter
&
\family default
 and 
\family typewriter
^
\family default
, for 
\family typewriter
int
\family default
 and 
\family typewriter
long
\family default
 values.
\end_layout

\begin_layout Description
Casts These instructions pop a value from the stack, convert it to another
 type, and push the result back.
 They correspond to cast expressions in Java.
 
\family typewriter
I2F
\family default
, 
\family typewriter
F2D
\family default
, 
\family typewriter
L2D
\family default
, etc.
 convert numeric values from one numeric type to another.
 
\family typewriter
CHECKCAST
\family default
 
\emph on
t
\emph default
 converts a reference value to the type 
\emph on
t
\emph default
.
\end_layout

\begin_layout Description
Objects These instructions are used to create objects, lock them, test their
 type, etc.
 For instance the 
\family typewriter
NEW
\family default
 
\emph on
type
\emph default
 instruction pushes a new object of type 
\emph on
type
\emph default
 on the stack (where 
\emph on
type
\emph default
 is an internal name).
\end_layout

\begin_layout Description
Fields These instructions read or write the value of a field.
 
\family typewriter
GETFIELD
\family default
 
\emph on
owner
\emph default
 
\emph on
name
\emph default
 
\emph on
desc
\emph default
 pops an object reference, and pushes the value of its 
\emph on
name
\emph default
 field.
 
\family typewriter
PUTFIELD
\family default
 
\emph on
owner
\emph default
 
\emph on
name
\emph default
 
\emph on
desc
\emph default
 pops a value and an object reference, and stores this value in its 
\emph on
name
\emph default
 field.
 In both cases the object must be of type 
\emph on
owner
\emph default
, and its field must be of type 
\emph on
desc
\emph default
.
 
\family typewriter
GETSTATIC
\family default
 and 
\family typewriter
PUTSTATIC
\family default
 are similar instructions, but for static fields.
\end_layout

\begin_layout Description
Methods These instructions invoke a method or a constructor.
 They pop as many values as there are method arguments, plus one value for
 the target object, and push the result of the method invocation.
 
\family typewriter
INVOKEVIRTUAL
\family default
 
\emph on
owner
\emph default
 
\emph on
name
\emph default
 
\emph on
desc
\emph default
 invokes the 
\emph on
name
\emph default
 method defined in class 
\emph on
owner
\emph default
, and whose method descriptor is 
\emph on
desc
\emph default
.
 
\family typewriter
INVOKESTATIC
\family default
 is used for static methods, 
\family typewriter
INVOKESPECIAL
\family default
 for private methods and constructors, and 
\family typewriter
INVOKEINTERFACE
\family default
 for methods defined in interfaces.
 Finally, for Java 7 classes,
\family typewriter
 INVOKEDYNAMIC
\family default
 is used for the new dynamic method invocation mechanism.
\end_layout

\begin_layout Description
Arrays These instructions are used to read and write values in arrays.
 The 
\emph on
x
\family typewriter
\emph default
ALOAD
\family default
 instructions pop an index and an array, and push the value of the array
 element at this index.
 The 
\emph on
x
\family typewriter
\emph default
ASTORE
\family default
 instructions pop a value, an index and an array, and store this value at
 that index in the array.
 Here 
\emph on
x
\emph default
 can be 
\family typewriter
I
\family default
, 
\family typewriter
L
\family default
, 
\family typewriter
F
\family default
, 
\family typewriter
D
\family default
 or 
\family typewriter
A
\family default
, but also 
\family typewriter
B
\family default
, 
\family typewriter
C
\family default
 or 
\family typewriter
S
\family default
.
\end_layout

\begin_layout Description
Jumps These instructions jump to an arbitrary instruction if some condition
 is true, or unconditionally.
 They are used to compile 
\family typewriter
if
\family default
, 
\family typewriter
for
\family default
, 
\family typewriter
do
\family default
, 
\family typewriter
while
\family default
, 
\family typewriter
break
\family default
 and 
\family typewriter
continue
\family default
 instructions.
 For instance 
\family typewriter
IFEQ
\family default
 
\emph on
label
\emph default
 pops an 
\family typewriter
int
\family default
 value from the stack, and jumps to the instruction designed by 
\emph on
label
\emph default

\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
label
\end_layout

\end_inset

 if this value is 0 (otherwise execution continues normally to the next
 instruction).
 Many other jump instructions exist, such as 
\family typewriter
IFNE
\family default
 or 
\family typewriter
IFGE
\family default
.
 Finally 
\family typewriter
TABLESWITCH
\family default
 and 
\family typewriter
LOOKUPSWITCH
\family default
 correspond to the 
\family typewriter
switch
\family default
 Java instruction.
\end_layout

\begin_layout Description
Return Finally the 
\emph on
x
\family typewriter
\emph default
RETURN
\family default
 and 
\family typewriter
RETURN
\family default
 instructions are used to terminate the execution of a method and to return
 its result to the caller.
 
\family typewriter
RETURN
\family default
 is used for methods that return 
\family typewriter
void
\family default
, and 
\emph on
x
\family typewriter
\emph default
RETURN
\family default
 for the other methods.
\end_layout

\begin_layout Subsection
Examples
\begin_inset CommandInset label
LatexCommand label
name "sub:Bytecode-sequence-examples"

\end_inset


\end_layout

\begin_layout Standard
Lets look at some basic examples to get a more concrete sense of how bytecode
 instructions work.
 Consider the following bean class:
\end_layout

\begin_layout LyX-Code
package pkg;
\end_layout

\begin_layout LyX-Code
public class Bean {
\end_layout

\begin_layout LyX-Code
  private int f;
\end_layout

\begin_layout LyX-Code
  public int getF() {
\end_layout

\begin_layout LyX-Code
    return this.f;
\end_layout

\begin_layout LyX-Code
  }
\end_layout

\begin_layout LyX-Code
  public void setF(int f) {
\end_layout

\begin_layout LyX-Code
    this.f = f;
\end_layout

\begin_layout LyX-Code
  }
\end_layout

\begin_layout LyX-Code
}
\end_layout

\begin_layout Standard
The bytecode of the getter method is:
\end_layout

\begin_layout LyX-Code
ALOAD 0
\end_layout

\begin_layout LyX-Code
GETFIELD pkg/Bean f I
\end_layout

\begin_layout LyX-Code
IRETURN
\end_layout

\begin_layout Standard
The first instruction reads the local variable 0, which was initialized
 to 
\family typewriter
this
\family default
 during the creation of the frame for this method call, and pushes this
 value on the operand stack.
 The second instruction pops this value from the stack, i.e.
 
\family typewriter
this
\family default
, and pushes the 
\family typewriter
f
\family default
 field of this object, i.e.
 
\family typewriter
this.f
\family default
.
 The last instruction pops this value from the stack, and returns it to
 the caller.
 The successive states of the execution frame for this method are shown
 in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Successive-frame-states-getF"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
vspace{0.6cm}
\end_layout

\end_inset


\begin_inset Graphics
	filename figures/getter-frames.eps
	scale 80

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
vspace{0.6cm}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Successive-frame-states-getF"

\end_inset

Successive frame states for the 
\family typewriter
getF
\family default
 method: a) initial state, b) after 
\family typewriter
ALOAD 0
\family default
 and c) after 
\family typewriter
GETFIELD
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
The bytecode of the setter method is:
\end_layout

\begin_layout LyX-Code
ALOAD 0
\end_layout

\begin_layout LyX-Code
ILOAD 1
\end_layout

\begin_layout LyX-Code
PUTFIELD pkg/Bean f I
\end_layout

\begin_layout LyX-Code
RETURN
\end_layout

\begin_layout Standard
The first instruction pushes 
\family typewriter
this
\family default
 on the operand stack, as before.
 The second instruction pushes the local variable 1, which was initialized
 with the 
\family typewriter
f
\family default
 argument value during the creation of the frame for this method call.
 The third instruction pops these two values and stores the 
\family typewriter
int
\family default
 value in the 
\family typewriter
f
\family default
 field of the referenced object, i.e.
 in 
\family typewriter
this.f
\family default
.
 The last instruction, which is implicit in the source code but which is
 mandatory in the compiled code, destroys the current execution frame and
 returns to the caller.
 The successive states of the execution frame for this method are shown
 in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Successive-frame-states-setF"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
vspace{0.6cm}
\end_layout

\end_inset


\begin_inset Graphics
	filename figures/setter-frames.eps
	scale 80

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
vspace{0.6cm}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Successive-frame-states-setF"

\end_inset

Successive frame states for the 
\family typewriter
setF
\family default
 method: a) initial state, b) after 
\family typewriter
ALOAD 0
\family default
, c) after 
\family typewriter
ILOAD 1
\family default
 and d) after 
\family typewriter
PUTFIELD
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
The 
\family typewriter
Bean
\family default
 class also has a default public constructor which is generated by the compiler,
 since no explicit constructor
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
constructors
\end_layout

\end_inset

 was defined by the programmer.
 This default public constructor is generated as 
\family typewriter
Bean() { super(); }
\family default
.
 The bytecode of this constructor is the following:
\end_layout

\begin_layout LyX-Code
ALOAD 0
\end_layout

\begin_layout LyX-Code
INVOKESPECIAL java/lang/Object <init> ()V
\end_layout

\begin_layout LyX-Code
RETURN
\end_layout

\begin_layout Standard
The first instruction pushes 
\family typewriter
this
\family default
 on the operand stack.
 The second instruction pops this value from the stack, and calls the 
\family typewriter
<init>
\family default
 method defined in the 
\family typewriter
Object
\family default
 class.
 This corresponds to the 
\family typewriter
super()
\family default
 call, i.e.
 a call to the constructor of the super class, 
\family typewriter
Object
\family default
.
 You can see here that constructors are named differently in compiled and
 source classes: in compiled classes they are always named 
\family typewriter
<init>
\family default
, while in source classes they have the name of the class in which they
 are defined.
 Finally the last instruction returns to the caller.
\end_layout

\begin_layout Standard
Now let us consider a slightly more complex setter method:
\end_layout

\begin_layout LyX-Code
public void checkAndSetF(int f) {
\end_layout

\begin_layout LyX-Code
  if (f >= 0) {
\end_layout

\begin_layout LyX-Code
    this.f = f;
\end_layout

\begin_layout LyX-Code
  } else {
\end_layout

\begin_layout LyX-Code
    throw new IllegalArgumentException();
\end_layout

\begin_layout LyX-Code
  }
\end_layout

\begin_layout LyX-Code
}
\end_layout

\begin_layout Standard
The bytecode for this new setter method is the following:
\end_layout

\begin_layout LyX-Code
  ILOAD 1
\end_layout

\begin_layout LyX-Code
  IFLT 
\shape slanted
label
\end_layout

\begin_layout LyX-Code
  ALOAD 0
\end_layout

\begin_layout LyX-Code
  ILOAD 1
\end_layout

\begin_layout LyX-Code
  PUTFIELD pkg/Bean f I
\end_layout

\begin_layout LyX-Code
  GOTO 
\shape slanted
end
\end_layout

\begin_layout LyX-Code

\shape slanted
label:
\end_layout

\begin_layout LyX-Code
  NEW java/lang/IllegalArgumentException
\end_layout

\begin_layout LyX-Code
  DUP
\end_layout

\begin_layout LyX-Code
  INVOKESPECIAL java/lang/IllegalArgumentException <init> ()V
\end_layout

\begin_layout LyX-Code
  ATHROW
\end_layout

\begin_layout LyX-Code

\shape slanted
end:
\end_layout

\begin_layout LyX-Code
  RETURN
\end_layout

\begin_layout Standard
The first instruction pushes the local variable 1, initialized to 
\family typewriter
f
\family default
, on the operand stack.
 The 
\family typewriter
IFLT
\family default
 instruction pops this value from the stack, and compares it to 0.
 If it is Less Than (
\family typewriter
LT
\family default
) 0, it jumps to the instruction designated by the 
\family typewriter
\shape slanted
label
\family default
\shape default
 label, otherwise it does nothing and the execution continues to the next
 instruction.
 The next three instructions are the same instructions as in the 
\family typewriter
setF
\family default
 method.
 The 
\family typewriter
GOTO
\family default
 instruction unconditionally jumps to the instruction designated by the
 
\family typewriter
\shape slanted
end
\family default
\shape default
 label, which is the 
\family typewriter
RETURN
\family default
 instruction.
 The instructions between the 
\family typewriter
\shape slanted
label
\family default
\shape default
 and 
\family typewriter
\shape slanted
end
\family default
\shape default
 labels create and throw an exception: the 
\family typewriter
NEW
\family default
 instruction creates an exception object and pushes it on the operand stack.
 The 
\family typewriter
DUP
\family default
 instruction duplicates this value on the stack.
 The 
\family typewriter
INVOKESPECIAL
\family default
 instruction pops one of these two copies and calls the exception constructor
 on it.
 Finally the 
\family typewriter
ATHROW
\family default
 instruction pops the remaining copy and throws it as an exception (so the
 execution does not continue to the next instruction).
\end_layout

\begin_layout Subsection
Exception handlers
\begin_inset CommandInset label
LatexCommand label
name "sub:Exception-handlers"

\end_inset


\end_layout

\begin_layout Standard
There is no bytecode instruction to catch exceptions: instead the bytecode
 of a method is associated with a list of 
\emph on
exception handlers
\emph default

\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
exceptions!handlers
\end_layout

\end_inset

 that specify the code that must be executed when an exception is thrown
 in a given part of a method.
 An exception handler is similar to a 
\family typewriter
try
\family default
 
\family typewriter
catch
\family default
 block: it has a range, which is a sequence of instructions that corresponds
 to the content of the 
\family typewriter
try
\family default
 block, and a handler, which corresponds to the content of the 
\family typewriter
catch
\family default
 block.
 The range is specified by a start and end labels, and the handler with
 a start label.
 For example the source code below:
\end_layout

\begin_layout LyX-Code
public static void sleep(long d) {
\end_layout

\begin_layout LyX-Code
  try {
\end_layout

\begin_layout LyX-Code
    Thread.sleep(d);
\end_layout

\begin_layout LyX-Code
  } catch (InterruptedException e) {
\end_layout

\begin_layout LyX-Code
    e.printStackTrace();
\end_layout

\begin_layout LyX-Code
  }
\end_layout

\begin_layout LyX-Code
}
\end_layout

\begin_layout Standard
can be compiled into:
\end_layout

\begin_layout LyX-Code
TRYCATCHBLOCK 
\shape slanted
try
\shape default
 
\shape slanted
catch
\shape default
 
\shape slanted
catch
\shape default
 java/lang/InterruptedException
\end_layout

\begin_layout LyX-Code

\shape slanted
try:
\end_layout

\begin_layout LyX-Code
  LLOAD 0
\end_layout

\begin_layout LyX-Code
  INVOKESTATIC java/lang/Thread sleep (J)V
\end_layout

\begin_layout LyX-Code
  RETURN
\end_layout

\begin_layout LyX-Code

\shape slanted
catch:
\end_layout

\begin_layout LyX-Code
  INVOKEVIRTUAL java/lang/InterruptedException printStackTrace ()V
\end_layout

\begin_layout LyX-Code
  RETURN
\end_layout

\begin_layout Standard
The code between the 
\family typewriter
\emph on
try
\family default
\emph default
 and 
\family typewriter
\emph on
catch
\family default
\emph default
 labels corresponds to the 
\family typewriter
try
\family default
 block, while the code after the 
\family typewriter
\emph on
catch
\family default
\emph default
 label corresponds to the 
\family typewriter
catch
\family default
 block.
 The 
\family typewriter
TRYCATCHBLOCK
\family default
 line specifies an exception handler that covers the range between the 
\family typewriter
\emph on
try
\family default
\emph default
 and 
\family typewriter
\emph on
catch
\family default
\emph default
 labels, with a handler starting at the 
\family typewriter
\emph on
catch
\family default
\emph default
 label, and for exceptions whose class is a subclass of 
\family typewriter
InterruptedException
\family default
.
 This means that if such an exception is thrown anywhere between 
\family typewriter
\emph on
try
\family default
\emph default
 and 
\family typewriter
\emph on
catch
\family default
\emph default
 the stack is cleared, the exception is pushed on this empty stack, and
 execution continues at 
\family typewriter
\shape slanted
catch
\family default
\shape default
.
\end_layout

\begin_layout Subsection
Frames
\begin_inset CommandInset label
LatexCommand label
name "sub:Frames"

\end_inset


\end_layout

\begin_layout Standard
Classes compiled with Java 6 or higher contain, in addition to bytecode
 instructions, a set of 
\emph on
stack map frames
\emph default

\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
frames
\end_layout

\end_inset

 that are used to speed up the class verification process inside the Java
 Virtual Machine.
 A stack map frame gives the state of the execution frame of a method at
 some point during its execution.
 More precisely it gives the 
\emph on
type
\emph default
 of the values that are contained in each local variable slot and in each
 operand stack slot just before some specific bytecode instruction is executed.
\end_layout

\begin_layout Standard
For example, if we consider the 
\family typewriter
getF
\family default
 method of the previous section, we can define three stack map frames giving
 the state of the execution frame just before 
\family typewriter
ALOAD
\family default
, just before 
\family typewriter
GETFIELD
\family default
, and just before 
\family typewriter
IRETURN
\family default
.
 These three stack map frames correspond to the three cases shown in Figure
 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Successive-frame-states-getF"

\end_inset

 and can be described as follows, where the types between the first square
 brackets correspond to the local variables, and the others to the operand
 stack:
\end_layout

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="2">
<features tabularvalignment="middle">
<column alignment="left" valignment="top" width="0">
<column alignment="left" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
State of the execution frame 
\emph on
before
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Instruction
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
[
\family typewriter
pkg/Bean
\family default
] []
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
ALOAD 0
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
[
\family typewriter
pkg/Bean
\family default
] [
\family typewriter
pkg/Bean
\family default
]
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
GETFIELD
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
[
\family typewriter
pkg/Bean
\family default
] [
\family typewriter
I
\family default
]
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
IRETURN
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
We can do the same for the 
\family typewriter
checkAndSetF
\family default
 method:
\end_layout

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="14" columns="2">
<features tabularvalignment="middle">
<column alignment="left" valignment="top" width="0">
<column alignment="left" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
State of the execution frame 
\emph on
before
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Instruction
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
[
\family typewriter
pkg/Bean
\family default
 
\family typewriter
I
\family default
] []
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
ILOAD 1
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
[
\family typewriter
pkg/Bean
\family default
 
\family typewriter
I
\family default
] [
\family typewriter
I
\family default
]
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
IFLT
\family default
 
\family typewriter
\emph on
label
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
[
\family typewriter
pkg/Bean
\family default
 
\family typewriter
I
\family default
] []
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
ALOAD 0
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
[
\family typewriter
pkg/Bean
\family default
 
\family typewriter
I
\family default
] [
\family typewriter
pkg/Bean
\family default
]
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
ILOAD 1
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
[
\family typewriter
pkg/Bean
\family default
 
\family typewriter
I
\family default
] [
\family typewriter
pkg/Bean
\family default
 
\family typewriter
I
\family default
]
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
PUTFIELD
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
[
\family typewriter
pkg/Bean
\family default
 
\family typewriter
I
\family default
] []
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
GOTO
\family default
 
\family typewriter
\emph on
end
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
[
\family typewriter
pkg/Bean
\family default
 
\family typewriter
I
\family default
] []
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\emph on
label
\emph default
:
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
[
\family typewriter
pkg/Bean
\family default
\series default
 
\family typewriter
\series bold
I
\family default
] []
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
NEW
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
[
\family typewriter
pkg/Bean
\family default
 
\family typewriter
I
\family default
] [Uninitialized(label)]
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
DUP
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
[
\family typewriter
pkg/Bean
\family default
 
\family typewriter
I
\family default
] [Uninitialized(label) Uninitialized(label)]
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
INVOKESPECIAL
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
[
\family typewriter
pkg/Bean
\family default
 
\family typewriter
I
\family default
] [
\family typewriter
java/lang/IllegalArgumentException
\family default
]
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
ATHROW
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
[
\family typewriter
pkg/Bean
\family default
 
\family typewriter
I
\family default
] []
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\emph on
end
\emph default
:
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
[
\family typewriter
pkg/Bean
\family default
\series default
 
\family typewriter
\series bold
I
\family default
] []
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
RETURN
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
This is similar to the previous method, except for the Uninitialized(label)
 type.
 This is a special type that is used only in stack map frames, and that
 designates an object whose memory has been allocated but whose constructor
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
constructors
\end_layout

\end_inset

 has not been called yet.
 The argument designates the instruction that created this object.
 The only possible method that can be called on a value of this type is
 a constructor.
 When it is called, 
\emph on
all the occurrences
\emph default
 of this type in the frame are replaced with the real type, here 
\family typewriter
IllegalArgumentException
\family default
.
 Stack map frames can use three other special types: 
\family typewriter
UNINITIALIZED_THIS
\family default
 is the initial type of local variable 0 in constructors, 
\family typewriter
TOP
\family default
 corresponds to an undefined value, and 
\family typewriter
NULL
\family default
 corresponds to 
\family typewriter
null
\family default
.
\end_layout

\begin_layout Standard
As said above, starting from Java 6, compiled classes contain, in addition
 to bytecode, a set of stack map frames.
 In order to save space, a compiled method does not contain one frame per
 instruction: in fact it contains only the frames for the instructions that
 correspond to jump targets or exception handlers, or that follow unconditional
 jump instructions.
 Indeed the other frames can be easily and quickly inferred from these ones.
 
\end_layout

\begin_layout Standard
In the case of the 
\family typewriter
checkAndSetF
\family default
 method, this means that only two frames are stored: one for the 
\family typewriter
NEW
\family default
 instruction, because it is the target of the 
\family typewriter
IFLT
\family default
 instruction, but also because it follows the unconditional jump 
\family typewriter
GOTO
\family default
 instruction, and one for the 
\family typewriter
RETURN
\family default
 instruction, because it is the target of the 
\family typewriter
GOTO
\family default
 instruction, and also because it follows the 
\begin_inset Quotes eld
\end_inset

unconditional jump
\begin_inset Quotes erd
\end_inset

 
\family typewriter
ATHROW
\family default
 instruction.
\end_layout

\begin_layout Standard
In order to save even more space, each frame is compressed
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
frames!compression
\end_layout

\end_inset

 by storing only its difference compared to the previous frame, and the
 initial frame is not stored at all, because it can easily be deduced from
 the method parameter types.
 In the case of the 
\family typewriter
checkAndSetF
\family default
 method the two frames that must be stored are equal and are equal to the
 initial frame, so they are stored as the single byte value designated by
 the 
\family typewriter
F_SAME
\family default
 mnemonic.
 These frames can be represented just before their associated bytecode instructi
on.
 This gives the final bytecode for the 
\family typewriter
checkAndSetF
\family default
 method:
\end_layout

\begin_layout LyX-Code
  ILOAD 1
\end_layout

\begin_layout LyX-Code
  IFLT 
\shape slanted
label
\end_layout

\begin_layout LyX-Code
  ALOAD 0
\end_layout

\begin_layout LyX-Code
  ILOAD 1
\end_layout

\begin_layout LyX-Code
  PUTFIELD pkg/Bean f I
\end_layout

\begin_layout LyX-Code
  GOTO 
\shape slanted
end
\end_layout

\begin_layout LyX-Code

\shape slanted
label:
\end_layout

\begin_layout LyX-Code

\series bold
F_SAME
\end_layout

\begin_layout LyX-Code
  NEW java/lang/IllegalArgumentException
\end_layout

\begin_layout LyX-Code
  DUP
\end_layout

\begin_layout LyX-Code
  INVOKESPECIAL java/lang/IllegalArgumentException <init> ()V
\end_layout

\begin_layout LyX-Code
  ATHROW
\end_layout

\begin_layout LyX-Code

\shape slanted
end:
\end_layout

\begin_layout LyX-Code

\series bold
F_SAME
\end_layout

\begin_layout LyX-Code
  RETURN
\end_layout

\begin_layout Section
Interfaces and components
\end_layout

\begin_layout Subsection
Presentation
\begin_inset CommandInset label
LatexCommand label
name "sub:Methods-coreAPI"

\end_inset


\end_layout

\begin_layout Standard
The ASM API for generating and transforming compiled methods is based on
 the 
\family typewriter
MethodVisitor
\family default
 abstract class (see Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:The-MethodVisitor-interface"

\end_inset

), which is returned by the 
\family typewriter
ClassVisitor
\family default
's 
\family typewriter
visitMethod
\family default
 method.
 In addition to some methods related to annotations and debug information,
 which are explained in the next chapter, this class defines one method
 per bytecode instruction category, based on the number and type of arguments
 of these instructions (these categories do 
\emph on
not
\emph default
 correspond to the ones presented in section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Bytecode-instructions"

\end_inset

).
 These methods must be called in the following order (with some additional
 constraints specified in the Javadoc of the 
\family typewriter
MethodVisitor
\family default
 interface):
\end_layout

\begin_layout LyX-Code

\family typewriter
visitAnnotationDefault
\family default

\begin_inset ERT
status collapsed

\begin_layout Plain Layout

{
\backslash
normalfont?}
\end_layout

\end_inset


\end_layout

\begin_layout LyX-Code

\family typewriter
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

{
\backslash
normalfont(~}
\end_layout

\end_inset

visitAnnotation
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

{
\backslash
normalfont~|~}
\end_layout

\end_inset

visitParameterAnnotation
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

{
\backslash
normalfont~|~}
\end_layout

\end_inset

visitAttribute
\family default

\begin_inset ERT
status collapsed

\begin_layout Plain Layout

{
\backslash
normalfont~)*}
\end_layout

\end_inset


\end_layout

\begin_layout LyX-Code

\family typewriter
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

{
\backslash
normalfont(~}
\end_layout

\end_inset

visitCode
\end_layout

\begin_layout LyX-Code
 
\family typewriter
 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

{
\backslash
normalfont(~}
\end_layout

\end_inset

visitTryCatchBlock
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

{
\backslash
normalfont~|~}
\end_layout

\end_inset

visitLabel
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

{
\backslash
normalfont~|~}
\end_layout

\end_inset

visitFrame
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

{
\backslash
normalfont~|~}
\end_layout

\end_inset

visit
\family default
\shape slanted
Xxx
\family typewriter
\shape default
Insn
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

{
\backslash
normalfont~|}
\end_layout

\end_inset


\end_layout

\begin_layout LyX-Code
 
\family typewriter
   visitLocalVariable
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

{
\backslash
normalfont~|~}
\end_layout

\end_inset

visitLineNumber
\family default

\begin_inset ERT
status collapsed

\begin_layout Plain Layout

{
\backslash
normalfont~)*}
\end_layout

\end_inset


\end_layout

\begin_layout LyX-Code
 
\family typewriter
 visitMaxs
\family default

\begin_inset ERT
status collapsed

\begin_layout Plain Layout

{
\backslash
normalfont~)?}
\end_layout

\end_inset


\end_layout

\begin_layout LyX-Code

\family typewriter
visitEnd
\end_layout

\begin_layout Standard
This means that annotations and attributes, if any, must be visited first,
 followed by the method's bytecode, for non abstract methods.
 For these methods the code must be visited in 
\emph on
sequential
\emph default
 order, between exactly one call to 
\family typewriter
visitCode
\family default
 and exactly one call to 
\family typewriter
visitMaxs
\family default
.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout LyX-Code
abstract class 
\series bold
MethodVisitor
\series default
 { // public accessors ommited
\end_layout

\begin_layout LyX-Code
  MethodVisitor(int api);
\end_layout

\begin_layout LyX-Code
  MethodVisitor(int api, MethodVisitor mv);
\end_layout

\begin_layout LyX-Code
  AnnotationVisitor visitAnnotationDefault();
\end_layout

\begin_layout LyX-Code
  AnnotationVisitor visitAnnotation(String desc, boolean visible);
\end_layout

\begin_layout LyX-Code
  AnnotationVisitor visitParameterAnnotation(int parameter,
\end_layout

\begin_layout LyX-Code
      String desc, boolean visible);
\end_layout

\begin_layout LyX-Code
  void visitAttribute(Attribute attr);
\end_layout

\begin_layout LyX-Code
  void 
\series bold
visitCode
\series default
();
\end_layout

\begin_layout LyX-Code
  void 
\series bold
visitFrame
\series default
(int type, int nLocal, Object[] local, int nStack,
\end_layout

\begin_layout LyX-Code
      Object[] stack);
\end_layout

\begin_layout LyX-Code
  void 
\series bold
visitInsn
\series default
(int opcode);
\end_layout

\begin_layout LyX-Code
  void 
\series bold
visitIntInsn
\series default
(int opcode, int operand);
\end_layout

\begin_layout LyX-Code
  void 
\series bold
visitVarInsn
\series default
(int opcode, int var);
\end_layout

\begin_layout LyX-Code
  void 
\series bold
visitTypeInsn
\series default
(int opcode, String desc);
\end_layout

\begin_layout LyX-Code
  void 
\series bold
visitFieldInsn
\series default
(int opc, String owner, String name, String desc);
\end_layout

\begin_layout LyX-Code
  void 
\series bold
visitMethodInsn
\series default
(int opc, String owner, String name, String desc);
\end_layout

\begin_layout LyX-Code
  void 
\series bold
visitInvokeDynamicInsn
\series default
(String name, String desc, Handle bsm, 
\end_layout

\begin_layout LyX-Code
      Object...
 bsmArgs);
\end_layout

\begin_layout LyX-Code
  void 
\series bold
visitJumpInsn
\series default
(int opcode, Label label);
\end_layout

\begin_layout LyX-Code
  void 
\series bold
visitLabel
\series default
(Label label);
\end_layout

\begin_layout LyX-Code
  void 
\series bold
visitLdcInsn
\series default
(Object cst);
\end_layout

\begin_layout LyX-Code
  void 
\series bold
visitIincInsn
\series default
(int var, int increment);
\end_layout

\begin_layout LyX-Code
  void 
\series bold
visitTableSwitchInsn
\series default
(int min, int max, Label dflt, Label[] labels);
\end_layout

\begin_layout LyX-Code
  void 
\series bold
visitLookupSwitchInsn
\series default
(Label dflt, int[] keys, Label[] labels);
\end_layout

\begin_layout LyX-Code
  void 
\series bold
visitMultiANewArrayInsn
\series default
(String desc, int dims);
\end_layout

\begin_layout LyX-Code
  void 
\series bold
visitTryCatchBlock
\series default
(Label start, Label end, Label handler,
\end_layout

\begin_layout LyX-Code
      String type);
\end_layout

\begin_layout LyX-Code
  void visitLocalVariable(String name, String desc, String signature,
\end_layout

\begin_layout LyX-Code
      Label start, Label end, int index);
\end_layout

\begin_layout LyX-Code
  void visitLineNumber(int line, Label start);
\end_layout

\begin_layout LyX-Code
  void 
\series bold
visitMaxs
\series default
(int maxStack, int maxLocals);
\end_layout

\begin_layout LyX-Code
  void 
\series bold
visitEnd
\series default
();
\end_layout

\begin_layout LyX-Code
}
\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:The-MethodVisitor-interface"

\end_inset

The 
\family typewriter
MethodVisitor
\family default

\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
MethodVisitor@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
texttt{MethodVisitor}
\end_layout

\end_inset


\end_layout

\end_inset

 class
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
The 
\family typewriter
visitCode
\family default
 and 
\family typewriter
visitMaxs
\family default
 methods can therefore be used to detect the start and end of the method's
 bytecode in a sequence of events.
 Like for classes, the 
\family typewriter
visitEnd
\family default
 method must be called last, and is used to detect the end of a method in
 a sequence of events.
\end_layout

\begin_layout Standard
The 
\family typewriter
ClassVisitor
\family default
 and 
\family typewriter
MethodVisitor
\family default
 classes can be combined in order to generate complete classes:
\end_layout

\begin_layout LyX-Code
ClassVisitor cv = ...;
\end_layout

\begin_layout LyX-Code
cv.visit(...);
\end_layout

\begin_layout LyX-Code
MethodVisitor mv1 = cv.visitMethod(..., "m1", ...);
\end_layout

\begin_layout LyX-Code
mv1.visitCode();
\end_layout

\begin_layout LyX-Code
mv1.visitInsn(...);
\end_layout

\begin_layout LyX-Code
...
\end_layout

\begin_layout LyX-Code
mv1.visitMaxs(...);
\end_layout

\begin_layout LyX-Code
mv1.visitEnd();
\end_layout

\begin_layout LyX-Code
MethodVisitor mv2 = cv.visitMethod(..., "m2", ...);
\end_layout

\begin_layout LyX-Code
mv2.visitCode();
\end_layout

\begin_layout LyX-Code
mv2.visitInsn(...);
\end_layout

\begin_layout LyX-Code
...
\end_layout

\begin_layout LyX-Code
mv2.visitMaxs(...);
\end_layout

\begin_layout LyX-Code
mv2.visitEnd();
\end_layout

\begin_layout LyX-Code
cv.visitEnd();
\end_layout

\begin_layout Standard
Note that it is not necessary to finish one method in order to start visiting
 another one.
 In fact 
\family typewriter
MethodVisitor
\family default
 instances are completely independent and can be used in any order (as long
 as 
\family typewriter
cv.visitEnd()
\family default
 has not been called):
\end_layout

\begin_layout LyX-Code
ClassVisitor cv = ...;
\end_layout

\begin_layout LyX-Code
cv.visit(...);
\end_layout

\begin_layout LyX-Code
MethodVisitor mv1 = cv.visitMethod(..., "m1", ...);
\end_layout

\begin_layout LyX-Code
mv1.visitCode();
\end_layout

\begin_layout LyX-Code
mv1.visitInsn(...);
\end_layout

\begin_layout LyX-Code
...
\end_layout

\begin_layout LyX-Code
MethodVisitor mv2 = cv.visitMethod(..., "m2", ...);
\end_layout

\begin_layout LyX-Code
mv2.visitCode();
\end_layout

\begin_layout LyX-Code
mv2.visitInsn(...);
\end_layout

\begin_layout LyX-Code
...
\end_layout

\begin_layout LyX-Code
mv1.visitMaxs(...);
\end_layout

\begin_layout LyX-Code
mv1.visitEnd();
\end_layout

\begin_layout LyX-Code
...
\end_layout

\begin_layout LyX-Code
mv2.visitMaxs(...);
\end_layout

\begin_layout LyX-Code
mv2.visitEnd();
\end_layout

\begin_layout LyX-Code
cv.visitEnd();
\end_layout

\begin_layout Standard
ASM provides three core components based on the 
\family typewriter
MethodVisitor
\family default
 API to generate and transform methods:
\end_layout

\begin_layout Itemize
The 
\family typewriter
ClassReader
\family default
 class parses the content of compiled methods and calls the corresponding
 methods on the 
\family typewriter
MethodVisitor
\family default
 objects returned by the 
\family typewriter
ClassVisitor
\family default
 passed as argument to its 
\family typewriter
accept
\family default
 method.
\end_layout

\begin_layout Itemize
The 
\family typewriter
ClassWriter
\family default
's 
\family typewriter
visitMethod
\family default
 method returns an implementation of the 
\family typewriter
MethodVisitor
\family default
 interface that builds compiled methods directly in binary form.
\end_layout

\begin_layout Itemize
The 
\family typewriter
MethodVisitor
\family default
 class delegates all the method calls it receives to another 
\family typewriter
MethodVisitor
\family default
 instance.
 It can be seen as an event filter.
\end_layout

\begin_layout Subsubsection*

\family typewriter
ClassWriter
\family default
 options
\end_layout

\begin_layout Standard
As we have seen in section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Frames"

\end_inset

, computing the stack map frames
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
frames!computing
\end_layout

\end_inset

 for a method is not very easy: you have to compute all the frames, find
 the frames that correspond to jump targets or that follow unconditional
 jumps, and finally compress these remaining frames.
 Likewise, computing the size of the local variables
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
local variables!computing number of
\end_layout

\end_inset

 and operand stack parts for a method is easier but still not very easy.
\end_layout

\begin_layout Standard
Hopefully ASM can compute this for you.
 When you create a 
\family typewriter
ClassWriter
\family default
 you can specify what must be automatically computed:
\end_layout

\begin_layout Itemize
with 
\family typewriter
new ClassWriter(0)
\family default
 nothing is automatically computed.
 You have to compute yourself the frames and the local variables and operand
 stack sizes.
\end_layout

\begin_layout Itemize
with 
\family typewriter
new ClassWriter(ClassWriter.COMPUTE_MAXS)
\family default
 the sizes of the local variables and operand stack parts are computed for
 you.
 You must still call 
\family typewriter
visitMaxs
\family default
, but you can use any arguments: they will be ignored and recomputed.
 With this option you still have to compute the frames yourself.
\end_layout

\begin_layout Itemize
with 
\family typewriter
new ClassWriter(ClassWriter.COMPUTE_FRAMES)
\family default
 everything is computed automatically.
 You don't have to call 
\family typewriter
visitFrame
\family default
, but you must still call 
\family typewriter
visitMaxs
\family default
 (arguments will be ignored and recomputed).
\end_layout

\begin_layout Standard
Using these options
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
ClassWriter@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
texttt{ClassWriter}!options
\end_layout

\end_inset


\end_layout

\end_inset

 is convenient but this has a cost: the 
\family typewriter
COMPUTE_MAXS
\family default
 option makes a 
\family typewriter
ClassWriter
\family default
 
\begin_inset Formula $10\%$
\end_inset

 slower, and using the 
\family typewriter
COMPUTE_FRAMES
\family default
 option makes it 
\emph on
two times
\emph default
 slower.
 This must be compared to the time it would take to compute this yourself:
 in specific situations there are often easier and faster algorithms for
 computing this, compared to the algorithm used in ASM, which must handle
 all cases.
\end_layout

\begin_layout Standard
Note that if you choose to compute the frames yourself, you can let the
 
\family typewriter
ClassWriter
\family default
 class do the compression step for you.
 For this you just have to visit your uncompressed frames with 
\family typewriter
visitFrame(
\series bold
F_NEW
\series default
, nLocals, locals, nStack, stack)
\family default
, where 
\family typewriter
nLocals
\family default
 and 
\family typewriter
nStack
\family default
 are the number of locals and the operand stack size, and 
\family typewriter
locals
\family default
 and 
\family typewriter
stack
\family default
 are arrays containing the corresponding types (see the Javadoc for more
 details).
\end_layout

\begin_layout Standard
Note also that, in order to compute frames automatically, it is sometimes
 necessary to compute the common super class of two given classes.
 By default the 
\family typewriter
ClassWriter
\family default
 class computes this, in the 
\family typewriter
getCommonSuperClass
\family default
 method, by loading the two classes into the JVM and by using the reflection
 API.
 This can be a problem if you are generating several classes that reference
 each other, because the referenced classes may not yet exist.
 In this case you can override the 
\family typewriter
getCommonSuperClass
\family default
 method to solve this problem.
\end_layout

\begin_layout Subsection
Generating methods
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
methods!generating
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The bytecode of the 
\family typewriter
getF
\family default
 method defined in section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Bytecode-sequence-examples"

\end_inset

 can be generated with the following method calls, if 
\family typewriter
mv
\family default
 is a 
\family typewriter
MethodVisitor
\family default
:
\end_layout

\begin_layout LyX-Code
mv.visitCode();
\end_layout

\begin_layout LyX-Code
mv.visitVarInsn(ALOAD, 0);
\end_layout

\begin_layout LyX-Code
mv.visitFieldInsn(GETFIELD, "pkg/Bean", "f", "I");
\end_layout

\begin_layout LyX-Code
mv.visitInsn(IRETURN);
\end_layout

\begin_layout LyX-Code
mv.visitMaxs(1, 1);
\end_layout

\begin_layout LyX-Code
mv.visitEnd();
\end_layout

\begin_layout Standard
The first call starts the bytecode generation.
 It is followed by three calls that generate the three instructions of this
 method (as you can see the mapping between the bytecode and the ASM API
 is quite simple).
 The call to 
\family typewriter
visitMaxs
\family default
 must be done after all the instructions have been visited.
 It is used to define the sizes of the local variables and operand stack
 parts for the execution frame of this method.
 As we saw in section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Bytecode-sequence-examples"

\end_inset

, these sizes are 1 slot for each part.
 Finally the last call is used to end the generation of the method.
\end_layout

\begin_layout Standard
The bytecode of the 
\family typewriter
setF
\family default
 method and of the constructor can be generated in a similar way.
 A more interesting example is the 
\family typewriter
checkAndSetF
\family default
 method:
\end_layout

\begin_layout LyX-Code
mv.visitCode();
\end_layout

\begin_layout LyX-Code
mv.visitVarInsn(ILOAD, 1);
\end_layout

\begin_layout LyX-Code
Label label = new Label();
\end_layout

\begin_layout LyX-Code
mv.visitJumpInsn(IFLT, label);
\end_layout

\begin_layout LyX-Code
mv.visitVarInsn(ALOAD, 0);
\end_layout

\begin_layout LyX-Code
mv.visitVarInsn(ILOAD, 1);
\end_layout

\begin_layout LyX-Code
mv.visitFieldInsn(PUTFIELD, "pkg/Bean", "f", "I");
\end_layout

\begin_layout LyX-Code
Label end = new Label();
\end_layout

\begin_layout LyX-Code
mv.visitJumpInsn(GOTO, end);
\end_layout

\begin_layout LyX-Code
mv.visitLabel(label);
\end_layout

\begin_layout LyX-Code
mv.visitFrame(F_SAME, 0, null, 0, null);
\end_layout

\begin_layout LyX-Code
mv.visitTypeInsn(NEW, "java/lang/IllegalArgumentException");
\end_layout

\begin_layout LyX-Code
mv.visitInsn(DUP);
\end_layout

\begin_layout LyX-Code
mv.visitMethodInsn(INVOKESPECIAL,
\end_layout

\begin_layout LyX-Code
    "java/lang/IllegalArgumentException", "<init>", "()V");
\end_layout

\begin_layout LyX-Code
mv.visitInsn(ATHROW);
\end_layout

\begin_layout LyX-Code
mv.visitLabel(end);
\end_layout

\begin_layout LyX-Code
mv.visitFrame(F_SAME, 0, null, 0, null);
\end_layout

\begin_layout LyX-Code
mv.visitInsn(RETURN);
\end_layout

\begin_layout LyX-Code
mv.visitMaxs(2, 2);
\end_layout

\begin_layout LyX-Code
mv.visitEnd();
\end_layout

\begin_layout Standard
Between the 
\family typewriter
visitCode
\family default
 and 
\family typewriter
visitEnd
\family default
 calls you can see method calls that map exactly to the bytecode shown at
 the end of section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Frames"

\end_inset

: one call per instruction, label or frame (the only exceptions are the
 declaration and construction of the 
\family typewriter
label
\family default
 and 
\family typewriter
end
\family default
 
\family typewriter
Label
\family default
 objects).
\end_layout

\begin_layout Description
Note: a 
\family typewriter
Label
\family default

\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
Label@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
texttt{Label}
\end_layout

\end_inset


\end_layout

\end_inset

 object designates the 
\emph on
instruction
\emph default
 that follows the 
\family typewriter
visitLabel
\family default
 call for this label.
 For example 
\family typewriter
end
\family default
 designates the 
\family typewriter
RETURN
\family default
 instruction, and not the frame that is visited just after, since this is
 not an instruction.
 It is perfectly legal to have several labels designating the same instruction,
 but a label must designate exactly one instruction.
 In other words it is possible to have successive calls to 
\family typewriter
visitLabel
\family default
 with different labels, but a label used in an instruction must be visited
 exactly once with 
\family typewriter
visitLabel
\family default
.
 A last constraint is that labels can not be shared: each method must have
 its own labels.
\end_layout

\begin_layout Subsection
Transforming methods
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
methods!transforming
\end_layout

\end_inset


\end_layout

\begin_layout Standard
You should now have guessed that methods can be transformed like classes,
 i.e.
 by using a method adapter that forwards the method calls it receives with
 some modifications: changing arguments can be used to change individual
 instructions, not forwarding a received call removes an instruction, and
 inserting calls between the received ones adds new instructions.
 The 
\family typewriter
MethodVisitor
\family default
 class provides a basic implementation of such a method adapter, which does
 nothing else than just forwarding all the method calls it receives.
\end_layout

\begin_layout Standard
In order to understand how method adapters can be used, let's consider a
 very simple adapter that removes the 
\family typewriter
NOP
\family default
 instructions inside methods (they can be removed without problems since
 they do nothing):
\end_layout

\begin_layout LyX-Code
public class RemoveNopAdapter extends MethodVisitor {
\end_layout

\begin_layout LyX-Code
  public RemoveNopAdapter(MethodVisitor mv) {
\end_layout

\begin_layout LyX-Code
    super(ASM4, mv);
\end_layout

\begin_layout LyX-Code
  }
\end_layout

\begin_layout LyX-Code
  @Override 
\end_layout

\begin_layout LyX-Code
  public void visitInsn(int opcode) {
\end_layout

\begin_layout LyX-Code
    
\series bold
if (opcode != NOP) {
\end_layout

\begin_layout LyX-Code
 
\series bold
     mv.visitInsn(opcode);
\end_layout

\begin_layout LyX-Code
 
\series bold
   }
\end_layout

\begin_layout LyX-Code
  }
\end_layout

\begin_layout LyX-Code
}
\end_layout

\begin_layout Standard
This adapter can be used inside a class adapter as follows:
\end_layout

\begin_layout LyX-Code
public class RemoveNopClassAdapter extends ClassVisitor {
\end_layout

\begin_layout LyX-Code
  public RemoveNopClassAdapter(ClassVisitor cv) {
\end_layout

\begin_layout LyX-Code
    super(ASM4, cv);
\end_layout

\begin_layout LyX-Code
  }
\end_layout

\begin_layout LyX-Code
  @Override 
\end_layout

\begin_layout LyX-Code
  public MethodVisitor visitMethod(int access, String name,
\end_layout

\begin_layout LyX-Code
      String desc, String signature, String[] exceptions) {
\end_layout

\begin_layout LyX-Code
    MethodVisitor mv;
\end_layout

\begin_layout LyX-Code
    
\series bold
mv = cv.visitMethod(access, name, desc, signature, exceptions);
\end_layout

\begin_layout LyX-Code
 
\series bold
   if (mv != null) {
\end_layout

\begin_layout LyX-Code
 
\series bold
     mv = new RemoveNopAdapter(mv);
\end_layout

\begin_layout LyX-Code
 
\series bold
   }
\end_layout

\begin_layout LyX-Code
    return mv;
\end_layout

\begin_layout LyX-Code
  }
\end_layout

\begin_layout LyX-Code
}
\end_layout

\begin_layout Standard
In other words the class adapter just builds a method adapter encapsulating
 the method visitor returned by the next class visitor in the chain, and
 returns this adapter.
 The effect is the construction of a method adapter chain that is similar
 to the class adapter chain (see Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Sequence-diagram-for-RemoveNopAdapter"

\end_inset

).
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename figures/removenop.eps
	scale 80

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Sequence-diagram-for-RemoveNopAdapter"

\end_inset

Sequence diagram for the 
\family typewriter
RemoveNopAdapter
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Note however that this is not mandatory: it is perfectly possible to build
 a method adapter chain that is not similar to the class adapter chain.
 Each method can even have a different method adapter chain.
 For instance the class adapter could choose to remove 
\family typewriter
NOP
\family default
s only in methods and not in constructors.
 This can be done as follows:
\end_layout

\begin_layout LyX-Code
...
\end_layout

\begin_layout LyX-Code
mv = cv.visitMethod(access, name, desc, signature, exceptions);
\end_layout

\begin_layout LyX-Code
if (mv != null && 
\series bold
!name.equals("<init>")
\series default
) {
\end_layout

\begin_layout LyX-Code
  mv = new RemoveNopAdapter(mv);
\end_layout

\begin_layout LyX-Code
}
\end_layout

\begin_layout LyX-Code
...
\end_layout

\begin_layout Standard
In this case the adapter chain is shorter for constructors.
 On the contrary, the adapter chain for constructors could have been longer,
 with several method adapters chained together created inside 
\family typewriter
visitMethod
\family default
.
 The method adapter chain can even have a different topology than the class
 adapter chain.
 For instance the class adapter chain could be linear, while the method
 adapter chain has branches:
\end_layout

\begin_layout LyX-Code
public MethodVisitor visitMethod(int access, String name,
\end_layout

\begin_layout LyX-Code
    String desc, String signature, String[] exceptions) {
\end_layout

\begin_layout LyX-Code
  MethodVisitor mv1, mv2;
\end_layout

\begin_layout LyX-Code
  mv1 = cv.visitMethod(access, name, desc, signature, exceptions);
\end_layout

\begin_layout LyX-Code
  mv2 = cv.visitMethod(access, "_" + name, desc, signature, exceptions);
\end_layout

\begin_layout LyX-Code
  return new MultiMethodAdapter(mv1, mv2);
\end_layout

\begin_layout LyX-Code
}
\end_layout

\begin_layout Standard
Now that we have seen how method adapters can be used and combined inside
 a class adapter, let's see how to implement more interesting adapters than
 
\family typewriter
RemoveNopAdapter
\family default
.
\end_layout

\begin_layout Subsection
Stateless transformations
\begin_inset CommandInset label
LatexCommand label
name "sub:Stateless-transformations"

\end_inset


\end_layout

\begin_layout Standard
Let's suppose we want to measure the time spent in each class of a program.
 We need to add a static timer field in each class, and we need to add the
 execution time of each method of this class to this timer field.
 In other words we want to transform a class such as 
\family typewriter
C
\family default
:
\end_layout

\begin_layout LyX-Code
public class C {
\end_layout

\begin_layout LyX-Code
  public void m() throws Exception {
\end_layout

\begin_layout LyX-Code
    Thread.sleep(100);
\end_layout

\begin_layout LyX-Code
  }
\end_layout

\begin_layout LyX-Code
}
\end_layout

\begin_layout Standard
into this:
\end_layout

\begin_layout LyX-Code
public class C {
\end_layout

\begin_layout LyX-Code
  
\series bold
public static long timer;
\end_layout

\begin_layout LyX-Code
  public void m() throws Exception {
\end_layout

\begin_layout LyX-Code
    
\series bold
timer -= System.currentTimeMillis();
\end_layout

\begin_layout LyX-Code
    Thread.sleep(100);
\end_layout

\begin_layout LyX-Code
    
\series bold
timer += System.currentTimeMillis();
\end_layout

\begin_layout LyX-Code
  }
\end_layout

\begin_layout LyX-Code
}
\end_layout

\begin_layout Standard
In order to have an idea of how this can be implemented in ASM, we can compile
 these two classes and compare the output of 
\family typewriter
TraceClassVisitor
\family default
 on these two versions (either with the default 
\family typewriter
Textifier
\family default
 backend, or with an 
\family typewriter
ASMifier
\family default
 backend).
 With the default backend we get the following differences (in bold):
\end_layout

\begin_layout LyX-Code

\series bold
GETSTATIC C.timer : J
\end_layout

\begin_layout LyX-Code

\series bold
INVOKESTATIC java/lang/System.currentTimeMillis()J
\end_layout

\begin_layout LyX-Code

\series bold
LSUB
\end_layout

\begin_layout LyX-Code

\series bold
PUTSTATIC C.timer : J
\end_layout

\begin_layout LyX-Code
LDC 100
\end_layout

\begin_layout LyX-Code
INVOKESTATIC java/lang/Thread.sleep(J)V
\end_layout

\begin_layout LyX-Code

\series bold
GETSTATIC C.timer : J
\end_layout

\begin_layout LyX-Code

\series bold
INVOKESTATIC java/lang/System.currentTimeMillis()J
\end_layout

\begin_layout LyX-Code

\series bold
LADD
\end_layout

\begin_layout LyX-Code

\series bold
PUTSTATIC C.timer : J
\end_layout

\begin_layout LyX-Code
RETURN
\end_layout

\begin_layout LyX-Code
MAXSTACK = 
\series bold
4
\end_layout

\begin_layout LyX-Code
MAXLOCALS = 1
\end_layout

\begin_layout Standard
We see that we must add four instructions at the beginning of the method,
 and four other instructions before the return instruction.
 We also need to update the maximum operand stack size.
 The beginning of the method's code is visited with the 
\family typewriter
visitCode
\family default
 method.
 We can therefore add the first four instructions by overriding this method
 in our method adapter:
\end_layout

\begin_layout LyX-Code
public void visitCode() {
\end_layout

\begin_layout LyX-Code
  mv.visitCode();
\end_layout

\begin_layout LyX-Code
  
\series bold
mv.visitFieldInsn(GETSTATIC, owner, "timer", "J");
\end_layout

\begin_layout LyX-Code
 
\series bold
 mv.visitMethodInsn(INVOKESTATIC, "java/lang/System",
\end_layout

\begin_layout LyX-Code
 
\series bold
     "currentTimeMillis", "()J");
\end_layout

\begin_layout LyX-Code
 
\series bold
 mv.visitInsn(LSUB);
\end_layout

\begin_layout LyX-Code
 
\series bold
 mv.visitFieldInsn(PUTSTATIC, owner, "timer", "J");
\end_layout

\begin_layout LyX-Code
}
\end_layout

\begin_layout Standard
where 
\family typewriter
owner
\family default
 must be set to the name of the class that is being transformed.
 We must now add four other instructions before any 
\family typewriter
RETURN
\family default
, but also before any 
\emph on
x
\family typewriter
\emph default
RETURN
\family default
 or before 
\family typewriter
ATHROW
\family default
, which are all the instructions that terminate the method's execution.
 These instructions do not have any argument, and are therefore visited
 in the 
\family typewriter
visitInsn
\family default
 method.
 We can then override this method in order to add our instructions:
\end_layout

\begin_layout LyX-Code
public void visitInsn(int opcode) {
\end_layout

\begin_layout LyX-Code
  if ((opcode >= IRETURN && opcode <= RETURN) || opcode == ATHROW) {
\end_layout

\begin_layout LyX-Code
    
\series bold
mv.visitFieldInsn(GETSTATIC, owner, "timer", "J");
\end_layout

\begin_layout LyX-Code
 
\series bold
   mv.visitMethodInsn(INVOKESTATIC, "java/lang/System",
\end_layout

\begin_layout LyX-Code
 
\series bold
       "currentTimeMillis", "()J");
\end_layout

\begin_layout LyX-Code
 
\series bold
   mv.visitInsn(LADD);
\end_layout

\begin_layout LyX-Code
 
\series bold
   mv.visitFieldInsn(PUTSTATIC, owner, "timer", "J");
\end_layout

\begin_layout LyX-Code
  }
\end_layout

\begin_layout LyX-Code
  mv.visitInsn(opcode);
\end_layout

\begin_layout LyX-Code
}
\end_layout

\begin_layout Standard
Finally we must update the maximum operand stack size
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
operand stack!updating size
\end_layout

\end_inset

.
 The instructions that we add push two long values, and therefore require
 four slots on the operand stack.
 At the beginning of the method the operand stack is initially empty, so
 we know that the four instructions added at the beginning require a stack
 of size 
\begin_inset Formula $4$
\end_inset

.
 We also know that our inserted code leaves the stack state unchanged (because
 it pops as many values as it pushes).
 As a consequence, if the original code requires a stack of size 
\begin_inset Formula $s$
\end_inset

, the maximum stack size needed by the transformed method is 
\begin_inset Formula $max(4,s)$
\end_inset

.
 Unfortunately we also add four instructions before the return instructions,
 and here we do not know the size of the operand stack just before these
 instructions.
 We just know that it is less than or equal to 
\begin_inset Formula $s$
\end_inset

.
 As a consequence we can just say that the code added before the return
 instructions may require an operand stack of size up to 
\begin_inset Formula $s+4$
\end_inset

.
 This worst case scenario rarely happens in practice: with common compilers
 the operand stack before a 
\family typewriter
RETURN
\family default
 contains only the return value, i.e.
 it has a size of 0, 1 or 2 at most.
 But if we want to handle all possible cases, we need to use the worst case
 scenario
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
hopefully it is not necessary to give the optimal operand stack size.
 Giving any value greater than or equal to this optimal value is possible,
 although it may waste memory on the thread's execution stack.
\end_layout

\end_inset

.
 We must then override the 
\family typewriter
visitMaxs
\family default
 method as follows:
\end_layout

\begin_layout LyX-Code
public void visitMaxs(int maxStack, int maxLocals) {
\end_layout

\begin_layout LyX-Code
  mv.visitMaxs(maxStack + 4, maxLocals);
\end_layout

\begin_layout LyX-Code
}
\end_layout

\begin_layout Standard
Of course it is possible to not bother about the maximum stack size and
 rely on the 
\family typewriter
COMPUTE_MAXS
\family default
 option that, in addition, will compute the optimal value and not a worst
 case value.
 But for such simple transformations it does not cost much effort to update
 
\family typewriter
maxStack
\family default
 manually.
\end_layout

\begin_layout Standard
Now an interesting question is: what about stack map frames? The original
 code did not contain any frame, nor the transformed one, but is this due
 to the specific code we used as example? are there some situations where
 frames must be updated
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
frames!updating
\end_layout

\end_inset

? The answer is no because 1) the inserted code leaves the operand stack
 unchanged, 2) the inserted code does not contain jump instructions and
 3) the jump instructions -- or, more formally, the control flow graph
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
control flow graph
\end_layout

\end_inset

 -- of the original code is not modified.
 This means that the original frames do not change, and since no new frames
 must be stored for the inserted code, the compressed original frames do
 not change either.
\end_layout

\begin_layout Standard
We can now put all the elements together in associated 
\family typewriter
ClassVisitor
\family default
 and 
\family typewriter
MethodVisitor
\family default
 subclasses:
\end_layout

\begin_layout LyX-Code
public class AddTimerAdapter extends ClassVisitor {
\end_layout

\begin_layout LyX-Code
  private String owner;
\end_layout

\begin_layout LyX-Code
  private boolean isInterface;
\end_layout

\begin_layout LyX-Code
  public AddTimerAdapter(ClassVisitor cv) {
\end_layout

\begin_layout LyX-Code
    super(ASM4, cv);
\end_layout

\begin_layout LyX-Code
  }
\end_layout

\begin_layout LyX-Code
  @Override public void visit(int version, int access, String name,
\end_layout

\begin_layout LyX-Code
      String signature, String superName, String[] interfaces) {
\end_layout

\begin_layout LyX-Code
    cv.visit(version, access, name, signature, superName, interfaces);
\end_layout

\begin_layout LyX-Code
    
\series bold
owner = name;
\end_layout

\begin_layout LyX-Code
    
\series bold
isInterface = (access & ACC_INTERFACE) != 0;
\end_layout

\begin_layout LyX-Code
  }
\end_layout

\begin_layout LyX-Code
  @Override public MethodVisitor visitMethod(int access, String name,
\end_layout

\begin_layout LyX-Code
      String desc, String signature, String[] exceptions) {
\end_layout

\begin_layout LyX-Code
    MethodVisitor mv = cv.visitMethod(access, name, desc, signature,
\end_layout

\begin_layout LyX-Code
        exceptions);
\end_layout

\begin_layout LyX-Code
    
\series bold
if (!isInterface && mv != null && !name.equals("<init>")) {
\end_layout

\begin_layout LyX-Code
 
\series bold
     mv = new AddTimerMethodAdapter(mv);
\end_layout

\begin_layout LyX-Code
 
\series bold
   }
\end_layout

\begin_layout LyX-Code
    return mv;
\end_layout

\begin_layout LyX-Code
  }
\end_layout

\begin_layout LyX-Code
  @Override public void visitEnd() {
\end_layout

\begin_layout LyX-Code
    
\series bold
if (!isInterface) {
\end_layout

\begin_layout LyX-Code
 
\series bold
     FieldVisitor fv = cv.visitField(ACC_PUBLIC + ACC_STATIC, "timer",
\end_layout

\begin_layout LyX-Code
 
\series bold
         "J", null, null);
\end_layout

\begin_layout LyX-Code
      if (fv != null) {
\end_layout

\begin_layout LyX-Code
        fv.visitEnd();
\end_layout

\begin_layout LyX-Code
      }
\end_layout

\begin_layout LyX-Code
    }
\end_layout

\begin_layout LyX-Code
    cv.visitEnd();
\end_layout

\begin_layout LyX-Code
  }
\end_layout

\begin_layout LyX-Code
  class AddTimerMethodAdapter extends MethodVisitor {
\end_layout

\begin_layout LyX-Code
    public AddTimerMethodAdapter(MethodVisitor mv) {
\end_layout

\begin_layout LyX-Code
      super(ASM4, mv);
\end_layout

\begin_layout LyX-Code
    }
\end_layout

\begin_layout LyX-Code
    @Override public void visitCode() {
\end_layout

\begin_layout LyX-Code
      
\series bold
mv.visitCode();
\end_layout

\begin_layout LyX-Code
 
\series bold
     mv.visitFieldInsn(GETSTATIC, owner, "timer", "J");
\end_layout

\begin_layout LyX-Code
 
\series bold
     mv.visitMethodInsn(INVOKESTATIC, "java/lang/System",
\end_layout

\begin_layout LyX-Code
 
\series bold
         "currentTimeMillis", "()J");
\end_layout

\begin_layout LyX-Code
 
\series bold
     mv.visitInsn(LSUB);
\end_layout

\begin_layout LyX-Code
 
\series bold
     mv.visitFieldInsn(PUTSTATIC, owner, "timer", "J");
\end_layout

\begin_layout LyX-Code
    }
\end_layout

\begin_layout LyX-Code
    @Override public void visitInsn(int opcode) {
\end_layout

\begin_layout LyX-Code
      
\series bold
if ((opcode >= IRETURN && opcode <= RETURN) || opcode == ATHROW) {
\end_layout

\begin_layout LyX-Code
 
\series bold
       mv.visitFieldInsn(GETSTATIC, owner, "timer", "J");
\end_layout

\begin_layout LyX-Code
 
\series bold
       mv.visitMethodInsn(INVOKESTATIC, "java/lang/System",
\end_layout

\begin_layout LyX-Code
 
\series bold
           "currentTimeMillis", "()J");
\end_layout

\begin_layout LyX-Code
 
\series bold
       mv.visitInsn(LADD);
\end_layout

\begin_layout LyX-Code
 
\series bold
       mv.visitFieldInsn(PUTSTATIC, owner, "timer", "J");
\end_layout

\begin_layout LyX-Code
 
\series bold
     }
\end_layout

\begin_layout LyX-Code
 
\series bold
     mv.visitInsn(opcode);
\end_layout

\begin_layout LyX-Code
    }
\end_layout

\begin_layout LyX-Code
    @Override public void visitMaxs(int maxStack, int maxLocals) {
\end_layout

\begin_layout LyX-Code
      mv.visitMaxs(maxStack 
\series bold
+ 4
\series default
, maxLocals);
\end_layout

\begin_layout LyX-Code
    }
\end_layout

\begin_layout LyX-Code
  }
\end_layout

\begin_layout LyX-Code
}
\end_layout

\begin_layout Standard
The class adapter is used to instantiate the method adapter (except for
 constructors), but also to add the timer field and to store the name of
 the class that is being transformed in a field that can be accessed from
 the method adapter.
\end_layout

\begin_layout Subsection
Statefull transformations
\begin_inset CommandInset label
LatexCommand label
name "sub:Statefull-transformations"

\end_inset


\end_layout

\begin_layout Standard
The transformation seen in the previous section is local and does not depend
 on the instructions that have been visited before the current one: the
 code added at the beginning is always the same and is always added, and
 likewise for the code inserted before each 
\family typewriter
RETURN
\family default
 instruction.
 Such transformations are called 
\emph on
stateless
\emph default
 transformations.
 They are simple to implement but only the simplest transformations verify
 this property.
\end_layout

\begin_layout Standard
More complex transformations require memorizing some state about the instruction
s that have been visited before the current one.
 Consider for example a transformation that removes all occurrences of the
 
\family typewriter
ICONST_0
\family default
 
\family typewriter
IADD
\family default
 sequence, whose empty effect is to add 0.
 It is clear that when an 
\family typewriter
IADD
\family default
 instruction is visited, it must be removed only if the last visited instruction
 was an 
\family typewriter
ICONST_0
\family default
.
 This requires storing state inside the method adapter.
 For this reason such transformations are called 
\emph on
statefull
\emph default
 transformations.
\end_layout

\begin_layout Standard
Let's look in more details at this example.
 When an 
\family typewriter
ICONST_0
\family default
 is visited, it must be removed only if the 
\emph on
next
\emph default
 instruction is an 
\family typewriter
IADD
\family default
.
 The problem is that the next instruction is not yet known.
 The solution is to postpone this decision to the next instruction: if it
 is an 
\family typewriter
IADD
\family default
 then remove both instructions, otherwise emit the 
\family typewriter
ICONST_0
\family default
 and the current instruction.
\end_layout

\begin_layout Standard
In order to implement transformations that remove or replace some instruction
 sequence, it is convenient to introduce a 
\family typewriter
MethodVisitor
\family default
 subclass whose 
\family typewriter
visit
\emph on
Xxx
\emph default
Insn
\family default
 methods call a common 
\family typewriter
visitInsn()
\family default
 method:
\end_layout

\begin_layout LyX-Code
public abstract class PatternMethodAdapter extends MethodVisitor {
\end_layout

\begin_layout LyX-Code
  protected final static int SEEN_NOTHING = 0;
\end_layout

\begin_layout LyX-Code
  protected int 
\series bold
state
\series default
;
\end_layout

\begin_layout LyX-Code
  public PatternMethodAdapter(int api, MethodVisitor mv) {
\end_layout

\begin_layout LyX-Code
    super(api, mv);
\end_layout

\begin_layout LyX-Code
  }
\end_layout

\begin_layout LyX-Code
  @Overrid public void visitInsn(int opcode) {
\end_layout

\begin_layout LyX-Code
    
\series bold
visitInsn
\series default
();
\end_layout

\begin_layout LyX-Code
    mv.visitInsn(opcode);
\end_layout

\begin_layout LyX-Code
  }
\end_layout

\begin_layout LyX-Code
  @Override public void visitIntInsn(int opcode, int operand) {
\end_layout

\begin_layout LyX-Code
    
\series bold
visitInsn
\series default
();
\end_layout

\begin_layout LyX-Code
    mv.visitIntInsn(opcode, operand);
\end_layout

\begin_layout LyX-Code
  }
\end_layout

\begin_layout LyX-Code
  ...
\end_layout

\begin_layout LyX-Code
  protected abstract void 
\series bold
visitInsn
\series default
();
\end_layout

\begin_layout LyX-Code
}
\end_layout

\begin_layout Standard
Then the above transformation can be implemented like this:
\end_layout

\begin_layout LyX-Code
public class RemoveAddZeroAdapter extends PatternMethodAdapter {
\end_layout

\begin_layout LyX-Code
  private static int SEEN_ICONST_0 = 1;
\end_layout

\begin_layout LyX-Code
  public RemoveAddZeroAdapter(MethodVisitor mv) {
\end_layout

\begin_layout LyX-Code
    super(ASM4, mv);
\end_layout

\begin_layout LyX-Code
  }
\end_layout

\begin_layout LyX-Code
  @Override public void visitInsn(int opcode) {
\end_layout

\begin_layout LyX-Code
    if (state == SEEN_ICONST_0) {
\end_layout

\begin_layout LyX-Code
      if (opcode == IADD) {
\end_layout

\begin_layout LyX-Code
        state = SEEN_NOTHING;
\end_layout

\begin_layout LyX-Code
        return;
\end_layout

\begin_layout LyX-Code
      }
\end_layout

\begin_layout LyX-Code
    }
\end_layout

\begin_layout LyX-Code
    visitInsn();
\end_layout

\begin_layout LyX-Code
    if (opcode == ICONST_0) {
\end_layout

\begin_layout LyX-Code
      state = SEEN_ICONST_0;
\end_layout

\begin_layout LyX-Code
      return;
\end_layout

\begin_layout LyX-Code
    }
\end_layout

\begin_layout LyX-Code
    mv.visitInsn(opcode);
\end_layout

\begin_layout LyX-Code
  }
\end_layout

\begin_layout LyX-Code
  @Override protected void visitInsn() {
\end_layout

\begin_layout LyX-Code
    if (state == SEEN_ICONST_0) {
\end_layout

\begin_layout LyX-Code
      mv.visitInsn(ICONST_0);
\end_layout

\begin_layout LyX-Code
    }
\end_layout

\begin_layout LyX-Code
    state = SEEN_NOTHING;
\end_layout

\begin_layout LyX-Code
  }
\end_layout

\begin_layout LyX-Code
}
\end_layout

\begin_layout Standard
The 
\family typewriter
visitInsn(int)
\family default
 method first tests if the sequence has been detected.
 In this case it reinitializes 
\family typewriter
state
\family default
 and returns immediately, which has the effect of removing the sequence.
 In the other cases it calls the common 
\family typewriter
visitInsn
\family default
 method, which emits an 
\family typewriter
ICONST_0
\family default
 if this was the 
\emph on
last
\emph default
 visited instruction.
 Then, if the 
\emph on
current
\emph default
 instruction is an 
\family typewriter
ICONST_0
\family default
, it memorizes this fact and returns, in order to postpone the decision
 about this instruction.
 In all other cases the current instruction is forwarded to the next visitor.
\end_layout

\begin_layout Subsubsection*
Labels and frames
\end_layout

\begin_layout Standard
As we have seen in the previous sections, labels and frames are visited
 just before their associated instruction.
 In other words they are visited at the same time as instructions, although
 they are not instructions themselves.
 This has an impact on transformations that detect 
\emph on
instruction
\emph default
 sequences, but this impact is in fact an advantage.
 Indeed, what happens if one of the instructions we remove is the target
 of a jump instruction? If some instruction may jump to the 
\family typewriter
ICONST_0
\family default
, this means that there is a label designating this instruction.
 After the removal of the two instructions this label will designate the
 instruction that follows the removed 
\family typewriter
IADD
\family default
, which is what we want.
 But if some instruction may jump to the 
\family typewriter
IADD
\family default
, we can not remove the instruction sequence (we can not be sure that before
 this jump a 0 was pushed on the stack).
 Hopefully, in this case, there must be a label between the 
\family typewriter
ICONST_0
\family default
 and the 
\family typewriter
IADD
\family default
, which can easily be detected.
\end_layout

\begin_layout Standard
The reasoning is the same for stack map frames: if a stack map frame is
 visited between the two instructions, we can not remove them.
 Both cases can be handled by considering labels and frames as instructions
 in the pattern matching algorithm.
 This can be done in 
\family typewriter
PatternMethodAdapter
\family default

\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
PatternMethodAdapter@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
texttt{PatternMethodAdapter}
\end_layout

\end_inset


\end_layout

\end_inset

 (note that 
\family typewriter
visitMaxs
\family default
 also calls the common 
\family typewriter
visitInsn
\family default
 method; this is used to handle the case where the end of the method is
 a prefix of the sequence that must be detected):
\end_layout

\begin_layout LyX-Code
public abstract class PatternMethodAdapter extends MethodVisitor {
\end_layout

\begin_layout LyX-Code
  ...
\end_layout

\begin_layout LyX-Code
  @Override public void visitFrame(int type, int nLocal, Object[] local,
\end_layout

\begin_layout LyX-Code
      int nStack, Object[] stack) {
\end_layout

\begin_layout LyX-Code
    
\series bold
visitInsn
\series default
();
\end_layout

\begin_layout LyX-Code
    mv.visitFrame(type, nLocal, local, nStack, stack);
\end_layout

\begin_layout LyX-Code
  }
\end_layout

\begin_layout LyX-Code
  @Override public void visitLabel(Label label) {
\end_layout

\begin_layout LyX-Code
    
\series bold
visitInsn
\series default
();
\end_layout

\begin_layout LyX-Code
    mv.visitLabel(label);
\end_layout

\begin_layout LyX-Code
  }
\end_layout

\begin_layout LyX-Code
  @Override public void visitMaxs(int maxStack, int maxLocals) {
\end_layout

\begin_layout LyX-Code
    
\series bold
visitInsn
\series default
();
\end_layout

\begin_layout LyX-Code
    mv.visitMaxs(maxStack, maxLocals);
\end_layout

\begin_layout LyX-Code
  }
\end_layout

\begin_layout LyX-Code
}
\end_layout

\begin_layout Standard
As we will see in the next chapter, a compiled method may contain information
 about source file line numbers, used for instance in exception stack traces.
 This information is visited with the 
\family typewriter
visitLineNumber
\family default
 method, which is also called at the same time as instructions.
 Here however the presence of line numbers in the middle of an instruction
 sequence does not have any impact on the possibility to transform or remove
 it.
 The solution is therefore to ignore them completely in the pattern matching
 algorithm.
\end_layout

\begin_layout Subsubsection*
A more complex example
\end_layout

\begin_layout Standard
The previous example can be easily generalized to more complex instruction
 sequences.
 Consider for example a transformation that removes self field assignments,
 generally due to typos, such as 
\family typewriter
f = f;
\family default
 or, in bytecode, 
\family typewriter
ALOAD
\family default
 
\family typewriter
0
\family default
 
\family typewriter
ALOAD
\family default
 
\family typewriter
0
\family default
 
\family typewriter
GETFIELD
\family default
 
\family typewriter
f
\family default
 
\family typewriter
PUTFIELD
\family default
 
\family typewriter
f
\family default
.
 Before implementing this transformation, it is preferable to design the
 state machine to recognize this sequence (see Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:StateMachine-for-RemoveSelfAssignAdapter"

\end_inset

).
\end_layout

\begin_layout Standard
\noindent
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename figures/automaton.eps
	scale 80

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:StateMachine-for-RemoveSelfAssignAdapter"

\end_inset

State machine for 
\family typewriter
ALOAD 0 ALOAD 0 GETFIELD f PUTFIELD f
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Each transition is labeled with a condition (the value of the current instructio
n) and an action (an instruction sequence that must be emitted, in bold).
 For instance the transition from S1 to S0 happens if the current instruction
 is not an 
\family typewriter
ALOAD
\family default
 
\family typewriter
0
\family default
.
 In this case the 
\family typewriter
ALOAD
\family default
 
\family typewriter
0
\family default
 that was visited to arrive at this state is emitted.
 Note the transition from S2 to itself: this happens when three or more
 consecutive 
\family typewriter
ALOAD
\family default
 
\family typewriter
0
\family default
 are found.
 In this case we stay in the state where two 
\family typewriter
ALOAD
\family default
 
\family typewriter
0
\family default
 have been visited, and we emit the third one.
 Once the state machine has been found, writing the corresponding method
 adapter is straightforward (the 8 switch cases correspond to the 8 transitions
 in the diagram):
\end_layout

\begin_layout LyX-Code
class RemoveGetFieldPutFieldAdapter extends PatternMethodAdapter {
\end_layout

\begin_layout LyX-Code
  private final static int SEEN_ALOAD_0 = 1;
\end_layout

\begin_layout LyX-Code
  private final static int SEEN_ALOAD_0ALOAD_0 = 2;
\end_layout

\begin_layout LyX-Code
  private final static int SEEN_ALOAD_0ALOAD_0GETFIELD = 3;
\end_layout

\begin_layout LyX-Code
  private String fieldOwner;
\end_layout

\begin_layout LyX-Code
  private String fieldName;
\end_layout

\begin_layout LyX-Code
  private String fieldDesc;
\end_layout

\begin_layout LyX-Code
  public RemoveGetFieldPutFieldAdapter(MethodVisitor mv) {
\end_layout

\begin_layout LyX-Code
    super(mv);
\end_layout

\begin_layout LyX-Code
  }
\end_layout

\begin_layout LyX-Code
  @Override 
\end_layout

\begin_layout LyX-Code
  public void visitVarInsn(int opcode, int var) {
\end_layout

\begin_layout LyX-Code
    switch (state) {
\end_layout

\begin_layout LyX-Code
    case SEEN_NOTHING: // S0 -> S1
\end_layout

\begin_layout LyX-Code
      if (opcode == ALOAD && var == 0) {
\end_layout

\begin_layout LyX-Code
        state = SEEN_ALOAD_0;
\end_layout

\begin_layout LyX-Code
        return;
\end_layout

\begin_layout LyX-Code
      }
\end_layout

\begin_layout LyX-Code
      break;
\end_layout

\begin_layout LyX-Code
    case SEEN_ALOAD_0: // S1 -> S2
\end_layout

\begin_layout LyX-Code
      if (opcode == ALOAD && var == 0) {
\end_layout

\begin_layout LyX-Code
        state = SEEN_ALOAD_0ALOAD_0;
\end_layout

\begin_layout LyX-Code
        return;
\end_layout

\begin_layout LyX-Code
      }
\end_layout

\begin_layout LyX-Code
      break;
\end_layout

\begin_layout LyX-Code
    case SEEN_ALOAD_0ALOAD_0: // S2 -> S2
\end_layout

\begin_layout LyX-Code
      if (opcode == ALOAD && var == 0) {
\end_layout

\begin_layout LyX-Code
        mv.visitVarInsn(ALOAD, 0);
\end_layout

\begin_layout LyX-Code
        return;
\end_layout

\begin_layout LyX-Code
      }
\end_layout

\begin_layout LyX-Code
      break;
\end_layout

\begin_layout LyX-Code
    }
\end_layout

\begin_layout LyX-Code
    visitInsn();
\end_layout

\begin_layout LyX-Code
    mv.visitVarInsn(opcode, var);
\end_layout

\begin_layout LyX-Code
  }
\end_layout

\begin_layout LyX-Code
  @Override
\end_layout

\begin_layout LyX-Code
  public void visitFieldInsn(int opcode, String owner, String name,
\end_layout

\begin_layout LyX-Code
      String desc) {
\end_layout

\begin_layout LyX-Code
    switch (state) {
\end_layout

\begin_layout LyX-Code
    case SEEN_ALOAD_0ALOAD_0: // S2 -> S3
\end_layout

\begin_layout LyX-Code
      if (opcode == GETFIELD) {
\end_layout

\begin_layout LyX-Code
        state = SEEN_ALOAD_0ALOAD_0GETFIELD;
\end_layout

\begin_layout LyX-Code
        fieldOwner = owner;
\end_layout

\begin_layout LyX-Code
        fieldName = name;
\end_layout

\begin_layout LyX-Code
        fieldDesc = desc;
\end_layout

\begin_layout LyX-Code
        return;
\end_layout

\begin_layout LyX-Code
      }
\end_layout

\begin_layout LyX-Code
      break;
\end_layout

\begin_layout LyX-Code
    case SEEN_ALOAD_0ALOAD_0GETFIELD: // S3 -> S0
\end_layout

\begin_layout LyX-Code
      if (opcode == PUTFIELD && name.equals(fieldName)) {
\end_layout

\begin_layout LyX-Code
        state = SEEN_NOTHING;
\end_layout

\begin_layout LyX-Code
        return;
\end_layout

\begin_layout LyX-Code
      }
\end_layout

\begin_layout LyX-Code
      break;
\end_layout

\begin_layout LyX-Code
    }
\end_layout

\begin_layout LyX-Code
    visitInsn();
\end_layout

\begin_layout LyX-Code
    mv.visitFieldInsn(opcode, owner, name, desc);
\end_layout

\begin_layout LyX-Code
  }
\end_layout

\begin_layout LyX-Code
  @Override protected void visitInsn() {
\end_layout

\begin_layout LyX-Code
    switch (state) {
\end_layout

\begin_layout LyX-Code
    case SEEN_ALOAD_0: // S1 -> S0
\end_layout

\begin_layout LyX-Code
      mv.visitVarInsn(ALOAD, 0);
\end_layout

\begin_layout LyX-Code
      break;
\end_layout

\begin_layout LyX-Code
    case SEEN_ALOAD_0ALOAD_0: // S2 -> S0
\end_layout

\begin_layout LyX-Code
      mv.visitVarInsn(ALOAD, 0);
\end_layout

\begin_layout LyX-Code
      mv.visitVarInsn(ALOAD, 0);
\end_layout

\begin_layout LyX-Code
      break;
\end_layout

\begin_layout LyX-Code
    case SEEN_ALOAD_0ALOAD_0GETFIELD: // S3 -> S0
\end_layout

\begin_layout LyX-Code
      mv.visitVarInsn(ALOAD, 0);
\end_layout

\begin_layout LyX-Code
      mv.visitVarInsn(ALOAD, 0);
\end_layout

\begin_layout LyX-Code
      mv.visitFieldInsn(GETFIELD, fieldOwner, fieldName, fieldDesc);
\end_layout

\begin_layout LyX-Code
      break;
\end_layout

\begin_layout LyX-Code
    }
\end_layout

\begin_layout LyX-Code
    state = SEEN_NOTHING;
\end_layout

\begin_layout LyX-Code
  }
\end_layout

\begin_layout LyX-Code
}
\end_layout

\begin_layout Standard
Note that, for the same reasons as in the 
\family typewriter
AddTimerAdapter
\family default
 case in section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Stateless-transformations"

\end_inset

, the statefull transformations presented in this section do not need to
 transform stack map frames
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
frames!updating
\end_layout

\end_inset

: the original frames stay valid after the transformation.
 They don't even need to transform the local variables and operand stack
 size.
 Finally it must be noted that statefull transformations are not limited
 to transformations that detect and transform instruction sequences.
 Many other types of transformation are also statefull.
 This is the case, for instance, of the method adapters presented in the
 next section.
\end_layout

\begin_layout Section
Tools
\begin_inset CommandInset label
LatexCommand label
name "sub:MethodTools"

\end_inset


\end_layout

\begin_layout Standard
The 
\family typewriter
org.objectweb.asm.commons
\family default
 package contains some predefined method adapters that can be useful to
 define your own adapters.
 This section presents three of them and shows how they can be used with
 the 
\family typewriter
AddTimerAdapter
\family default
 example of section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Stateless-transformations"

\end_inset

.
 It also shows how the tools seen in the previous chapter can be used to
 ease method generation or transformation.
\end_layout

\begin_layout Subsection
Basic tools
\end_layout

\begin_layout Standard
The tools presented in section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:ClassTools"

\end_inset

 can also be used for methods.
\end_layout

\begin_layout Subsubsection*

\family typewriter
Type
\end_layout

\begin_layout Standard
Many bytecode instructions, such as 
\emph on
x
\family typewriter
\emph default
LOAD
\family default
, 
\emph on
x
\family typewriter
\emph default
ADD
\family default
 or 
\emph on
x
\family typewriter
\emph default
RETURN
\family default
, depend on the type to which they are applied.
 The 
\family typewriter
Type
\family default

\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
Type@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
texttt{Type}
\end_layout

\end_inset


\end_layout

\end_inset

 class provides a 
\family typewriter
getOpcode
\family default
 method that can be used to get, for these instructions, the opcode correspondin
g to a given type.
 This method takes as parameter an opcode for the 
\family typewriter
int
\family default
 type, and returns the opcode for the type on which it is called.
 For instance 
\family typewriter
t.getOpcode(IMUL)
\family default
 returns 
\family typewriter
FMUL
\family default
 if 
\family typewriter
t
\family default
 is equal to 
\family typewriter
Type.FLOAT_TYPE
\family default
.
\end_layout

\begin_layout Subsubsection*

\family typewriter
TraceClassVisitor
\end_layout

\begin_layout Standard
This class
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
TraceClassVisitor@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
texttt{TraceClassVisitor}
\end_layout

\end_inset


\end_layout

\end_inset

, which has already been presented in the previous chapter, prints a textual
 representation of the classes it visits, 
\emph on
including a textual representation of their methods
\emph default
, in a form very similar to the one used in this chapter.
 It can therefore be used to trace the content of generated or transformed
 methods at any point in a transformation chain.
 For example:
\end_layout

\begin_layout LyX-Code
java -classpath asm.jar:asm-util.jar 
\backslash

\end_layout

\begin_layout LyX-Code
     org.objectweb.asm.util.TraceClassVisitor 
\backslash

\end_layout

\begin_layout LyX-Code
     java.lang.Void
\end_layout

\begin_layout Standard
prints:
\end_layout

\begin_layout LyX-Code
// class version 49.0 (49)
\end_layout

\begin_layout LyX-Code
// access flags 49
\end_layout

\begin_layout LyX-Code
public final class java/lang/Void {
\end_layout

\begin_layout LyX-Code
  // access flags 25
\end_layout

\begin_layout LyX-Code
  // signature Ljava/lang/Class<Ljava/lang/Void;>;
\end_layout

\begin_layout LyX-Code
  // declaration: java.lang.Class<java.lang.Void>
\end_layout

\begin_layout LyX-Code
  public final static Ljava/lang/Class; TYPE
\end_layout

\begin_layout LyX-Code
  // access flags 2
\end_layout

\begin_layout LyX-Code
  private <init>()V
\end_layout

\begin_layout LyX-Code
    ALOAD 0
\end_layout

\begin_layout LyX-Code
    INVOKESPECIAL java/lang/Object.<init> ()V
\end_layout

\begin_layout LyX-Code
    RETURN
\end_layout

\begin_layout LyX-Code
    MAXSTACK = 1
\end_layout

\begin_layout LyX-Code
    MAXLOCALS = 1
\end_layout

\begin_layout LyX-Code
  // access flags 8
\end_layout

\begin_layout LyX-Code
  static <clinit>()V
\end_layout

\begin_layout LyX-Code
    LDC "void"
\end_layout

\begin_layout LyX-Code
    INVOKESTATIC java/lang/Class.getPrimitiveClass (...)...
\end_layout

\begin_layout LyX-Code
    PUTSTATIC java/lang/Void.TYPE : Ljava/lang/Class;
\end_layout

\begin_layout LyX-Code
    RETURN
\end_layout

\begin_layout LyX-Code
    MAXSTACK = 1
\end_layout

\begin_layout LyX-Code
    MAXLOCALS = 0
\end_layout

\begin_layout LyX-Code
}
\end_layout

\begin_layout Standard
This shows how to generate a static block
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
static blocks
\end_layout

\end_inset

 
\family typewriter
static { ...
 }
\family default
, namely with a 
\family typewriter
<clinit>
\family default
 method (for CLass INITializer).
 Note that if you want to trace the content of a single method at some point
 in a chain, instead of tracing all the content of its class, you can use
 
\family typewriter
TraceMethodVisitor
\family default

\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
TraceMethodVisitor@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
texttt{TraceMethodVisitor}
\end_layout

\end_inset


\end_layout

\end_inset

 instead of 
\family typewriter
TraceClassVisitor
\family default
 (in this case you must specify the backend explicitly; here we use a 
\family typewriter
Textifier
\family default
):
\end_layout

\begin_layout LyX-Code

\family typewriter
public MethodVisitor visitMethod(int access, String name,
\end_layout

\begin_layout LyX-Code
 
\family typewriter
   String desc, String signature, String[] exceptions) {
\end_layout

\begin_layout LyX-Code
 
\family typewriter
 MethodVisitor mv = cv.visitMethod(access, name, desc, signature,
\end_layout

\begin_layout LyX-Code
 
\family typewriter
       exceptions);
\end_layout

\begin_layout LyX-Code
 
\family typewriter
 if (
\family default
\shape slanted
debug
\shape default
 && mv != null && ...
\family typewriter
) { // if this method must be traced
\end_layout

\begin_layout LyX-Code
    Printer p = new Textifier(ASM4) {
\end_layout

\begin_layout LyX-Code
      @Override 
\family typewriter
public void visitMethodEnd() {
\end_layout

\begin_layout LyX-Code
 
\family typewriter
       print(
\family default
\shape slanted
aPrintWriter
\family typewriter
\shape default
); // print it after it has been visited 
\end_layout

\begin_layout LyX-Code
 
\family typewriter
     }
\end_layout

\begin_layout LyX-Code

\family typewriter
    };
\end_layout

\begin_layout LyX-Code

\family typewriter
    mv = new TraceMethodVisitor(mv, p);
\end_layout

\begin_layout LyX-Code
  }
\end_layout

\begin_layout LyX-Code
  return new 
\shape slanted
MyMethodAdapter
\shape default
(mv);
\end_layout

\begin_layout LyX-Code

\family typewriter
}
\end_layout

\begin_layout Standard
This code prints the method after transformation by 
\family typewriter
MyMethodAdapter
\family default
.
\end_layout

\begin_layout Subsubsection*

\family typewriter
CheckClassAdapter
\end_layout

\begin_layout Standard
This class
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
CheckClassAdapter@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
texttt{CheckClassAdapter}
\end_layout

\end_inset


\end_layout

\end_inset

, which has already been presented in the previous chapter, checks that
 the 
\family typewriter
ClassVisitor
\family default
 methods are called in the appropriate order, and with valid arguments,
 and it does the same for the 
\family typewriter
MethodVisitor
\family default
 methods.
 It can therefore be used to check that the 
\family typewriter
MethodVisitor
\family default
 API is correctly used at any point in a transformation chain.
 Like with 
\family typewriter
TraceMethodVisitor
\family default
, you can use the 
\family typewriter
CheckMethodAdapter
\family default

\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
CheckMethodAdapter@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
texttt{CheckMethodAdapter}
\end_layout

\end_inset


\end_layout

\end_inset

 class to check a single method instead of checking all its class:
\end_layout

\begin_layout LyX-Code

\family typewriter
public MethodVisitor visitMethod(int access, String name,
\end_layout

\begin_layout LyX-Code
 
\family typewriter
   String desc, String signature, String[] exceptions) {
\end_layout

\begin_layout LyX-Code
 
\family typewriter
 MethodVisitor mv = cv.visitMethod(access, name, desc, signature,
\end_layout

\begin_layout LyX-Code
 
\family typewriter
       exceptions);
\end_layout

\begin_layout LyX-Code
 
\family typewriter
 if (
\family default
\shape slanted
debug
\shape default
 && mv != null && ...
\family typewriter
) { // if this method must be checked
\end_layout

\begin_layout LyX-Code
 
\family typewriter
   mv = new CheckMethodAdapter(mv);
\end_layout

\begin_layout LyX-Code
  }
\end_layout

\begin_layout LyX-Code
  return new 
\shape slanted
MyMethodAdapter
\shape default
(mv);
\end_layout

\begin_layout LyX-Code

\family typewriter
}
\end_layout

\begin_layout Standard
This code checks that 
\family typewriter
MyMethodAdapter
\family default
 uses the 
\family typewriter
MethodVisitor
\family default
 API correctly.
 Note however that this adapter will 
\emph on
not
\emph default
 check that the bytecode is correct: for instance it will not detect that
 
\family typewriter
ISTORE
\family default
 
\family typewriter
1
\family default
 
\family typewriter
ALOAD
\family default
 
\family typewriter
1
\family default
 is invalid.
 In fact this kind of error 
\emph on
can
\emph default
 be detected, if you use the other constructor of 
\family typewriter
CheckMethodAdapter
\family default
 (see the Javadoc), and if you provide valid 
\family typewriter
maxStack
\family default
 and 
\family typewriter
maxLocals
\family default
 arguments in 
\family typewriter
visitMaxs
\family default
.
\end_layout

\begin_layout Subsubsection*

\family typewriter
ASMifier
\end_layout

\begin_layout Standard
This class
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
ASMifier@
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{ASMifier}
\end_layout

\end_inset


\end_layout

\end_inset

, which has already been presented in the previous chapter, also works with
 the content of methods.
 It can be used to know how to generate some compiled code with ASM: just
 write the corresponding source code in Java, compile it with 
\family typewriter
javac
\family default
, and use the 
\family typewriter
ASMifier
\family default
 to visit this class.
 You will get the ASM code to generate the bytecode corresponding to your
 source code.
\end_layout

\begin_layout Subsection

\family typewriter
AnalyzerAdapter
\family default

\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
AnalyzerAdapter@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
texttt{AnalyzerAdapter}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
This method adapter computes the stack map frames before each instruction,
 based on the frames visited in 
\family typewriter
visitFrame
\family default
.
 Indeed, as explained in section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Frames"

\end_inset

, 
\family typewriter
visitFrame
\family default
 is only called before some specific instructions in a method, in order
 to save space, and because 
\begin_inset Quotes eld
\end_inset

the other frames can be easily and quickly inferred from these ones
\begin_inset Quotes erd
\end_inset

.
 This is what this adapter does.
 Of course it only works on classes that contain precomputed stack map frames,
 i.e.
 compiled with Java 6 or higher (or previously upgraded to Java 6 with an
 ASM adapter using the 
\family typewriter
COMPUTE_FRAMES
\family default
 option).
\end_layout

\begin_layout Standard
In the case of our 
\family typewriter
AddTimerAdapter
\family default
 example, this adapter could be used to get the size of the operand stack
 just before the 
\family typewriter
RETURN
\family default
 instructions, thereby allowing to compute an optimal transformed value
 for 
\family typewriter
maxStack
\family default
 in 
\family typewriter
visitMaxs
\family default
 (in fact this method is not recommended in practice, because it is much
 less efficient than using 
\family typewriter
COMPUTE_MAXS
\family default
):
\end_layout

\begin_layout LyX-Code
class AddTimerMethodAdapter2 
\series bold
extends AnalyzerAdapter
\series default
 {
\end_layout

\begin_layout LyX-Code
  
\series bold
private int maxStack;
\end_layout

\begin_layout LyX-Code
  public AddTimerMethodAdapter2(String owner, int access,
\end_layout

\begin_layout LyX-Code
      String name, String desc, MethodVisitor mv) {
\end_layout

\begin_layout LyX-Code
    super(ASM4, owner, access, name, desc, mv);
\end_layout

\begin_layout LyX-Code
  }
\end_layout

\begin_layout LyX-Code
  @Override public void visitCode() {
\end_layout

\begin_layout LyX-Code
    
\series bold
super
\series default
.visitCode();
\end_layout

\begin_layout LyX-Code
    mv.visitFieldInsn(GETSTATIC, owner, "timer", "J");
\end_layout

\begin_layout LyX-Code
    mv.visitMethodInsn(INVOKESTATIC, "java/lang/System",
\end_layout

\begin_layout LyX-Code
        "currentTimeMillis", "()J");
\end_layout

\begin_layout LyX-Code
    mv.visitInsn(LSUB);
\end_layout

\begin_layout LyX-Code
    mv.visitFieldInsn(PUTSTATIC, owner, "timer", "J");
\end_layout

\begin_layout LyX-Code
    
\series bold
maxStack = 4;
\end_layout

\begin_layout LyX-Code
  }
\end_layout

\begin_layout LyX-Code
  @Override public void visitInsn(int opcode) {
\end_layout

\begin_layout LyX-Code
    if ((opcode >= IRETURN && opcode <= RETURN) || opcode == ATHROW) {
\end_layout

\begin_layout LyX-Code
      mv.visitFieldInsn(GETSTATIC, owner, "timer", "J");
\end_layout

\begin_layout LyX-Code
      mv.visitMethodInsn(INVOKESTATIC, "java/lang/System",
\end_layout

\begin_layout LyX-Code
          "currentTimeMillis", "()J");
\end_layout

\begin_layout LyX-Code
      mv.visitInsn(LADD);
\end_layout

\begin_layout LyX-Code
      mv.visitFieldInsn(PUTSTATIC, owner, "timer", "J");
\end_layout

\begin_layout LyX-Code
      
\series bold
maxStack = Math.max(maxStack, stack.size() + 4);
\end_layout

\begin_layout LyX-Code
    }
\end_layout

\begin_layout LyX-Code
    
\series bold
super
\series default
.visitInsn(opcode);
\end_layout

\begin_layout LyX-Code
  }
\end_layout

\begin_layout LyX-Code
  @Override public void visitMaxs(int maxStack, int maxLocals) {
\end_layout

\begin_layout LyX-Code
    
\series bold
super
\series default
.visitMaxs(
\series bold
Math.max(this.maxStack, maxStack)
\series default
, maxLocals);
\end_layout

\begin_layout LyX-Code
  }
\end_layout

\begin_layout LyX-Code
}
\end_layout

\begin_layout Standard
The 
\family typewriter
stack
\family default
 field is defined in the 
\family typewriter
AnalyzerAdapter
\family default
 class, and contains the types in operand stack.
 More precisely, in a 
\family typewriter
visit
\emph on
Xxx
\emph default
Insn
\family default
, and before the overridden method is called, this list contains the state
 of the operand stack just before this instruction.
 Note that the overridden methods 
\emph on
must
\emph default
 be called so that the 
\family typewriter
stack
\family default
 field is correctly updated (hence the use of 
\family typewriter
super
\family default
 instead of 
\family typewriter
mv
\family default
 in the original code).
\end_layout

\begin_layout Standard
Alternatively the new instructions can be inserted by calling the methods
 of the super class: the effect is that the frames for these instructions
 will be computed by 
\family typewriter
AnalyzerAdapter
\family default
.
 Since, in addition, this adapter updates the arguments of 
\family typewriter
visitMaxs
\family default
 based on the frames it computes, we do not need to update them ourselves:
\end_layout

\begin_layout LyX-Code
class AddTimerMethodAdapter3 extends AnalyzerAdapter {
\end_layout

\begin_layout LyX-Code
  public AddTimerMethodAdapter3(String owner, int access,
\end_layout

\begin_layout LyX-Code
      String name, String desc, MethodVisitor mv) {
\end_layout

\begin_layout LyX-Code
    super(ASM4, owner, access, name, desc, mv);
\end_layout

\begin_layout LyX-Code
  }
\end_layout

\begin_layout LyX-Code
  @Override public void visitCode() {
\end_layout

\begin_layout LyX-Code
    super.visitCode();
\end_layout

\begin_layout LyX-Code
    
\series bold
super
\series default
.visitFieldInsn(GETSTATIC, owner, "timer", "J");
\end_layout

\begin_layout LyX-Code
    
\series bold
super
\series default
.visitMethodInsn(INVOKESTATIC, "java/lang/System",
\end_layout

\begin_layout LyX-Code
        "currentTimeMillis", "()J");
\end_layout

\begin_layout LyX-Code
    
\series bold
super
\series default
.visitInsn(LSUB);
\end_layout

\begin_layout LyX-Code
    
\series bold
super
\series default
.visitFieldInsn(PUTSTATIC, owner, "timer", "J");
\end_layout

\begin_layout LyX-Code
  }
\end_layout

\begin_layout LyX-Code
  @Override public void visitInsn(int opcode) {
\end_layout

\begin_layout LyX-Code
    if ((opcode >= IRETURN && opcode <= RETURN) || opcode == ATHROW) {
\end_layout

\begin_layout LyX-Code
      
\series bold
super
\series default
.visitFieldInsn(GETSTATIC, owner, "timer", "J");
\end_layout

\begin_layout LyX-Code
      
\series bold
super
\series default
.visitMethodInsn(INVOKESTATIC, "java/lang/System",
\end_layout

\begin_layout LyX-Code
          "currentTimeMillis", "()J");
\end_layout

\begin_layout LyX-Code
      
\series bold
super
\series default
.visitInsn(LADD);
\end_layout

\begin_layout LyX-Code
      
\series bold
super
\series default
.visitFieldInsn(PUTSTATIC, owner, "timer", "J");
\end_layout

\begin_layout LyX-Code
    }
\end_layout

\begin_layout LyX-Code
    super.visitInsn(opcode);
\end_layout

\begin_layout LyX-Code
  }
\end_layout

\begin_layout LyX-Code
}
\end_layout

\begin_layout Subsection

\family typewriter
LocalVariablesSorter
\family default

\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
LocalVariablesSorter@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
texttt{LocalVariablesSorter}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
This method adapter renumbers
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
local variables!renumbering
\end_layout

\end_inset

 the local variables used in a method in the order they appear in this method.
 For instance in a method with two parameters, the first local variable
 read or written whose index is greater than or equal to 3 -- the first
 three local variables correspond to this and to the two method parameters,
 and can therefore not be changed -- is assigned index 3, the second one
 is assigned index 4, and so on.
 This adapter is useful to insert
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
local variables!inserting
\end_layout

\end_inset

 new local variables in a method.
 Without this adapter it would be necessary to add new local variables after
 all the existing ones, but unfortunately their number is not known until
 the end of the method, in 
\family typewriter
visitMaxs
\family default
.
\end_layout

\begin_layout Standard
In order to show how this adapter can be used, let's suppose that we want
 to use a local variable to implement 
\family typewriter
AddTimerAdapter
\family default
:
\end_layout

\begin_layout LyX-Code
public class C {
\end_layout

\begin_layout LyX-Code
  
\series bold
public static long timer;
\end_layout

\begin_layout LyX-Code
  public void m() throws Exception {
\end_layout

\begin_layout LyX-Code
    
\series bold
long t = System.currentTimeMillis();
\end_layout

\begin_layout LyX-Code
    Thread.sleep(100);
\end_layout

\begin_layout LyX-Code
    
\series bold
timer += System.currentTimeMillis() - t;
\end_layout

\begin_layout LyX-Code
  }
\end_layout

\begin_layout LyX-Code
}
\end_layout

\begin_layout Standard
This can be done easily by extending 
\family typewriter
LocalVariablesSorter
\family default
, and by using the 
\family typewriter
newLocal
\family default
 method defined in this class:
\end_layout

\begin_layout LyX-Code
class AddTimerMethodAdapter4 
\series bold
extends LocalVariablesSorter
\series default
 {
\end_layout

\begin_layout LyX-Code
  
\series bold
private int time;
\end_layout

\begin_layout LyX-Code
  public AddTimerMethodAdapter4(int access, String desc,
\end_layout

\begin_layout LyX-Code
      MethodVisitor mv) {
\end_layout

\begin_layout LyX-Code
    super(ASM4, access, desc, mv);
\end_layout

\begin_layout LyX-Code
  }
\end_layout

\begin_layout LyX-Code
  @Override public void visitCode() {
\end_layout

\begin_layout LyX-Code
    super.visitCode();
\end_layout

\begin_layout LyX-Code
    mv.visitMethodInsn(INVOKESTATIC, "java/lang/System",
\end_layout

\begin_layout LyX-Code
        "currentTimeMillis", "()J");
\end_layout

\begin_layout LyX-Code
    
\series bold
time = newLocal(Type.LONG_TYPE);
\end_layout

\begin_layout LyX-Code
    mv.visitVarInsn(LSTORE, 
\series bold
time
\series default
);
\end_layout

\begin_layout LyX-Code
  }
\end_layout

\begin_layout LyX-Code
  @Override public void visitInsn(int opcode) {
\end_layout

\begin_layout LyX-Code
    if ((opcode >= IRETURN && opcode <= RETURN) || opcode == ATHROW) {
\end_layout

\begin_layout LyX-Code
      mv.visitMethodInsn(INVOKESTATIC, "java/lang/System",
\end_layout

\begin_layout LyX-Code
          "currentTimeMillis", "()J");
\end_layout

\begin_layout LyX-Code
      mv.visitVarInsn(LLOAD, 
\series bold
time
\series default
);
\end_layout

\begin_layout LyX-Code
      mv.visitInsn(LSUB);
\end_layout

\begin_layout LyX-Code
      mv.visitFieldInsn(GETSTATIC, owner, "timer", "J");
\end_layout

\begin_layout LyX-Code
      mv.visitInsn(LADD);
\end_layout

\begin_layout LyX-Code
      mv.visitFieldInsn(PUTSTATIC, owner, "timer", "J");
\end_layout

\begin_layout LyX-Code
    }
\end_layout

\begin_layout LyX-Code
    super.visitInsn(opcode);
\end_layout

\begin_layout LyX-Code
  }
\end_layout

\begin_layout LyX-Code
  @Override public void visitMaxs(int maxStack, int maxLocals) {
\end_layout

\begin_layout LyX-Code
    super.visitMaxs(maxStack + 4, maxLocals);
\end_layout

\begin_layout LyX-Code
  }
\end_layout

\begin_layout LyX-Code
}
\end_layout

\begin_layout Standard
Note that the original frames associated to the method become invalid when
 the local variables are renumbered, and a fortiori when new local variables
 are inserted.
 Hopefully it is possible to avoid recomputing these frames from scratch:
 indeed no frames must be added or removed, and it 
\begin_inset Quotes eld
\end_inset

suffices
\begin_inset Quotes erd
\end_inset

 to reorder the content of local variables in the original frames to get
 the frames of the transformed method.
 
\family typewriter
LocalVariablesSorter
\family default
 takes care of that automatically.
 If you also need to do incremental stack map frame updates
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
frames!updating
\end_layout

\end_inset

 for one of your method adapters, you can inspire yourself from the source
 of this class.
\end_layout

\begin_layout Standard
As you can see above using a local variable does not solve the problem we
 had in the original version of this class, concerning the worst case value
 for 
\family typewriter
maxStack
\family default
.
 If you want to use an 
\family typewriter
AnalyzerAdapter
\family default
 to solve that, in addition to a 
\family typewriter
LocalVariablesSorter
\family default
, you must use these adapters through delegation instead of via inheritance
 (since multiple inheritance is not possible):
\end_layout

\begin_layout LyX-Code
class AddTimerMethodAdapter5 
\series bold
extends MethodVisitor
\series default
 {
\end_layout

\begin_layout LyX-Code
  
\series bold
public LocalVariablesSorter lvs;
\end_layout

\begin_layout LyX-Code
 
\series bold
 public AnalyzerAdapter aa;
\end_layout

\begin_layout LyX-Code
 
\series bold
 private int time;
\end_layout

\begin_layout LyX-Code
 
\series bold
 private int maxStack;
\end_layout

\begin_layout LyX-Code
  public AddTimerMethodAdapter5(MethodVisitor mv) {
\end_layout

\begin_layout LyX-Code
    super(ASM4, mv);
\end_layout

\begin_layout LyX-Code
  }
\end_layout

\begin_layout LyX-Code
  @Override public void visitCode() {
\end_layout

\begin_layout LyX-Code
    mv.visitCode();
\end_layout

\begin_layout LyX-Code
    mv.visitMethodInsn(INVOKESTATIC, "java/lang/System",
\end_layout

\begin_layout LyX-Code
        "currentTimeMillis", "()J");
\end_layout

\begin_layout LyX-Code
    
\series bold
time = lvs.newLocal(Type.LONG_TYPE);
\end_layout

\begin_layout LyX-Code
    mv.visitVarInsn(LSTORE, 
\series bold
time
\series default
);
\end_layout

\begin_layout LyX-Code
    
\series bold
maxStack = 4;
\end_layout

\begin_layout LyX-Code
  }
\end_layout

\begin_layout LyX-Code
  @Override public void visitInsn(int opcode) {
\end_layout

\begin_layout LyX-Code
    if ((opcode >= IRETURN && opcode <= RETURN) || opcode == ATHROW) {
\end_layout

\begin_layout LyX-Code
      mv.visitMethodInsn(INVOKESTATIC, "java/lang/System",
\end_layout

\begin_layout LyX-Code
          "currentTimeMillis", "()J");
\end_layout

\begin_layout LyX-Code
      mv.visitVarInsn(LLOAD, 
\series bold
time
\series default
);
\end_layout

\begin_layout LyX-Code
      mv.visitInsn(LSUB);
\end_layout

\begin_layout LyX-Code
      mv.visitFieldInsn(GETSTATIC, owner, "timer", "J");
\end_layout

\begin_layout LyX-Code
      mv.visitInsn(LADD);
\end_layout

\begin_layout LyX-Code
      mv.visitFieldInsn(PUTSTATIC, owner, "timer", "J");
\end_layout

\begin_layout LyX-Code
      
\series bold
maxStack = Math.max(aa.stack.size() + 4, maxStack);
\end_layout

\begin_layout LyX-Code
    }
\end_layout

\begin_layout LyX-Code
    mv.visitInsn(opcode);
\end_layout

\begin_layout LyX-Code
  }
\end_layout

\begin_layout LyX-Code
  @Override public void visitMaxs(int maxStack, int maxLocals) {
\end_layout

\begin_layout LyX-Code
    mv.visitMaxs(
\series bold
Math.max(this.maxStack, maxStack)
\series default
, maxLocals);
\end_layout

\begin_layout LyX-Code
  }
\end_layout

\begin_layout LyX-Code
}
\end_layout

\begin_layout Standard
In order to use this adapter you must chain a 
\family typewriter
LocalVariablesSorter
\family default
 to an 
\family typewriter
AnalyzerAdapter
\family default
, itself chained to your adapter: the first adapter will sort local variables
 and update frames accordingly, the analyzer adapter will compute intermediate
 frames taking into account the renumbering done in the previous adapter,
 and your adapter will have access to these renumbered intermediate frames.
 This chain can be constructed as follows in 
\family typewriter
visitMethod
\family default
:
\end_layout

\begin_layout LyX-Code
mv = cv.visitMethod(access, name, desc, signature, exceptions);
\end_layout

\begin_layout LyX-Code
if (!isInterface && mv != null && !name.equals("<init>")) {
\end_layout

\begin_layout LyX-Code
   AddTimerMethodAdapter5 at = new AddTimerMethodAdapter5(mv);
\end_layout

\begin_layout LyX-Code
   at.aa = new AnalyzerAdapter(owner, access, name, desc, at);
\end_layout

\begin_layout LyX-Code
   at.lvs = new LocalVariablesSorter(access, desc, at.aa);
\end_layout

\begin_layout LyX-Code
   return at.lvs;
\end_layout

\begin_layout LyX-Code
}
\end_layout

\begin_layout Subsection

\family typewriter
AdviceAdapter
\family default

\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
AdviceAdapter@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
texttt{AdviceAdapter}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
This method adapter is an abstract class that can be used to insert code
 at the beginning of a method and just before any 
\family typewriter
RETURN
\family default
 or 
\family typewriter
ATHROW
\family default
 instruction.
 Its main advantage is that it also works for constructors
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
constructors
\end_layout

\end_inset

, where code must not be inserted just at the beginning of the constructor,
 but after the call to the super constructor.
 In fact most of the code of this adapter is dedicated to the detection
 of this super constructor call.
\end_layout

\begin_layout Standard
If you look carefully at the 
\family typewriter
AddTimerAdapter
\family default
 class in section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Stateless-transformations"

\end_inset

, you will see that the 
\family typewriter
AddTimerMethodAdapter
\family default
 is not used for constructors, because of this problem.
 By inheriting from 
\family typewriter
AdviceAdapter
\family default
 this method adapter can be improved to work on constructors too (note that
 
\family typewriter
AdviceAdapter
\family default
 inherits from 
\family typewriter
LocalVariablesSorter
\family default
, so we could also easily use a local variable):
\end_layout

\begin_layout LyX-Code
class AddTimerMethodAdapter6 
\series bold
extends AdviceAdapter
\series default
 {
\end_layout

\begin_layout LyX-Code
  public AddTimerMethodAdapter6(int access, String name, String desc,
\end_layout

\begin_layout LyX-Code
      MethodVisitor mv) {
\end_layout

\begin_layout LyX-Code
    super(ASM4, mv, access, name, desc);
\end_layout

\begin_layout LyX-Code
  }
\end_layout

\begin_layout LyX-Code
  @Override protected void 
\series bold
onMethodEnter
\series default
() {
\end_layout

\begin_layout LyX-Code
    mv.visitFieldInsn(GETSTATIC, owner, "timer", "J");
\end_layout

\begin_layout LyX-Code
    mv.visitMethodInsn(INVOKESTATIC, "java/lang/System",
\end_layout

\begin_layout LyX-Code
        "currentTimeMillis", "()J");
\end_layout

\begin_layout LyX-Code
    mv.visitInsn(LSUB);
\end_layout

\begin_layout LyX-Code
    mv.visitFieldInsn(PUTSTATIC, owner, "timer", "J");
\end_layout

\begin_layout LyX-Code
  }
\end_layout

\begin_layout LyX-Code
  @Override protected void 
\series bold
onMethodExit
\series default
(int opcode) {
\end_layout

\begin_layout LyX-Code
    mv.visitFieldInsn(GETSTATIC, owner, "timer", "J");
\end_layout

\begin_layout LyX-Code
    mv.visitMethodInsn(INVOKESTATIC, "java/lang/System",
\end_layout

\begin_layout LyX-Code
        "currentTimeMillis", "()J");
\end_layout

\begin_layout LyX-Code
    mv.visitInsn(LADD);
\end_layout

\begin_layout LyX-Code
    mv.visitFieldInsn(PUTSTATIC, owner, "timer", "J");
\end_layout

\begin_layout LyX-Code
  }
\end_layout

\begin_layout LyX-Code
  @Override public void visitMaxs(int maxStack, int maxLocals) {
\end_layout

\begin_layout LyX-Code
    super.visitMaxs(maxStack + 4, maxLocals);
\end_layout

\begin_layout LyX-Code
  }
\end_layout

\begin_layout LyX-Code
}
\end_layout

\begin_layout Chapter
Metadata
\begin_inset CommandInset label
LatexCommand label
name "cha:Metadata"

\end_inset


\end_layout

\begin_layout Standard
This chapter explains how to generate and transform compiled Java classes
 metadata, such as annotations, with the core API.
 Each section starts with a presentation of one type of metadata, and then
 presents the corresponding ASM interfaces, components and tools to generate
 and transform these metadata, with some illustrative examples.
\end_layout

\begin_layout Section
Generics
\begin_inset CommandInset label
LatexCommand label
name "sec:Generics"

\end_inset


\end_layout

\begin_layout Standard
Generic classes
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
generic classes
\end_layout

\end_inset

 such as 
\family typewriter
List<E>
\family default
, and classes using them, contain information about the generic types they
 declare or use.
 This information is not used at runtime by the bytecode instructions, but
 it can be accessed via the reflection API.
 It is also used by compilers, for separate compilation.
\end_layout

\begin_layout Subsection
Structure
\end_layout

\begin_layout Standard
For backward compatibility reasons the information about generic types is
 not stored in type or method descriptors (which were defined long before
 the introduction of generics in Java 5), but in similar constructs called
 type, method and class 
\emph on
signatures
\emph default

\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
signature
\end_layout

\end_inset

.
 These signatures are stored in addition to descriptors in class, field
 and method 
\emph on
declarations
\emph default
 when a generic type is involved (generic types do not affect the bytecode
 of methods: the compiler uses them to perform static type checks, but then
 compiles methods as if they were not used, by reintroducing type casts
 where necessary).
\end_layout

\begin_layout Standard
Unlike type and method descriptors, and due to the recursive nature of generic
 types (a generic type can be parameterized by a generic type -- consider
 for example 
\family typewriter
List<List<E>>
\family default
) the grammar of type signatures is quite complex.
 It is given by the following rules (see the Java Virtual Machine Specification
 for a complete description of these rules):
\end_layout

\begin_layout Quote

\size small
\emph on
TypeSignature
\emph default
: 
\family typewriter
\series bold
Z
\family default
\series default
 
\series bold
|
\series default
 
\family typewriter
\series bold
C
\family default
\series default
 
\series bold
|
\series default
 
\family typewriter
\series bold
B
\family default
\series default
 
\series bold
|
\series default
 
\family typewriter
\series bold
S
\family default
\series default
 
\series bold
|
\series default
 
\family typewriter
\series bold
I
\family default
\series default
 
\series bold
|
\series default
 
\family typewriter
\series bold
F
\family default
\series default
 
\series bold
|
\series default
 
\family typewriter
\series bold
J
\family default
\series default
 
\series bold
|
\series default
 
\family typewriter
\series bold
D
\family default
\series default
 | 
\emph on
FieldTypeSignature
\end_layout

\begin_layout Quote

\size small
\emph on
FieldTypeSignature
\emph default
: 
\emph on
ClassTypeSignature
\emph default
 | 
\family typewriter
\series bold
[
\family default
\series default
 
\emph on
TypeSignature
\emph default
 | 
\emph on
TypeVar
\end_layout

\begin_layout Quote

\size small
\emph on
ClassTypeSignature
\emph default
: 
\family typewriter
\series bold
L
\family default
\series default
 
\emph on
Id
\emph default
 ( 
\family typewriter
\series bold
/
\family default
\series default
 
\emph on
Id
\emph default
 )* 
\emph on
TypeArgs
\emph default
? ( 
\family typewriter
\series bold
.

\family default
\series default
 
\emph on
Id
\emph default
 
\emph on
TypeArgs
\emph default
? )* 
\family typewriter
\series bold
;
\end_layout

\begin_layout Quote

\size small
\emph on
TypeArgs
\emph default
: 
\family typewriter
\series bold
<
\family default
\series default
 
\emph on
TypeArg
\emph default
+ 
\family typewriter
\series bold
>
\end_layout

\begin_layout Quote

\size small
\emph on
TypeArg
\emph default
: 
\family typewriter
\series bold
*
\family default
\series default
 | ( 
\family typewriter
\series bold
+
\family default
\series default
 | 
\family typewriter
\series bold
-
\family default
\series default
 )? 
\emph on
FieldTypeSignature
\end_layout

\begin_layout Quote

\size small
\emph on
TypeVar
\emph default
: 
\family typewriter
\series bold
T
\family default
\series default
 
\emph on
Id
\emph default
 
\family typewriter
\series bold
;
\end_layout

\begin_layout Standard
The first rule says that a 
\emph on
type signature
\emph default

\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
type signature
\end_layout

\end_inset

 is either a primitive type descriptor or a field type signature.
 The second rule defines a field type signature as a class type signature,
 an array type signature, or a type variable.
 The third rule defines class type signatures: they are class type descriptors
 with possible type arguments, between angle brackets, after the main class
 name or after the inner class names (prefixed with dots).
 The remaining rules define type arguments and type variables.
 Note that a type argument can be a complete field type signature, with
 its own type arguments: type signatures can therefore be very complex (see
 Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Sample-type-signatures"

\end_inset

).
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="13" columns="2">
<features tabularvalignment="middle">
<column alignment="left" valignment="top" width="0">
<column alignment="left" valignment="top" width="0">
<row>
<cell multicolumn="1" alignment="left" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Java type and corresponding type signature
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell multicolumn="1" alignment="left" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
List<E>
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
Ljava/util/List<TE;>;
\end_layout

\end_inset
</cell>
</row>
<row>
<cell multicolumn="1" alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
List<?>
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
Ljava/util/List<*>;
\end_layout

\end_inset
</cell>
</row>
<row>
<cell multicolumn="1" alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
List<? extends Number>
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
Ljava/util/List<+Ljava/lang/Number;>;
\end_layout

\end_inset
</cell>
</row>
<row>
<cell multicolumn="1" alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
List<? super Integer>
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
Ljava/util/List<-Ljava/lang/Integer;>;
\end_layout

\end_inset
</cell>
</row>
<row>
<cell multicolumn="1" alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
List<List<String>[]>
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset space ~
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
Ljava/util/List<[Ljava/util/List<Ljava/lang/String;>;>;
\end_layout

\end_inset
</cell>
</row>
<row>
<cell multicolumn="1" alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
HashMap<K, V>.HashIterator<K>
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
Ljava/util/HashMap<TK;TV;>.HashIterator<TK;>;
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Sample-type-signatures"

\end_inset

Sample type signatures
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Method signatures extend method descriptors like type signatures extend
 type descriptors.
 A 
\emph on
method signature
\emph default

\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
method signature
\end_layout

\end_inset

 describes the type signatures of the method parameters and the signature
 of its return type.
 Unlike method descriptors, it also contains the signatures of the exceptions
 thrown by the method, preceded by 
\family typewriter
^
\family default
, and can also contain optional formal type parameters between angle brackets:
\end_layout

\begin_layout Quote

\size small
\emph on
MethodTypeSignature
\emph default
:
\emph on

\begin_inset Newline newline
\end_inset


\size default
\emph default

\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
verb!  !
\end_layout

\end_inset


\size small
\emph on
TypeParams
\emph default
? 
\family typewriter
\series bold
(
\family default
\series default
 
\emph on
TypeSignature
\emph default
* 
\family typewriter
\series bold
)
\family default
\series default
 ( 
\emph on
TypeSignature
\emph default
 | 
\family typewriter
\series bold
V
\family default
\series default
 ) 
\emph on
Exception
\emph default
*
\end_layout

\begin_layout Quote

\size small
\emph on
Exception:
\emph default
 
\family typewriter
\series bold
^
\family default
\series default
\emph on
ClassTypeSignature
\emph default
 | 
\family typewriter
\series bold
^
\family default
\series default
\emph on
TypeVar
\end_layout

\begin_layout Quote

\size small
\emph on
TypeParams
\emph default
: 
\family typewriter
\series bold
<
\family default
\series default
 
\emph on
TypeParam
\emph default
+ 
\family typewriter
\series bold
>
\end_layout

\begin_layout Quote

\size small
\emph on
TypeParam
\emph default
: 
\emph on
Id
\emph default
 
\family typewriter
\series bold
:
\family default
\series default
 
\emph on
FieldTypeSignature
\emph default
? ( 
\family typewriter
\series bold
:
\family default
\series default
 
\emph on
FieldTypeSignature
\emph default
 )*
\end_layout

\begin_layout Standard
For example the method signature of the following generic static method,
 parameterized by the type variable 
\family typewriter
T
\family default
:
\end_layout

\begin_layout Quote

\family typewriter
static <T> Class<? extends T> m (int n)
\end_layout

\begin_layout Standard
is the following method signature:
\end_layout

\begin_layout Quote

\family typewriter
<T:Ljava/lang/Object;>(I)Ljava/lang/Class<+TT;>;
\end_layout

\begin_layout Standard
Finally a 
\emph on
class signature
\emph default

\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
class signature
\end_layout

\end_inset

, which must not be confused with a class type signature, is defined as
 the type signature of its super class, followed by the type signatures
 of the implemented interfaces, and with optional formal type parameters:
\end_layout

\begin_layout Quote

\size small
\emph on
ClassSignature
\emph default
: 
\emph on
TypeParams
\emph default
? 
\emph on
ClassTypeSignature
\emph default
 
\emph on
ClassTypeSignature
\emph default
*
\end_layout

\begin_layout Standard
For example the class signature of a class declared as 
\family typewriter
C<E> extends List<E>
\family default
 is 
\family typewriter
<E:Ljava/lang/Object;>Ljava/util/List<TE;>;
\family default
.
\end_layout

\begin_layout Subsection
Interfaces and components
\end_layout

\begin_layout Standard
Like for descriptors, and for the same efficiency reasons (see section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Type"

\end_inset

), the ASM API exposes signatures as they as stored in compiled classes
 (the main occurences of signatures are in the 
\family typewriter
visit
\family default
, 
\family typewriter
visitField
\family default
 and 
\family typewriter
visitMethod
\family default
 methods of the 
\family typewriter
ClassVisitor
\family default
 class, as an optional class, type or method signature argument respectively).
 Hopefully it also provides some tools to generate and transform signatures,
 in the 
\family typewriter
org.objectweb.asm.signature
\family default
 package, based on the 
\family typewriter
SignatureVisitor
\family default
 abstract class (see Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:The-SignatureVisitor-interface"

\end_inset

).
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status collapsed

\begin_layout LyX-Code
public abstract class 
\series bold
SignatureVisitor
\series default
 {
\end_layout

\begin_layout LyX-Code
  public final static char EXTENDS = '+';
\end_layout

\begin_layout LyX-Code
  public final static char SUPER = '-';
\end_layout

\begin_layout LyX-Code
  public final static char INSTANCEOF = '=';
\end_layout

\begin_layout LyX-Code
  public SignatureVisitor(int api);
\end_layout

\begin_layout LyX-Code
  public void visitFormalTypeParameter(String name);
\end_layout

\begin_layout LyX-Code
  public SignatureVisitor visitClassBound();
\end_layout

\begin_layout LyX-Code
  public SignatureVisitor visitInterfaceBound();
\end_layout

\begin_layout LyX-Code
  public SignatureVisitor visitSuperclass();
\end_layout

\begin_layout LyX-Code
  public SignatureVisitor visitInterface();
\end_layout

\begin_layout LyX-Code
  public SignatureVisitor visitParameterType();
\end_layout

\begin_layout LyX-Code
  public SignatureVisitor visitReturnType();
\end_layout

\begin_layout LyX-Code
  public SignatureVisitor visitExceptionType();
\end_layout

\begin_layout LyX-Code
  public void 
\series bold
visitBaseType
\series default
(char descriptor);
\end_layout

\begin_layout LyX-Code
  public void 
\series bold
visitTypeVariable
\series default
(String name);
\end_layout

\begin_layout LyX-Code
  public SignatureVisitor 
\series bold
visitArrayType
\series default
();
\end_layout

\begin_layout LyX-Code
  public void 
\series bold
visitClassType
\series default
(String name);
\end_layout

\begin_layout LyX-Code
  public void 
\series bold
visitInnerClassType
\series default
(String name);
\end_layout

\begin_layout LyX-Code
  public void 
\series bold
visitTypeArgument
\series default
();
\end_layout

\begin_layout LyX-Code
  public SignatureVisitor 
\series bold
visitTypeArgument
\series default
(char wildcard);
\end_layout

\begin_layout LyX-Code
  public void 
\series bold
visitEnd
\series default
();
\end_layout

\begin_layout LyX-Code
}
\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:The-SignatureVisitor-interface"

\end_inset

The 
\family typewriter
SignatureVisitor
\family default

\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
SignatureVisitor@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
texttt{SignatureVisitor}
\end_layout

\end_inset


\end_layout

\end_inset

 class
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
This abstract class is used to visit type signatures, method signatures
 and class signatures.
 The methods used to visit type signatures are in bold, and must be called
 in the following order, which reflects the previous grammar rules (note
 that two of them return a 
\family typewriter
SignatureVisitor
\family default
: this is due to the recursive definition of type signatures):
\end_layout

\begin_layout LyX-Code

\family typewriter
visitBaseType
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

{
\backslash
normalfont~|~}
\end_layout

\end_inset

visitArrayType
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

{
\backslash
normalfont~|~}
\end_layout

\end_inset

visitTypeVariable
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

{
\backslash
normalfont~|}
\end_layout

\end_inset


\end_layout

\begin_layout LyX-Code

\family typewriter
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

{
\backslash
normalfont(~}
\end_layout

\end_inset

visitClassType
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

{
\backslash
normalfont~}
\end_layout

\end_inset

visitTypeArgument
\family default

\begin_inset ERT
status collapsed

\begin_layout Plain Layout

{
\backslash
normalfont{*}}
\end_layout

\end_inset


\end_layout

\begin_layout LyX-Code
 
\family typewriter
 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

{
\backslash
normalfont(~}
\end_layout

\end_inset

visitInnerClassType
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

{
\backslash
normalfont~}
\end_layout

\end_inset

visitTypeArgument
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

{
\backslash
normalfont*~)*~}
\end_layout

\end_inset

visitEnd
\family default

\begin_inset ERT
status collapsed

\begin_layout Plain Layout

{
\backslash
normalfont~)~)}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The methods used to visit method signatures are the following:
\end_layout

\begin_layout LyX-Code

\family typewriter
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

{
\backslash
normalfont(~}
\end_layout

\end_inset

visitFormalTypeParameter
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

{
\backslash
normalfont~}
\end_layout

\end_inset

visitClassBound
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

{
\backslash
normalfont?~}
\end_layout

\end_inset

visitInterfaceBound
\family default

\begin_inset ERT
status collapsed

\begin_layout Plain Layout

{
\backslash
normalfont{*}~)*}
\end_layout

\end_inset


\end_layout

\begin_layout LyX-Code

\family typewriter
visitParameterType
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

{
\backslash
normalfont{*}~}
\end_layout

\end_inset

visitReturnType
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

{
\backslash
normalfont~}
\end_layout

\end_inset

visitExceptionType
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

{
\backslash
normalfont{*}}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Finally the methods used to visit class signatures are:
\end_layout

\begin_layout LyX-Code

\family typewriter
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

{
\backslash
normalfont(~}
\end_layout

\end_inset


\family default
visitFormalTypeParameter
\family typewriter

\begin_inset ERT
status collapsed

\begin_layout Plain Layout

{
\backslash
normalfont~}
\end_layout

\end_inset


\family default
visitClassBound
\family typewriter

\begin_inset ERT
status collapsed

\begin_layout Plain Layout

{
\backslash
normalfont?~}
\end_layout

\end_inset


\family default
visitInterfaceBound
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

{
\backslash
normalfont{*}~)*}
\end_layout

\end_inset


\end_layout

\begin_layout LyX-Code
visitSuperClass
\family typewriter

\begin_inset ERT
status collapsed

\begin_layout Plain Layout

{
\backslash
normalfont~}
\end_layout

\end_inset


\family default
visitInterface
\family typewriter

\begin_inset ERT
status collapsed

\begin_layout Plain Layout

{
\backslash
normalfont{*}}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Most of these methods return a 
\family typewriter
SignatureVisitor
\family default
: it is intended to visit a 
\emph on
type
\emph default
 signature.
 Note that, unlike with the 
\family typewriter
MethodVisitor
\family default
s returned by a 
\family typewriter
ClassVisitor
\family default
, the 
\family typewriter
SignatureVisitor
\family default
s returned by a 
\family typewriter
SignatureVisitor
\family default
 must not be 
\family typewriter
null
\family default
, and must be used sequentially: in fact no method of the parent visitor
 must be called before a nested signature is fully visited.
\end_layout

\begin_layout Standard
Like for classes, the ASM API provides two components based on this API:
 the 
\family typewriter
SignatureReader
\family default

\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
SignatureReader@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
texttt{SignatureReader}
\end_layout

\end_inset


\end_layout

\end_inset

 component parses a signature and calls the appropriate visit methods on
 a given signature visitor, and the 
\family typewriter
SignatureWriter
\family default

\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
SignatureWriter@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
texttt{SignatureWriter}
\end_layout

\end_inset


\end_layout

\end_inset

 component builds a signature based on the method calls it received.
 
\end_layout

\begin_layout Standard
These two classes can be used to generate and transform signatures by using
 the same principles as with classes and methods.
 For example, let's suppose you want to rename the class names that appear
 in some signatures.
 This can be done with the following signature adapter, which forwards all
 the method calls it receives unchanged, except for the 
\family typewriter
visitClassType
\family default
 and 
\family typewriter
visitInnerClassType
\family default
 methods (we suppose here that 
\family typewriter
sv
\family default
 methods always return 
\family typewriter
this
\family default
, which is the case of 
\family typewriter
SignatureWriter
\family default
):
\end_layout

\begin_layout LyX-Code
public class RenameSignatureAdapter extends SignatureVisitor {
\end_layout

\begin_layout LyX-Code
  private SignatureVisitor sv;
\end_layout

\begin_layout LyX-Code
  
\series bold
private Map<String, String> renaming;
\end_layout

\begin_layout LyX-Code
 
\series bold
 private String oldName;
\end_layout

\begin_layout LyX-Code
  public RenameSignatureAdapter(SignatureVisitor sv,
\end_layout

\begin_layout LyX-Code
      
\series bold
Map<String, String> renaming
\series default
) {
\end_layout

\begin_layout LyX-Code
    super(ASM4);
\end_layout

\begin_layout LyX-Code
    this.sv = sv;
\end_layout

\begin_layout LyX-Code
    
\series bold
this.renaming = renaming;
\end_layout

\begin_layout LyX-Code
  }
\end_layout

\begin_layout LyX-Code
  public void visitFormalTypeParameter(String name) {
\end_layout

\begin_layout LyX-Code
    sv.visitFormalTypeParameter(name);
\end_layout

\begin_layout LyX-Code
  }
\end_layout

\begin_layout LyX-Code
  public SignatureVisitor visitClassBound() {
\end_layout

\begin_layout LyX-Code
    sv.visitClassBound();
\end_layout

\begin_layout LyX-Code
    return this;
\end_layout

\begin_layout LyX-Code
  }
\end_layout

\begin_layout LyX-Code
  public SignatureVisitor visitInterfaceBound() {
\end_layout

\begin_layout LyX-Code
    sv.visitInterfaceBound();
\end_layout

\begin_layout LyX-Code
    return this;
\end_layout

\begin_layout LyX-Code
  }
\end_layout

\begin_layout LyX-Code
  ...
\end_layout

\begin_layout LyX-Code
  public void visitClassType(String name) {
\end_layout

\begin_layout LyX-Code
    
\series bold
oldName = name;
\end_layout

\begin_layout LyX-Code
 
\series bold
   String newName = renaming.get(oldName);
\end_layout

\begin_layout LyX-Code
 
\series bold
   sv.visitClassType(newName == null ? name : newName);
\end_layout

\begin_layout LyX-Code
  }
\end_layout

\begin_layout LyX-Code
  public void visitInnerClassType(String name) {
\end_layout

\begin_layout LyX-Code
    
\series bold
oldName = oldName + "." + name;
\end_layout

\begin_layout LyX-Code
 
\series bold
   String newName = renaming.get(oldName);
\end_layout

\begin_layout LyX-Code
 
\series bold
   sv.visitInnerClassType(newName == null ? name : newName);
\end_layout

\begin_layout LyX-Code
  }
\end_layout

\begin_layout LyX-Code
  public void visitTypeArgument() {
\end_layout

\begin_layout LyX-Code
    sv.visitTypeArgument();
\end_layout

\begin_layout LyX-Code
  }
\end_layout

\begin_layout LyX-Code
  public SignatureVisitor visitTypeArgument(char wildcard) {
\end_layout

\begin_layout LyX-Code
    sv.visitTypeArgument(wildcard);
\end_layout

\begin_layout LyX-Code
    return this;
\end_layout

\begin_layout LyX-Code
  }
\end_layout

\begin_layout LyX-Code
  public void visitEnd() {
\end_layout

\begin_layout LyX-Code
    sv.visitEnd();
\end_layout

\begin_layout LyX-Code
  }
\end_layout

\begin_layout LyX-Code
}
\end_layout

\begin_layout Standard
Then the result of the following code is 
\family typewriter
"LA<TK;TV;>.B<TK;>;"
\family default
:
\end_layout

\begin_layout LyX-Code
String s = "
\series bold
Ljava/util/HashMap<TK;TV;>.HashIterator<TK;>;
\series default
";
\end_layout

\begin_layout LyX-Code
Map<String, String> renaming = new HashMap<String, String>();
\end_layout

\begin_layout LyX-Code
renaming.put(
\series bold
"java/util/HashMap", "A"
\series default
);
\end_layout

\begin_layout LyX-Code
renaming.put(
\series bold
"java/util/HashMap.HashIterator", "B"
\series default
);
\end_layout

\begin_layout LyX-Code
SignatureWriter sw = new SignatureWriter();
\end_layout

\begin_layout LyX-Code
SignatureVisitor sa = new RenameSignatureAdapter(sw, renaming);
\end_layout

\begin_layout LyX-Code
SignatureReader sr = new SignatureReader(s);
\end_layout

\begin_layout LyX-Code
sr.acceptType(sa);
\end_layout

\begin_layout LyX-Code
sw.toString();
\end_layout

\begin_layout Subsection
Tools
\end_layout

\begin_layout Standard
The 
\family typewriter
TraceClassVisitor
\family default

\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
TraceClassVisitor@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
texttt{TraceClassVisitor}
\end_layout

\end_inset


\end_layout

\end_inset

 and 
\family typewriter
ASMifier
\family default

\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
ASMifier@
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{ASMifier}
\end_layout

\end_inset


\end_layout

\end_inset

 classes, presented in section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:ClassTools"

\end_inset

, print the signatures contained in class files in their internal form.
 They can be used to find the signature corresponding to a given generic
 type in the following way: write a Java class with some generic types,
 compile it, and use these command line tools to find the corresponding
 signatures.
\end_layout

\begin_layout Section
Annotations
\begin_inset CommandInset label
LatexCommand label
name "sec:Annotations"

\end_inset


\end_layout

\begin_layout Standard
Class, field, method and method parameter annotations, such as 
\family typewriter
@Deprecated
\family default
 or 
\family typewriter
@Override
\family default
, are stored in compiled classes if their retention policy is not 
\family typewriter
RetentionPolicy.SOURCE
\family default
.
 This information is not used at runtime by the bytecode instructions, but
 it can be accessed via the reflection API if the retention policy is 
\family typewriter
RetentionPolicy.RUNTIME
\family default
.
 It can also be used by compilers.
\end_layout

\begin_layout Subsection
Structure
\end_layout

\begin_layout Standard
Annotations
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
annotations
\end_layout

\end_inset

 in source code can have various forms, such as 
\family typewriter
@Deprecated
\family default
, 
\family typewriter
@Retention(RetentionPolicy.CLASS)
\family default
 or 
\family typewriter
@Task(desc="refactor", id=1)
\family default
.
 Internally, however, all annotations have the same form and are specified
 by an annotation type and by a set of name value pairs, where values are
 restricted to:
\end_layout

\begin_layout Itemize
primitive, 
\family typewriter
String
\family default
 or 
\family typewriter
Class
\family default
 values,
\end_layout

\begin_layout Itemize
enum values,
\end_layout

\begin_layout Itemize
annotation values,
\end_layout

\begin_layout Itemize
arrays of the above values.
\end_layout

\begin_layout Standard
Note that an annotation can contain other annotations, or even annotation
 arrays.
 Annotations can therefore be quite complex.
\end_layout

\begin_layout Subsection
Interfaces and components
\end_layout

\begin_layout Standard
The ASM API for generating and transforming annotations is based on the
 
\family typewriter
AnnotationVisitor
\family default
 abstract class (see Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:The-AnnotationVisitor-interface"

\end_inset

).
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout LyX-Code
public abstract class 
\series bold
AnnotationVisitor
\series default
 {
\end_layout

\begin_layout LyX-Code
  public AnnotationVisitor(int api);
\end_layout

\begin_layout LyX-Code
  public AnnotationVisitor(int api, AnnotationVisitor av);
\end_layout

\begin_layout LyX-Code
  public void 
\series bold
visit
\series default
(String name, Object value);
\end_layout

\begin_layout LyX-Code
  public void 
\series bold
visitEnum
\series default
(String name, String desc, String value);
\end_layout

\begin_layout LyX-Code
  public AnnotationVisitor 
\series bold
visitAnnotation
\series default
(String name, String desc);
\end_layout

\begin_layout LyX-Code
  public AnnotationVisitor 
\series bold
visitArray
\series default
(String name);
\end_layout

\begin_layout LyX-Code
  public void 
\series bold
visitEnd
\series default
();
\end_layout

\begin_layout LyX-Code
}
\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:The-AnnotationVisitor-interface"

\end_inset

The 
\family typewriter
AnnotationVisitor
\family default

\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
AnnotationVisitor@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
texttt{AnnotationVisitor}
\end_layout

\end_inset


\end_layout

\end_inset

 class
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
The methods of this class are used to visit the name value pairs of an annotatio
n (the annnotation type is visited in the methods that return this type,
 i.e.
 the 
\family typewriter
visitAnnotation
\family default
 methods).
 The first method is used for primitive, 
\family typewriter
String
\family default
 and 
\family typewriter
Class
\family default
 values (the later being represented by 
\family typewriter
Type
\family default
 objects), and the others are used for enum, annotation and array values.
 They can be called in any order, except 
\family typewriter
visitEnd
\family default
:
\end_layout

\begin_layout LyX-Code
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

{
\backslash
normalfont(~}
\end_layout

\end_inset

visit
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

{
\backslash
normalfont~|~}
\end_layout

\end_inset

visitEnum
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

{
\backslash
normalfont~|~}
\end_layout

\end_inset

visitAnnotation
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

{
\backslash
normalfont~|~}
\end_layout

\end_inset

visitArray
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

{
\backslash
normalfont~)*~}
\end_layout

\end_inset

visitEnd
\end_layout

\begin_layout Standard
Note that two methods return an 
\family typewriter
AnnotationVisitor
\family default
: this is because annotations can contain other annotations.
 Also unlike with the 
\family typewriter
MethodVisitor
\family default
s returned by a 
\family typewriter
ClassVisitor
\family default
, the 
\family typewriter
AnnotationVisitor
\family default
s returned by these two methods must be used sequentially: in fact no method
 of the parent visitor must be called before a nested annotation is fully
 visited.
\end_layout

\begin_layout Standard
Note also that the 
\family typewriter
visitArray
\family default
 method returns an 
\family typewriter
AnnotationVisitor
\family default
 to visit the elements of an array.
 However, since the elements of an array are not named, the 
\family typewriter
name
\family default
 arguments are ignored by the methods of the visitor returned by 
\family typewriter
visitArray
\family default
, and can be set to 
\family typewriter
null
\family default
.
\end_layout

\begin_layout Subsubsection*
Adding, removing and detecting annotations
\end_layout

\begin_layout Standard
Like for fields and methods, an annotation can be removed by returning 
\family typewriter
null
\family default
 in the 
\family typewriter
visitAnnotation
\family default
 methods:
\end_layout

\begin_layout LyX-Code
public class RemoveAnnotationAdapter extends ClassVisitor {
\end_layout

\begin_layout LyX-Code
  private String annDesc;
\end_layout

\begin_layout LyX-Code
  public RemoveAnnotationAdapter(ClassVisitor cv, String annDesc) {
\end_layout

\begin_layout LyX-Code
    super(ASM4, cv);
\end_layout

\begin_layout LyX-Code
    this.annDesc = annDesc;
\end_layout

\begin_layout LyX-Code
  }
\end_layout

\begin_layout LyX-Code
  @Override
\end_layout

\begin_layout LyX-Code
  public AnnotationVisitor visitAnnotation(String desc, boolean vis) {
\end_layout

\begin_layout LyX-Code
    
\series bold
if (desc.equals(annDesc)) {
\end_layout

\begin_layout LyX-Code
      
\series bold
return null;
\end_layout

\begin_layout LyX-Code
    
\series bold
}
\end_layout

\begin_layout LyX-Code
    return cv.visitAnnotation(desc, vis);
\end_layout

\begin_layout LyX-Code
  }
\end_layout

\begin_layout LyX-Code
}
\end_layout

\begin_layout Standard
Adding a class annotation
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
annotations!adding
\end_layout

\end_inset

 is more difficult because of the constraints in which the methods of the
 
\family typewriter
ClassVisitor
\family default
 class must be called.
 Indeed all the methods that may follow a 
\family typewriter
visitAnnotation
\family default
 must be overridden to detect when all annotations have been visited (method
 annotations are easier to add, thanks to the 
\family typewriter
visitCode
\family default
 method):
\end_layout

\begin_layout LyX-Code
public class AddAnnotationAdapter extends ClassVisitor {
\end_layout

\begin_layout LyX-Code
  private String annotationDesc;
\end_layout

\begin_layout LyX-Code
  
\series bold
private boolean isAnnotationPresent;
\end_layout

\begin_layout LyX-Code
  public AddAnnotationAdapter(ClassVisitor cv, String annotationDesc) {
\end_layout

\begin_layout LyX-Code
    super(ASM4, cv);
\end_layout

\begin_layout LyX-Code
    this.annotationDesc = annotationDesc;
\end_layout

\begin_layout LyX-Code
  }
\end_layout

\begin_layout LyX-Code
  @Override public void visit(int version, int access, String name,
\end_layout

\begin_layout LyX-Code
      String signature, String superName, String[] interfaces) {
\end_layout

\begin_layout LyX-Code
    
\series bold
int v = (version & 0xFF) < V1_5 ? V1_5 : version;
\end_layout

\begin_layout LyX-Code
    cv.visit(
\series bold
v
\series default
, access, name, signature, superName, interfaces);
\end_layout

\begin_layout LyX-Code
  }
\end_layout

\begin_layout LyX-Code
  @Override public AnnotationVisitor visitAnnotation(String desc,
\end_layout

\begin_layout LyX-Code
      boolean visible) {
\end_layout

\begin_layout LyX-Code
    
\series bold
if (visible && desc.equals(annotationDesc)) {
\end_layout

\begin_layout LyX-Code
 
\series bold
     isAnnotationPresent = true;
\end_layout

\begin_layout LyX-Code
 
\series bold
   }
\end_layout

\begin_layout LyX-Code
    return cv.visitAnnotation(desc, visible);
\end_layout

\begin_layout LyX-Code
  }
\end_layout

\begin_layout LyX-Code
  @Override public void visitInnerClass(String name, String outerName,
\end_layout

\begin_layout LyX-Code
      String innerName, int access) {
\end_layout

\begin_layout LyX-Code
    
\series bold
addAnnotation();
\end_layout

\begin_layout LyX-Code
    cv.visitInnerClass(name, outerName, innerName, access);
\end_layout

\begin_layout LyX-Code
  }
\end_layout

\begin_layout LyX-Code
  @Override 
\end_layout

\begin_layout LyX-Code
  public FieldVisitor visitField(int access, String name, String desc,
\end_layout

\begin_layout LyX-Code
      String signature, Object value) {
\end_layout

\begin_layout LyX-Code
    
\series bold
addAnnotation();
\end_layout

\begin_layout LyX-Code
    return cv.visitField(access, name, desc, signature, value);
\end_layout

\begin_layout LyX-Code
  }
\end_layout

\begin_layout LyX-Code
  @Override 
\end_layout

\begin_layout LyX-Code
  public MethodVisitor visitMethod(int access, String name,
\end_layout

\begin_layout LyX-Code
      String desc, String signature, String[] exceptions) {
\end_layout

\begin_layout LyX-Code
    
\series bold
addAnnotation();
\end_layout

\begin_layout LyX-Code
    return cv.visitMethod(access, name, desc, signature, exceptions);
\end_layout

\begin_layout LyX-Code
  }
\end_layout

\begin_layout LyX-Code
  @Override public void visitEnd() {
\end_layout

\begin_layout LyX-Code
    
\series bold
addAnnotation();
\end_layout

\begin_layout LyX-Code
    cv.visitEnd();
\end_layout

\begin_layout LyX-Code
  }
\end_layout

\begin_layout LyX-Code
  
\series bold
private void addAnnotation() {
\end_layout

\begin_layout LyX-Code
 
\series bold
   if (!isAnnotationPresent) {
\end_layout

\begin_layout LyX-Code
 
\series bold
     AnnotationVisitor av = cv.visitAnnotation(annotationDesc, true);
\end_layout

\begin_layout LyX-Code
 
\series bold
     if (av != null) {
\end_layout

\begin_layout LyX-Code
 
\series bold
       av.visitEnd();
\end_layout

\begin_layout LyX-Code
      
\series bold
}
\end_layout

\begin_layout LyX-Code
 
\series bold
     isAnnotationPresent = true;
\end_layout

\begin_layout LyX-Code
 
\series bold
   }
\end_layout

\begin_layout LyX-Code
 
\series bold
 }
\end_layout

\begin_layout LyX-Code
}
\end_layout

\begin_layout Standard
Note that this adapter upgrades the class version to 1.5 if it was less than
 that.
 This is necessary because the JVM ignores annotations in classes whose
 version is less than 1.5.
\end_layout

\begin_layout Standard
The last and probably most frequent use case of annotations in class and
 method adapters is to use annotations in order to parameterize a transformation.
 For instance you could transform field accesses only for fields that have
 a 
\family typewriter
@Persistent
\family default
 annotation, add logging code only to methods that have a 
\family typewriter
@Log
\family default
 annotation, and so on.
 All these use cases can easily be implemented because annotations must
 be visited first: class annotations must be visited before fields and methods,
 and method and parameter annotations must be visited before the code.
 It is therefore sufficient to set a flag when the desired annotation is
 detected
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
annotations!detecting
\end_layout

\end_inset

, and to use it later on in the transformation, as is done in the above
 example with the 
\family typewriter
isAnnotationPresent
\family default
 flag.
\end_layout

\begin_layout Subsection
Tools
\end_layout

\begin_layout Standard
The 
\family typewriter
TraceClassVisitor
\family default

\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
TraceClassVisitor@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
texttt{TraceClassVisitor}
\end_layout

\end_inset


\end_layout

\end_inset

, 
\family typewriter
CheckClassAdapter
\family default
 and 
\family typewriter
ASMifier
\family default
 classes, presented in section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:ClassTools"

\end_inset

, also support annotations (like for methods, it is also possible to use
 
\family typewriter
TraceAnnotationVisitor
\family default
 or 
\family typewriter
CheckAnnotationAdapter
\family default
 to work at the level of individual annotations instead of at the class
 level).
 They can be used to see how to generate some specific annotation.
 For example using:
\end_layout

\begin_layout LyX-Code
java -classpath asm.jar:asm-util.jar 
\backslash

\end_layout

\begin_layout LyX-Code
     org.objectweb.asm.util.ASMifier 
\backslash

\end_layout

\begin_layout LyX-Code
     java.lang.Deprecated
\end_layout

\begin_layout Standard
prints code that, after minor refactoring, reads:
\end_layout

\begin_layout LyX-Code
package asm.java.lang;
\end_layout

\begin_layout LyX-Code
import org.objectweb.asm.*;
\end_layout

\begin_layout LyX-Code
public class DeprecatedDump implements Opcodes {
\end_layout

\begin_layout LyX-Code
  public static byte[] dump() throws Exception {
\end_layout

\begin_layout LyX-Code
    ClassWriter cw = new ClassWriter(0);
\end_layout

\begin_layout LyX-Code
    AnnotationVisitor av;
\end_layout

\begin_layout LyX-Code
    cw.visit(V1_5, ACC_PUBLIC + 
\series bold
ACC_ANNOTATION
\series default
 + ACC_ABSTRACT
\end_layout

\begin_layout LyX-Code
        + ACC_INTERFACE, "java/lang/Deprecated", null,
\end_layout

\begin_layout LyX-Code
        "java/lang/Object",
\end_layout

\begin_layout LyX-Code
        new String[] { "java/lang/annotation/Annotation" });
\end_layout

\begin_layout LyX-Code
    {
\end_layout

\begin_layout LyX-Code
      
\series bold
av = cw.visitAnnotation("Ljava/lang/annotation/Documented;",
\end_layout

\begin_layout LyX-Code
 
\series bold
         true);
\end_layout

\begin_layout LyX-Code
 
\series bold
     av.visitEnd();
\end_layout

\begin_layout LyX-Code
    }
\end_layout

\begin_layout LyX-Code
    {
\end_layout

\begin_layout LyX-Code
      
\series bold
av = cw.visitAnnotation("Ljava/lang/annotation/Retention;", true);
\end_layout

\begin_layout LyX-Code
 
\series bold
     av.visitEnum("value", "Ljava/lang/annotation/RetentionPolicy;",
\end_layout

\begin_layout LyX-Code
 
\series bold
         "RUNTIME");
\end_layout

\begin_layout LyX-Code
 
\series bold
     av.visitEnd();
\end_layout

\begin_layout LyX-Code
    }
\end_layout

\begin_layout LyX-Code
    cw.visitEnd();
\end_layout

\begin_layout LyX-Code
    return cw.toByteArray();
\end_layout

\begin_layout LyX-Code
  }
\end_layout

\begin_layout LyX-Code
}
\end_layout

\begin_layout Standard
This code shows how two create an annotation class, with the 
\family typewriter
ACC_ANNOTATION
\family default
 flag, and shows how to create two class annotations, one without value,
 and one with an enum value.
 Method and parameter annotations can be created in a similar way, with
 the 
\family typewriter
visitAnnotation
\family default
 and 
\family typewriter
visitParameterAnnotation
\family default
 methods defined in the 
\family typewriter
MethodVisitor
\family default
 class.
\end_layout

\begin_layout Section
Debug
\end_layout

\begin_layout Standard
Classes compiled with 
\family typewriter
javac -g
\family default
 contain the name of their source file, a mapping between source line numbers
 and bytecode instructions, and a mapping betwen local variable names in
 source code and local variable slots in bytecode.
 This optional information is used in debuggers and in exception stack traces
 when it is available.
\end_layout

\begin_layout Subsection
Structure
\end_layout

\begin_layout Standard
The source file name of a class is stored in a dedicated class file structure
 section (see Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Overall-structure-of-class-file"

\end_inset

).
\end_layout

\begin_layout Standard
The mapping between source line numbers and bytecode instructions is stored
 as a list of (
\emph on
line number
\emph default
, 
\emph on
label
\emph default
) pairs in the compiled code section of methods.
 For example if 
\family typewriter
\emph on
l1
\family default
\emph default
, 
\family typewriter
\emph on
l2
\family default
\emph default
 and 
\family typewriter
\emph on
l3
\family default
\emph default
 are three labels that appear in this order, then the following pairs:
\end_layout

\begin_layout LyX-Code
(n1, 
\shape slanted
l1
\shape default
)
\end_layout

\begin_layout LyX-Code
(n2, 
\shape slanted
l2
\shape default
)
\end_layout

\begin_layout LyX-Code
(n3, 
\shape slanted
l3
\shape default
)
\end_layout

\begin_layout Standard
mean that instructions between 
\family typewriter
\emph on
l1
\family default
\emph default
 and 
\family typewriter
\emph on
l2
\family default
\emph default
 come from line 
\family typewriter
n1
\family default
, that instructions between 
\family typewriter
\emph on
l2
\family default
\emph default
 and 
\family typewriter
\emph on
l3
\family default
\emph default
 come from line 
\family typewriter
n2
\family default
, and that instructions after 
\family typewriter
\emph on
l3
\family default
\emph default
 come from line 
\family typewriter
n3
\family default
.
 Note that a given line number can appear in several pairs.
 This is because the instructions corresponding to expressions that appear
 on a single source line may not be contiguous in the bytecode.
 For example 
\family typewriter
for (
\family default
\emph on
init
\family typewriter
\emph default
;
\family default
 
\emph on
cond
\family typewriter
\emph default
;
\family default
 
\emph on
incr
\family typewriter
\emph default
)
\family default
 
\emph on
statement
\family typewriter
\emph default
;
\family default
 is generaly compiled in the following order: 
\emph on
init
\emph default
 
\emph on
statement
\emph default
 
\emph on
incr
\emph default
 
\emph on
cond
\emph default
.
\end_layout

\begin_layout Standard
The mapping between local variable names in source code and local variable
 slots in bytecode is stored as a list of (
\emph on
name
\emph default
, 
\emph on
type descriptor
\emph default
, 
\emph on
type signature
\emph default
, 
\emph on
start
\emph default
, 
\emph on
end
\emph default
, 
\emph on
index
\emph default
) tuples in the compiled code section of methods.
 Such a tuple means that, between the two labels 
\emph on
start
\emph default
 and 
\emph on
end
\emph default
, the local variable in slot 
\emph on
index
\emph default
 corresponds to the local variable whose name and type in source code are
 given by the first three tuple elements.
 Note that the compiler may use the same local variable slot to store distinct
 source local variables with different scopes.
 Conversely a unique source local variable may be compiled into a local
 variable slot with a non contiguous scope.
 For instance it is possible to have a situation like this:
\end_layout

\begin_layout LyX-Code

\shape slanted
l1
\shape default
:
\end_layout

\begin_layout LyX-Code
  ...
 // here slot 1 contains local variable i
\end_layout

\begin_layout LyX-Code

\shape slanted
l2
\shape default
:
\end_layout

\begin_layout LyX-Code
  ...
 // here slot 1 contains local variable j
\end_layout

\begin_layout LyX-Code

\shape slanted
l3
\shape default
:
\end_layout

\begin_layout LyX-Code
  ...
 // here slot 1 contains local variable i again
\end_layout

\begin_layout LyX-Code

\shape slanted
end
\shape default
:
\end_layout

\begin_layout Standard
The corresponding tuples are:
\end_layout

\begin_layout LyX-Code
("i", "I", null, 
\shape slanted
l1
\shape default
, 
\shape slanted
l2
\shape default
, 1)
\end_layout

\begin_layout LyX-Code
("j", "I", null, 
\shape slanted
l2
\shape default
, 
\shape slanted
l3
\shape default
, 1)
\end_layout

\begin_layout LyX-Code
("i", "I", null, 
\shape slanted
l3
\shape default
, 
\shape slanted
end
\shape default
, 1)
\end_layout

\begin_layout Subsection
Interfaces and components
\end_layout

\begin_layout Standard
The debug information is visited with three methods of the 
\family typewriter
ClassVisitor
\family default
 and 
\family typewriter
MethodVisitor
\family default
 classes:
\end_layout

\begin_layout Itemize
the source file name is visited with the 
\family typewriter
visitSource
\family default
 method of the 
\family typewriter
ClassVisitor
\family default
 class;
\end_layout

\begin_layout Itemize
the mapping between source line numbers and bytecode instructions is visited
 with the 
\family typewriter
visitLineNumber
\family default
 method of the 
\family typewriter
MethodVisitor
\family default
 class, one pair at a time;
\end_layout

\begin_layout Itemize
the mapping between local variable names in source code and local variable
 slots in bytecode is visited with the 
\family typewriter
visitLocalVariable
\family default
 method of the 
\family typewriter
MethodVisitor
\family default
 class, one tuple at a time.
\end_layout

\begin_layout Standard
The 
\family typewriter
visitLineNumber
\family default
 method must be called after the label passed as argument has been visited.
 In practice it is called just after this label, which makes it very easy
 to know the source line of the current instruction in a method visitor:
\end_layout

\begin_layout LyX-Code
public class MyAdapter extends MethodVisitor {
\end_layout

\begin_layout LyX-Code
  
\series bold
int currentLine;
\end_layout

\begin_layout LyX-Code
  public MyAdapter(MethodVisitor mv) {
\end_layout

\begin_layout LyX-Code
    super(ASM4, mv);
\end_layout

\begin_layout LyX-Code
  }
\end_layout

\begin_layout LyX-Code
  @Override 
\end_layout

\begin_layout LyX-Code
  public void visitLineNumber(int line, Label start) {
\end_layout

\begin_layout LyX-Code
    mv.visitLineNumber(line, start);
\end_layout

\begin_layout LyX-Code
    
\series bold
currentLine = line;
\end_layout

\begin_layout LyX-Code
  }
\end_layout

\begin_layout LyX-Code
  ...
\end_layout

\begin_layout LyX-Code
}
\end_layout

\begin_layout Standard
Similarly the 
\family typewriter
visitLocalVariable
\family default
 method must be called after the labels passed as argument have been visited.
 Here are example method calls that correspond to the pairs and tuples presented
 in the previous section:
\end_layout

\begin_layout LyX-Code
visitLineNumber(n1, 
\shape slanted
l1
\shape default
);
\end_layout

\begin_layout LyX-Code
visitLineNumber(n2, 
\shape slanted
l2
\shape default
);
\end_layout

\begin_layout LyX-Code
visitLineNumber(n3, 
\shape slanted
l3
\shape default
);
\end_layout

\begin_layout LyX-Code
visitLocalVariable("i", "I", null, 
\shape slanted
l1
\shape default
, 
\shape slanted
l2
\shape default
, 1);
\end_layout

\begin_layout LyX-Code
visitLocalVariable("j", "I", null, 
\shape slanted
l2
\shape default
, 
\shape slanted
l3
\shape default
, 1);
\end_layout

\begin_layout LyX-Code
visitLocalVariable("i", "I", null, 
\shape slanted
l3
\shape default
, 
\shape slanted
end
\shape default
, 1);
\end_layout

\begin_layout Subsubsection*
Ignoring debug information
\end_layout

\begin_layout Standard
In order to visit line numbers and local variable names, the 
\family typewriter
ClassReader
\family default
 class may need to introduce 
\begin_inset Quotes eld
\end_inset

artificial
\begin_inset Quotes erd
\end_inset

 
\family typewriter
Label
\family default
 objects, in the sense that they are not needed by jump instructions, but
 only to represent the debug information.
 This can introduce false positives in situations such as the one explained
 in section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Statefull-transformations"

\end_inset

, where a 
\family typewriter
Label
\family default
 in the middle of an instruction sequence was considered to be a jump target,
 and therefore prevented this sequence from being removed.
\end_layout

\begin_layout Standard
In order to avoid these false positives it is possible to use the 
\family typewriter
SKIP_DEBUG
\family default
 option in the 
\family typewriter
ClassReader.accept
\family default
 method.
 With this option the class reader does not visit the debug information,
 and does not create artificial labels for it.
 Of course the debug information will be removed from the class, so this
 option can be used only if this is not a problem for your application.
\end_layout

\begin_layout Description
Note: the 
\family typewriter
ClassReader
\family default
 class provides other options
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
ClassReader@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
texttt{ClassReader}!options
\end_layout

\end_inset


\end_layout

\end_inset

 such as 
\family typewriter
SKIP_CODE
\family default
 to skip the visit of compiled code (this can be useful if you just need
 the class structure), 
\family typewriter
SKIP_FRAMES
\family default
 to skip the stack map frames
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
frames!skipping
\end_layout

\end_inset

, and 
\family typewriter
EXPAND_FRAMES
\family default
 to uncompress
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
frames!uncompressing
\end_layout

\end_inset

 these frames.
\end_layout

\begin_layout Subsection
Tools
\end_layout

\begin_layout Standard
Like for generic types and annotations, you can use the 
\family typewriter
TraceClassVisitor
\family default
, 
\family typewriter
CheckClassAdapter
\family default
 and 
\family typewriter
ASMifier
\family default
 classes to find how to work with debug information.
\end_layout

\begin_layout Chapter
Backward compatibility
\begin_inset CommandInset label
LatexCommand label
name "chap:Backward-compatibility"

\end_inset


\end_layout

\begin_layout Section
Introduction
\end_layout

\begin_layout Standard
New elements have been introduced in the past in the class file format,
 and new elements will continue to be added in the future (
\emph on
e.g.
\emph default
, for modularity, annotations on Java types, etc).
 Up to ASM 3.
\emph on
x
\emph default
, each such change led to backward incompatible changes in the ASM API,
 which is not good.
 To solve these problems, a new mechanism has been introduced in ASM 4.0.
 Its goal is to ensure that all future ASM versions will remain backward
 compatible with any previous version, down to ASM 4.0, even when new features
 will be introduced to the class file format.
 This means that a class generator, a class analyzer or a class adapter
 written for one ASM version, starting from 4.0, will still be usable with
 any future ASM version.
 
\emph on
However
\emph default
, this property can not be ensured by ASM alone.
 It requires users to follow a few simple guidelines when writing their
 code.
 The goal of this chapter is to present these guidelines, and to give an
 idea of the internal mechanism used in the ASM core API to ensure backward
 compatibility.
\end_layout

\begin_layout Description
Note: the backward compatibility mechanism introduced in ASM 4.0 required
 to change the 
\family typewriter
ClassVisitor
\family default
, 
\family typewriter
FieldVisitor
\family default
, 
\family typewriter
MethodVisitor
\family default
, etc from interfaces to abstract classes, with a constructor taking an
 ASM version as argument.
 If your code was implemented for ASM 3.
\emph on
x
\emph default
, you can upgrade it to ASM 4.0 by replacing 
\family typewriter
implements
\family default
 with 
\family typewriter
extends
\family default
 in your code analyzers and adapters, and by specifying an ASM version in
 their constructors.
 In addition, 
\family typewriter
ClassAdapter
\family default
 and 
\family typewriter
MethodAdapter
\family default
 have been merged into 
\family typewriter
ClassVisitor
\family default
 and 
\family typewriter
MethodVisitor
\family default
.
 To convert your code, you simply need to replace 
\family typewriter
ClassAdapter
\family default
 with 
\family typewriter
ClassVisitor
\family default
, and 
\family typewriter
MethodAdapter
\family default
 with 
\family typewriter
MethodVisitor
\family default
.
 Also, if you defined custom 
\family typewriter
FieldAdapter
\family default
 or 
\family typewriter
AnnotationAdapter
\family default
 classes, you can now replace them with 
\family typewriter
FieldVisitor
\family default
 and 
\family typewriter
AnnotationVisitor
\family default
.
\end_layout

\begin_layout Subsection
Backward compatibility contract
\begin_inset CommandInset label
LatexCommand label
name "sub:Backward-compatibility-contract"

\end_inset


\end_layout

\begin_layout Standard
Before presenting the user guidelines to ensure backward compatibility,
 we define here more precisely what we mean by 
\begin_inset Quotes eld
\end_inset

backward compatibility
\begin_inset Quotes erd
\end_inset

.
 
\end_layout

\begin_layout Standard
First of all, it is important to study how new class file features impact
 code generators, analyzers and adapters.
 That is, independently of any implementation and binary compatibility issues,
 does a class generator, analyzer or adapter designed before the introduction
 of these new features remains valid after these modifications? Said otherwise,
 if we suppose that the new features are simply ignored and passed untouched
 through a transformation chain designed before their introduction, does
 this chain remains valid? In fact the impact differs for class generators,
 analyzers and adapters: 
\end_layout

\begin_layout Itemize
class generators are not impacted: they generate code with some fixed class
 version, and these generated classes will remain valid with future JVM
 versions, because the JVM ensures backward binary compatibility.
 
\end_layout

\begin_layout Itemize
class analyzers may or may not be impacted.
 For instance, a code that analyzes the bytecode instructions, written for
 Java 4, will probably still work with Java 5 classes, despite the introduction
 of annotations.
 But this same code will probably no longer work with Java 7 classes, because
 it can not ignore the new invokedynamic instruction.
 
\end_layout

\begin_layout Itemize
class adapters may or may not be impacted.
 A dead code removal tool is not impacted by the introduction of annotations,
 or even by the new invokedynamic instruction.
 On the other hand, a class renaming tool is impacted by both.
\end_layout

\begin_layout Standard
This shows that new class file features can have an unpredictable impact
 on existing class analyzers or adapters.
 If the new features are simply ignored and passed unchanged through an
 analysis or transformation chain, sometimes this chain will run without
 errors and produce a valid result, sometimes it will run without errors
 but will produce an invalid result, and sometimes it will fail during execution.
 The second case is particularly problematic, since it breaks the analysis
 or transformation chain semantics without the user being aware of this.
 This can lead to hard to find bugs.
 To solve this, instead of ignoring the new features, we think it is preferable
 to raise an error as soon as an unknown feature is encountered in an analysis
 or transformation chain.
 The error signals that this chain may or may not work with the new class
 format, and that its author must analyze the situation to update it if
 necessary.
\end_layout

\begin_layout Standard
All this leads to the definition of the following backward compatibility
 contract: 
\end_layout

\begin_layout Itemize
ASM version 
\emph on
X
\emph default
 is written for Java classes whose version is less than or equal to 
\emph on
x
\emph default
.
 It cannot generate classes with a version 
\emph on
y
\emph default
 > 
\emph on
x
\emph default
, and it must 
\emph on
fail
\emph default
 if given as input, in 
\family typewriter
ClassReader.accept
\family default
, a class whose version is greater than 
\emph on
x
\emph default
.
 
\end_layout

\begin_layout Itemize
code written for ASM 
\emph on
X
\emph default
 and following the guidelines presented below must continue to work, unmodified,
 with input classes up to version 
\emph on
x
\emph default
, with any future version 
\emph on
Y
\emph default
 > 
\emph on
X
\emph default
 of ASM.
 
\end_layout

\begin_layout Itemize
code written for ASM 
\emph on
X
\emph default
 and following the guidelines presented below must continue to work, unmodified,
 with input classes whose declared version is 
\emph on
y
\emph default
 but that only use features defined in versions older or equal to 
\emph on
x
\emph default
, with ASM 
\emph on
Y
\emph default
 or any future version.
 
\end_layout

\begin_layout Itemize
code written for ASM 
\emph on
X
\emph default
 and following the guidelines presented below must 
\emph on
fail
\emph default
 if given as input a class that uses features introduced in class versions
 
\emph on
y
\emph default
 > 
\emph on
x
\emph default
, with ASM 
\emph on
X
\emph default
 or any other future version.
\end_layout

\begin_layout Standard
Note that the last three points do not concern class generators, which do
 not have class inputs.
 
\end_layout

\begin_layout Subsection
An example
\begin_inset CommandInset label
LatexCommand label
name "sub:BackwardCompatibility-An-example"

\end_inset


\end_layout

\begin_layout Standard
In order to illustrate the user guidelines and the internal ASM mechanism
 ensuring backward compatibility, we suppose in this chapter that two new
 imaginary attributes will be added to Java 8 classes, one to store the
 class author(s), and one to store its license.
 We also suppose that these new attributes will be exposed via two new methods
 in 
\family typewriter
ClassVisitor
\family default
, in ASM 5.0:
\end_layout

\begin_layout LyX-Code
void visitLicense(String license);
\end_layout

\begin_layout Standard
to visit the license, and a new version of 
\family typewriter
visitSource
\family default
 to visit the author at the same time as the source file name and debug
 information
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
in reality we would probably add a single 
\family typewriter
visitLicense(String author, String license)
\family default
 method, since modifying a method signature is more complex than adding
 a method, as will be shown below.
 We do this here only for illustration purposes.
\end_layout

\end_inset

:
\end_layout

\begin_layout LyX-Code
void visitSource(String author, String source, String debug);
\end_layout

\begin_layout Standard
The old 
\family typewriter
visitSource
\family default
 method remains valid, but is declared deprecated in ASM 5.0:
\end_layout

\begin_layout LyX-Code
@Deprecated void visitSource(String source, String debug);
\end_layout

\begin_layout Standard
The author and license attributes are optional, i.e., calling 
\family typewriter
visitLicense
\family default
 is not mandatory, and 
\family typewriter
author
\family default
 can be 
\family typewriter
null
\family default
 in a 
\family typewriter
visitSource
\family default
 call.
\end_layout

\begin_layout Section
Guidelines
\end_layout

\begin_layout Standard
This section presents the guidelines that you must follow when using the
 core ASM API, in order to ensure that your code will remain valid with
 any future ASM versions (in the sense of the above contract).
\end_layout

\begin_layout Standard
First of all, if you write a class generator, you don't have any guideline
 to follow.
 For example, if you write a class generator for ASM 4.0, it will probably
 contain a call like 
\family typewriter
visitSource(mySource, myDebug)
\family default
, and of course no call to 
\family typewriter
visitLicense
\family default
.
 If you run it unchanged with ASM 5.0, this will call the deprecated 
\family typewriter
visitSource
\family default
 method, but the ASM 5.0 
\family typewriter
ClassWriter
\family default
 will internally redirect this to 
\family typewriter
visitSource(null, mySource, myDebug)
\family default
, yielding the expected result (but a bit less efficiently than if you upgrade
 your code to call the new method directly).
 Likewise, the absence of a call to 
\family typewriter
visitLicense
\family default
 will not be a problem (the generated class version will not have changed
 either, and classes of this version are not expected to have a license
 attribute).
\end_layout

\begin_layout Standard
If, on the other hand, you write a class analyzer or a class adapter, i.e.
 if you override the 
\family typewriter
ClassVisitor
\family default
 class (or any other similar class like 
\family typewriter
FieldVisitor
\family default
 or 
\family typewriter
MethodVisitor
\family default
), you must follow a few guidelines, presented below.
\end_layout

\begin_layout Subsection
Basic rule
\end_layout

\begin_layout Standard
We consider here the simple case of a class extending directly 
\family typewriter
ClassVisitor
\family default
 (the discussion and guidelines are the same for the other visitor classes;
 the case of indirect subclasses is discussed in the next section).
 In this case there is ony one guideline:
\end_layout

\begin_layout Description
Guideline
\begin_inset space ~
\end_inset

1: to write a 
\family typewriter
ClassVisitor
\family default
 subclass for ASM version 
\emph on
X
\emph default
, call the 
\family typewriter
ClassVisitor
\family default
 constructor with this exact version as argument, and 
\emph on
never override or call methods that are deprecated
\emph default
 in this version of the 
\family typewriter
ClassVisitor
\family default
 class (or that are introduced in later versions).
\end_layout

\begin_layout Standard
And that's it.
 In our example scenario (see section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:BackwardCompatibility-An-example"

\end_inset

), a class adapter written for ASM 4.0 must therefore look like this:
\end_layout

\begin_layout LyX-Code
class MyClassAdapter extends ClassVisitor { 
\end_layout

\begin_layout LyX-Code
  public MyClassAdapter(ClassVisitor cv) { 
\end_layout

\begin_layout LyX-Code
    super(
\series bold
ASM4
\series default
, cv); 
\end_layout

\begin_layout LyX-Code
  }
\end_layout

\begin_layout LyX-Code
  ...
\end_layout

\begin_layout LyX-Code
  public void visitSource(String source, String debug) { // optional
\end_layout

\begin_layout LyX-Code
    ...
\end_layout

\begin_layout LyX-Code
    super.visitSource(source, debug); // optional 
\end_layout

\begin_layout LyX-Code
  } 
\end_layout

\begin_layout LyX-Code
}
\end_layout

\begin_layout Standard
Once updated for ASM 5.0, 
\family typewriter
visitSource(String, String)
\family default
 must be removed, and the class must thus look like this:
\end_layout

\begin_layout LyX-Code
class MyClassAdapter extends ClassVisitor {
\end_layout

\begin_layout LyX-Code
  public MyClassAdapter(ClassVisitor cv) { 
\end_layout

\begin_layout LyX-Code
    super(
\series bold
ASM5
\series default
, cv); 
\end_layout

\begin_layout LyX-Code
  } 
\end_layout

\begin_layout LyX-Code
  ...
 
\end_layout

\begin_layout LyX-Code
  public void visitSource(String author, 
\end_layout

\begin_layout LyX-Code
      String source, String debug) { // optional 
\end_layout

\begin_layout LyX-Code
    ...
\end_layout

\begin_layout LyX-Code
    super.visitSource(author, source, debug); // optional 
\end_layout

\begin_layout LyX-Code
  } 
\end_layout

\begin_layout LyX-Code
  public void visitLicense(String license) { // optional
\end_layout

\begin_layout LyX-Code
    ...
\end_layout

\begin_layout LyX-Code
    super.visitLicense(license); // optional 
\end_layout

\begin_layout LyX-Code
  } 
\end_layout

\begin_layout LyX-Code
}
\end_layout

\begin_layout Standard
How does this work? Internally, 
\family typewriter
ClassVisitor
\family default
 is implemented as follows in ASM 4.0: 
\end_layout

\begin_layout LyX-Code
public abstract class ClassVisitor { 
\end_layout

\begin_layout LyX-Code
  int api; 
\end_layout

\begin_layout LyX-Code
  ClassVisitor cv; 
\end_layout

\begin_layout LyX-Code
  public ClassVisitor(int api, ClassVisitor cv) { 
\end_layout

\begin_layout LyX-Code
    this.api = api; 
\end_layout

\begin_layout LyX-Code
    this.cv = cv; 
\end_layout

\begin_layout LyX-Code
  }
\end_layout

\begin_layout LyX-Code
  ...
 
\end_layout

\begin_layout LyX-Code
  public void visitSource(String source, String debug) { 
\end_layout

\begin_layout LyX-Code
    if (cv != null) cv.visitSource(source, debug); 
\end_layout

\begin_layout LyX-Code
  } 
\end_layout

\begin_layout LyX-Code
}
\end_layout

\begin_layout Standard
In ASM 5.0, this code becomes:
\end_layout

\begin_layout LyX-Code
public abstract class ClassVisitor { 
\end_layout

\begin_layout LyX-Code
  ...
 
\end_layout

\begin_layout LyX-Code
  public void visitSource(String source, String debug) {
\end_layout

\begin_layout LyX-Code
    if (api < ASM5) { 
\end_layout

\begin_layout LyX-Code
      if (cv != null) cv.visitSource(source, debug); 
\end_layout

\begin_layout LyX-Code
    } else { 
\end_layout

\begin_layout LyX-Code
      visitSource(null, source, debug); 
\end_layout

\begin_layout LyX-Code
    } 
\end_layout

\begin_layout LyX-Code
  }
\end_layout

\begin_layout LyX-Code
  public void visitSource(Sring author, String source, String debug) { 
\end_layout

\begin_layout LyX-Code
    if (api < ASM5) { 
\end_layout

\begin_layout LyX-Code
      if (author == null) { 
\end_layout

\begin_layout LyX-Code
        visitSource(source, debug); 
\end_layout

\begin_layout LyX-Code
      } else { 
\end_layout

\begin_layout LyX-Code
        throw new RuntimeException(); 
\end_layout

\begin_layout LyX-Code
      } 
\end_layout

\begin_layout LyX-Code
    } else { 
\end_layout

\begin_layout LyX-Code
      if (cv != null) cv.visitSource(author, source, debug); 
\end_layout

\begin_layout LyX-Code
    } 
\end_layout

\begin_layout LyX-Code
  }
\end_layout

\begin_layout LyX-Code
  public void visitLicense(String license) { 
\end_layout

\begin_layout LyX-Code
    if (api < ASM5) throw new RuntimeException(); 
\end_layout

\begin_layout LyX-Code
    if (cv != null) cv.visitSource(source, debug);
\end_layout

\begin_layout LyX-Code
  } 
\end_layout

\begin_layout LyX-Code
}
\end_layout

\begin_layout Standard
If 
\family typewriter
MyClassAdapter
\family default
 4.0 extends 
\family typewriter
ClassVisitor
\family default
 4.0, everything works as expected.
 If we upgrade to ASM 5.0 without changing our code, 
\family typewriter
MyClassAdapter
\family default
 4.0 will now extend 
\family typewriter
ClassVisitor
\family default
 5.0.
 But the 
\family typewriter
api
\family default
 field will still be 
\family typewriter
ASM4
\family default
 < 
\family typewriter
ASM5
\family default
, and it is easy to see that in this case 
\family typewriter
ClassVisitor
\family default
 5.0 behaves like 
\family typewriter
ClassVisitor
\family default
 4.0 when calling 
\family typewriter
visitSource(String, String)
\family default
.
 In addition, if the new 
\family typewriter
visitSource
\family default
 method is called with a 
\family typewriter
null
\family default
 author, the call will be redirected to the old version.
 Finally, if a non null author or license is found in the input class, the
 execution will fail, as defined in our contract (either in the new 
\family typewriter
visitSource
\family default
 method or in 
\family typewriter
visitLicense
\family default
).
\end_layout

\begin_layout Standard
If we upgrade to ASM 5.0, and update our code at the same time, we now have
 
\family typewriter
MyClassAdapter
\family default
 5.0 extending 
\family typewriter
ClassVisitor
\family default
 5.0.
 The 
\family typewriter
api
\family default
 field is now 
\family typewriter
ASM5
\family default
, and 
\family typewriter
visitLicense
\family default
 and the new 
\family typewriter
visitSource
\family default
 methods behave then by simply delegating calls to the next visitor 
\family typewriter
cv
\family default
.
 In addition, the old 
\family typewriter
visitSource
\family default
 method now redirect calls to the new 
\family typewriter
visitSource
\family default
 method, which ensures that if an old class adapter is used before our own
 in a transformation chain, 
\family typewriter
MyClassAdapter
\family default
 5.0 will not miss this visit event.
\end_layout

\begin_layout Standard

\family typewriter
ClassReader
\family default
 will always call the latest version of each visit method.
 Thus, no indirection will occur if we use 
\family typewriter
MyClassAdapter
\family default
 4.0 with ASM 4.0, or 
\family typewriter
MyClassAdapter
\family default
 5.0 with ASM 5.0.
 It is only if we use 
\family typewriter
MyClassAdapter
\family default
 4.0 with ASM 5.0 that an indirection occurs in 
\family typewriter
ClassVisitor
\family default
 (at the 3rd line of new 
\family typewriter
visitSource
\family default
 method).
 Thus, although old code will still work with new ASM versions, it will
 run a little slower.
 Upgrading it to use the new API will restore its performance.
\end_layout

\begin_layout Subsection
Inheritance rule
\end_layout

\begin_layout Standard
The above guideline is sufficient for a direct subclass of 
\family typewriter
ClassVisitor
\family default
 or any other similar class.
 For indirect subclasses, i.e.
 if you define a subclass 
\family typewriter
A1
\family default
 extending 
\family typewriter
ClassVisitor
\family default
, itself extended by 
\family typewriter
A2
\family default
, ...
 itself extended by 
\family typewriter
An
\family default
, then 
\emph on
all these subclasses must be written for the same ASM version
\emph default
.
 Indeed, mixing different versions in an inheritance chain could lead to
 several versions of the same method -- like 
\family typewriter
visitSource(String,String)
\family default
 and 
\family typewriter
visitSource(String,String,String)
\family default
 -- overriden at the same time, with potentially different behaviors, resulting
 in wrong or unpredictable results.
 If these classes come from different sources, each updated independently
 and released separately, this property is almost impossible to ensure.
 This leads to a second guideline:
\end_layout

\begin_layout Description
Guideline
\begin_inset space ~
\end_inset

2: do not use inheritance of visitors, use delegation instead (
\emph on
i.e.
\emph default
, visitor chains).
 A good practice is to make your visitor classes final by default to ensure
 this.
\end_layout

\begin_layout Standard
In fact there are two exceptions to this guideline:
\end_layout

\begin_layout Itemize
you can use inheritance of visitors if you fully control the inheritance
 chain yourself, and release all the classes of the hierarchy at the same
 time.
 You must then ensure that all the classes in the hierarchy are written
 for the same ASM version.
 Still, make the leaf classes of your hierarchy final.
 
\end_layout

\begin_layout Itemize
you can use inheritance of 
\begin_inset Quotes eld
\end_inset

visitors
\begin_inset Quotes erd
\end_inset

 if no class except the leaf ones override any visit method (for instance,
 if you use intermediate classes between 
\family typewriter
ClassVisitor
\family default
 and the concrete visitor classes only to introduce convenience methods).
 Still, make the leaf classes of your hierarchy final (unless they do not
 override any visit method either; in this case provide a constructor taking
 an ASM version as argument so that subclasses can specify for which version
 they are written).
 
\end_layout

\begin_layout Part
Tree API
\end_layout

\begin_layout Chapter
Classes
\end_layout

\begin_layout Standard
This chapter explains how to generate and transform classes with the ASM
 tree API.
 It starts with a presentation of the tree API alone, and then explains
 how to compose it with the core API.
 The tree API for the content of methods, annotations and generics is explained
 in the next chapters.
\end_layout

\begin_layout Section
Interfaces and components
\end_layout

\begin_layout Subsection
Presentation
\end_layout

\begin_layout Standard
The ASM tree API for generating and transforming compiled Java classes is
 based on the 
\family typewriter
ClassNode
\family default
 class (see Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:The-ClassNode-class"

\end_inset

).
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout LyX-Code
public class 
\series bold
ClassNode
\series default
 ...
 {
\end_layout

\begin_layout LyX-Code
  public int version;
\end_layout

\begin_layout LyX-Code
  public int access;
\end_layout

\begin_layout LyX-Code
  public String name;
\end_layout

\begin_layout LyX-Code
  public String signature;
\end_layout

\begin_layout LyX-Code
  public String superName;
\end_layout

\begin_layout LyX-Code
  public List<String> interfaces;
\end_layout

\begin_layout LyX-Code
  public String sourceFile;
\end_layout

\begin_layout LyX-Code
  public String sourceDebug;
\end_layout

\begin_layout LyX-Code
  public String outerClass;
\end_layout

\begin_layout LyX-Code
  public String outerMethod;
\end_layout

\begin_layout LyX-Code
  public String outerMethodDesc;
\end_layout

\begin_layout LyX-Code
  public List<AnnotationNode> visibleAnnotations;
\end_layout

\begin_layout LyX-Code
  public List<AnnotationNode> invisibleAnnotations;
\end_layout

\begin_layout LyX-Code
  public List<Attribute> attrs;
\end_layout

\begin_layout LyX-Code
  public List<InnerClassNode> innerClasses;
\end_layout

\begin_layout LyX-Code
  public List<FieldNode> fields;
\end_layout

\begin_layout LyX-Code
  public List<MethodNode> methods;
\end_layout

\begin_layout LyX-Code
}
\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:The-ClassNode-class"

\end_inset

The 
\family typewriter
ClassNode
\family default

\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
ClassNode@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
texttt{ClassNode}
\end_layout

\end_inset


\end_layout

\end_inset

 class (only fields are shown)
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
As you can see the public fields of this class correspond to the class file
 structure sections presented in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Overall-structure-of-class-file"

\end_inset

.
 The content of these fields is the same as in the core API.
 For instance 
\family typewriter
name
\family default
 is an internal name and 
\family typewriter
signature
\family default
 is a class signature (see sections 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Internal-names"

\end_inset

 and 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Generics"

\end_inset

).
 Some fields contain other 
\family typewriter
\emph on
Xxx
\emph default
Node
\family default
 classes: these classes, presented in details in the next chapters, have
 a similar structure, i.e.
 have fields that correspond to sub sections of the class file structure.
 For instance the 
\family typewriter
FieldNode
\family default

\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
FieldNode@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
texttt{FieldNode}
\end_layout

\end_inset


\end_layout

\end_inset

 class looks like this:
\end_layout

\begin_layout LyX-Code
public class FieldNode ...
 {
\end_layout

\begin_layout LyX-Code
  public int access;
\end_layout

\begin_layout LyX-Code
  public String name;
\end_layout

\begin_layout LyX-Code
  public String desc;
\end_layout

\begin_layout LyX-Code
  public String signature;
\end_layout

\begin_layout LyX-Code
  public Object value;
\end_layout

\begin_layout LyX-Code
  public FieldNode(int access, String name, String desc, 
\end_layout

\begin_layout LyX-Code
      String signature, Object value) { 
\end_layout

\begin_layout LyX-Code
    ...
 
\end_layout

\begin_layout LyX-Code
  }
\end_layout

\begin_layout LyX-Code
  ...
\end_layout

\begin_layout LyX-Code
}
\end_layout

\begin_layout Standard
The 
\family typewriter
MethodNode
\family default

\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
MethodNode@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
texttt{MethodNode}
\end_layout

\end_inset


\end_layout

\end_inset

 class is similar:
\end_layout

\begin_layout LyX-Code
public class MethodNode ...
 {
\end_layout

\begin_layout LyX-Code
  public int access;
\end_layout

\begin_layout LyX-Code
  public String name;
\end_layout

\begin_layout LyX-Code
  public String desc;
\end_layout

\begin_layout LyX-Code
  public String signature;
\end_layout

\begin_layout LyX-Code
  public List<String> exceptions;
\end_layout

\begin_layout LyX-Code
  ...
\end_layout

\begin_layout LyX-Code
  public MethodNode(int access, String name, String desc,
\end_layout

\begin_layout LyX-Code
      String signature, String[] exceptions)
\end_layout

\begin_layout LyX-Code
  {
\end_layout

\begin_layout LyX-Code
    ...
\end_layout

\begin_layout LyX-Code
  }
\end_layout

\begin_layout LyX-Code
}
\end_layout

\begin_layout Subsection
Generating classes
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
classes!generating
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Generating a class with the tree API simply consists in creating a 
\family typewriter
ClassNode
\family default
 object and in initializing its fields.
 For instance the 
\family typewriter
Comparable
\family default
 interface in section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Generating-classes-CoreAPI"

\end_inset

 can be built as follows, with approximatively the same amount of code as
 in section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Generating-classes-CoreAPI"

\end_inset

:
\end_layout

\begin_layout LyX-Code
ClassNode cn = new ClassNode();
\end_layout

\begin_layout LyX-Code
cn.version = V1_5;
\end_layout

\begin_layout LyX-Code
cn.access = ACC_PUBLIC + ACC_ABSTRACT + ACC_INTERFACE;
\end_layout

\begin_layout LyX-Code
cn.name = "pkg/Comparable";
\end_layout

\begin_layout LyX-Code
cn.superName = "java/lang/Object";
\end_layout

\begin_layout LyX-Code
cn.interfaces.add("pkg/Mesurable");
\end_layout

\begin_layout LyX-Code
cn.fields.add(new FieldNode(ACC_PUBLIC + ACC_FINAL + ACC_STATIC,
\end_layout

\begin_layout LyX-Code
    "LESS", "I", null, new Integer(-1)));
\end_layout

\begin_layout LyX-Code
cn.fields.add(new FieldNode(ACC_PUBLIC + ACC_FINAL + ACC_STATIC,
\end_layout

\begin_layout LyX-Code
    "EQUAL", "I", null, new Integer(0)));
\end_layout

\begin_layout LyX-Code
cn.fields.add(new FieldNode(ACC_PUBLIC + ACC_FINAL + ACC_STATIC,
\end_layout

\begin_layout LyX-Code
    "GREATER", "I", null, new Integer(1)));
\end_layout

\begin_layout LyX-Code
cn.methods.add(new MethodNode(ACC_PUBLIC + ACC_ABSTRACT,
\end_layout

\begin_layout LyX-Code
    "compareTo", "(Ljava/lang/Object;)I", null, null));
\end_layout

\begin_layout Standard
Using the tree API to generate a class takes about 
\begin_inset Formula $30\%$
\end_inset

 more time (see Appendix 
\begin_inset CommandInset ref
LatexCommand ref
reference "app:Bytecode-instructions"

\end_inset

) and consumes more memory than using the core API.
 But it makes it possible to generate the class elements in any order, which
 can be convenient in some cases.
\end_layout

\begin_layout Subsection
Adding and removing class members
\end_layout

\begin_layout Standard
Adding and removing class members simply consists in adding or removing
 elements in the 
\family typewriter
fields
\family default
 or 
\family typewriter
methods
\family default
 lists of a 
\family typewriter
ClassNode
\family default
 object.
 For example, if we define the 
\family typewriter
ClassTransformer
\family default

\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
ClassTransformer@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
texttt{ClassTransformer}
\end_layout

\end_inset


\end_layout

\end_inset

 class as follows, in order to be able to compose class transformers easily:
\end_layout

\begin_layout LyX-Code
public class ClassTransformer {
\end_layout

\begin_layout LyX-Code
  protected ClassTransformer ct;
\end_layout

\begin_layout LyX-Code
  public ClassTransformer(ClassTransformer ct) {
\end_layout

\begin_layout LyX-Code
    this.ct = ct;
\end_layout

\begin_layout LyX-Code
  }
\end_layout

\begin_layout LyX-Code
  public void transform(ClassNode cn) {
\end_layout

\begin_layout LyX-Code
    if (ct != null) {
\end_layout

\begin_layout LyX-Code
      ct.transform(cn);
\end_layout

\begin_layout LyX-Code
    }
\end_layout

\begin_layout LyX-Code
  }
\end_layout

\begin_layout LyX-Code
}
\end_layout

\begin_layout Standard
then the 
\family typewriter
RemoveMethodAdapter
\family default

\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
classes!removing members
\end_layout

\end_inset


\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
methods!removing
\end_layout

\end_inset

 in section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Removing-class-members-coreAPI"

\end_inset

 can be implemented as follows:
\end_layout

\begin_layout LyX-Code
public class RemoveMethodTransformer extends ClassTransformer {
\end_layout

\begin_layout LyX-Code
  private String methodName;
\end_layout

\begin_layout LyX-Code
  private String methodDesc;
\end_layout

\begin_layout LyX-Code
  public RemoveMethodTransformer(ClassTransformer ct,
\end_layout

\begin_layout LyX-Code
      String methodName, String methodDesc) {
\end_layout

\begin_layout LyX-Code
    super(ct);
\end_layout

\begin_layout LyX-Code
    this.methodName = methodName;
\end_layout

\begin_layout LyX-Code
    this.methodDesc = methodDesc;
\end_layout

\begin_layout LyX-Code
  }
\end_layout

\begin_layout LyX-Code
  @Override public void transform(ClassNode cn) {
\end_layout

\begin_layout LyX-Code
    
\series bold
Iterator<MethodNode> i = cn.methods.iterator();
\end_layout

\begin_layout LyX-Code
    while (i.hasNext()) {
\end_layout

\begin_layout LyX-Code
      MethodNode mn = i.next();
\end_layout

\begin_layout LyX-Code
      
\series bold
if (methodName.equals(mn.name) && methodDesc.equals(mn.desc)) {
\end_layout

\begin_layout LyX-Code
 
\series bold
       i.remove();
\end_layout

\begin_layout LyX-Code
 
\series bold
     }
\end_layout

\begin_layout LyX-Code
    }
\end_layout

\begin_layout LyX-Code
    super.transform(cn);
\end_layout

\begin_layout LyX-Code
  }
\end_layout

\begin_layout LyX-Code
}
\end_layout

\begin_layout Standard
As can be seen the main difference with the core API is that you need to
 iterate over all methods, while you don't need to do so with the core API
 (this is done for you in 
\family typewriter
ClassReader
\family default
).
 In fact this difference is valid for almost all tree based transformations.
 For instance the 
\family typewriter
AddFieldAdapter
\family default

\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
classes!adding members
\end_layout

\end_inset


\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
fields!adding
\end_layout

\end_inset

 of section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Adding-class-members-coreAPI"

\end_inset

 also needs an iterator when implemented with the tree API:
\end_layout

\begin_layout LyX-Code
public class AddFieldTransformer extends ClassTransformer {
\end_layout

\begin_layout LyX-Code
  private int fieldAccess;
\end_layout

\begin_layout LyX-Code
  private String fieldName;
\end_layout

\begin_layout LyX-Code
  private String fieldDesc;
\end_layout

\begin_layout LyX-Code
  public AddFieldTransformer(ClassTransformer ct, int fieldAccess,
\end_layout

\begin_layout LyX-Code
      String fieldName, String fieldDesc) {
\end_layout

\begin_layout LyX-Code
    super(ct);
\end_layout

\begin_layout LyX-Code
    this.fieldAccess = fieldAccess;
\end_layout

\begin_layout LyX-Code
    this.fieldName = fieldName;
\end_layout

\begin_layout LyX-Code
    this.fieldDesc = fieldDesc;
\end_layout

\begin_layout LyX-Code
  }
\end_layout

\begin_layout LyX-Code
  @Override public void transform(ClassNode cn) {
\end_layout

\begin_layout LyX-Code
    boolean isPresent = false;
\end_layout

\begin_layout LyX-Code
    
\series bold
for (FieldNode fn : cn.fields) {
\end_layout

\begin_layout LyX-Code
      
\series bold
if (fieldName.equals(fn.name)) {
\end_layout

\begin_layout LyX-Code
 
\series bold
       isPresent = true;
\end_layout

\begin_layout LyX-Code
 
\series bold
       break;
\end_layout

\begin_layout LyX-Code
 
\series bold
     }
\end_layout

\begin_layout LyX-Code
    }
\end_layout

\begin_layout LyX-Code
    
\series bold
if (!isPresent) {
\end_layout

\begin_layout LyX-Code
 
\series bold
     cn.fields.add(new FieldNode(fieldAccess, fieldName, fieldDesc,
\end_layout

\begin_layout LyX-Code
 
\series bold
         null, null));
\end_layout

\begin_layout LyX-Code
 
\series bold
   }
\end_layout

\begin_layout LyX-Code
    super.transform(cn);
\end_layout

\begin_layout LyX-Code
  }
\end_layout

\begin_layout LyX-Code
}
\end_layout

\begin_layout Standard
Like for class generation, using the tree API to transform classes takes
 more time and consumes more memory than using the core API.
 But it makes it possible to implement some transformations more easily.
 This is the case, for example, of a transformation that adds to a class
 an annotation containing a digital signature of its content.
 With the core API the digital signature can be computed only when all the
 class has been visited, but then it is too late to add an annotation containing
 it, because annotations must be visited before class members.
 With the tree API this problem disappears because there is no such constraint
 in this case.
\end_layout

\begin_layout Standard
In fact it 
\emph on
is
\emph default
 possible to implement the 
\family typewriter
AddDigitialSignature
\family default
 example with the core API, but then the class must be transformed in two
 
\emph on
passes
\emph default

\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
transformation pass
\end_layout

\end_inset

.
 During the first pass the class is visited with a 
\family typewriter
ClassReader
\family default
 (and no 
\family typewriter
ClassWriter
\family default
), in order to compute the digital signature based on the class content.
 During the second pass the same 
\family typewriter
ClassReader
\family default
 is reused to do a second visit of the class, this time with an 
\family typewriter
AddAnnotationAdapter
\family default
 chained to a 
\family typewriter
ClassWriter
\family default
.
 By generalizing this argument we see that, in fact, any transformation
 can be implemented with the core API alone, by using several passes if
 necessary.
 But this increases the transformation code complexity, this requires to
 store state between passes (which can be as complex as a full tree representati
on!), and parsing the class several times has a cost, which must be compared
 to the cost of constructing the corresponding 
\family typewriter
ClassNode
\family default
.
 
\end_layout

\begin_layout Standard
The conclusion is that 
\emph on
the tree API is generally used for transformations that cannot be implemented
 in one pass with the core API
\emph default
.
 But there are of course exceptions.
 For example an obfuscator cannot be implemented in one pass, because you
 cannot transform classes before the mapping from original to obfuscated
 names is fully constructed, which requires to parse all classes.
 But the tree API is not a good solution either, because it would require
 keeping in memory the object representation of 
\emph on
all
\emph default
 the classes to obfuscate.
 In this case it is better to use the core API with two passes: one to compute
 the mapping between original and obfuscated names (a simple hash table
 that requires much less memory than a full object representation of all
 the classes), and one to transform the classes based on this mapping.
\end_layout

\begin_layout Section
Components composition
\end_layout

\begin_layout Standard
So far we have only seen how to create and transform 
\family typewriter
ClassNode
\family default
 objects, but we haven't seen how to construct a 
\family typewriter
ClassNode
\family default
 from the byte array representation of a class or, vice versa, to construct
 this byte array from a 
\family typewriter
ClassNode
\family default
.
 In fact this is done by composing the core API and tree API components,
 as explained in this section.
\end_layout

\begin_layout Subsection
Presentation
\end_layout

\begin_layout Standard
In addition to the fields shown in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:The-ClassNode-class"

\end_inset

, the 
\family typewriter
ClassNode
\family default
 class extends the 
\family typewriter
ClassVisitor
\family default
 class, and also provides an 
\family typewriter
accept
\family default
 method that takes a 
\family typewriter
ClassVisitor
\family default
 as parameter.
 The 
\family typewriter
accept
\family default
 method generates events based on the 
\family typewriter
ClassNode
\family default
 field values, while the 
\family typewriter
ClassVisitor
\family default
 methods perform the inverse operation, i.e.
 set the 
\family typewriter
ClassNode
\family default
 fields based on the received events:
\end_layout

\begin_layout LyX-Code
public class ClassNode 
\series bold
extends ClassVisitor
\series default
 {
\end_layout

\begin_layout LyX-Code
  ...
\end_layout

\begin_layout LyX-Code
  public void visit(int version, int access, String name,
\end_layout

\begin_layout LyX-Code
      String signature, String superName, String[] interfaces[]) {
\end_layout

\begin_layout LyX-Code
    this.version = version;
\end_layout

\begin_layout LyX-Code
    this.access = access;
\end_layout

\begin_layout LyX-Code
    this.name = name;
\end_layout

\begin_layout LyX-Code
    this.signature = signature;
\end_layout

\begin_layout LyX-Code
    ...
\end_layout

\begin_layout LyX-Code
  }
\end_layout

\begin_layout LyX-Code
  ...
\end_layout

\begin_layout LyX-Code
  public void 
\series bold
accept
\series default
(ClassVisitor cv) {
\end_layout

\begin_layout LyX-Code
    cv.visit(version, access, name, signature, ...);
\end_layout

\begin_layout LyX-Code
    ...
\end_layout

\begin_layout LyX-Code
  }
\end_layout

\begin_layout LyX-Code
}
\end_layout

\begin_layout Standard
Constructing a 
\family typewriter
ClassNode
\family default
 from a byte array can therefore be done by composing it with a 
\family typewriter
ClassReader
\family default
, so that the events generated by the 
\family typewriter
ClassReader
\family default
 are consumed by the 
\family typewriter
ClassNode
\family default
 component, resulting in the initialization of its fields (as can be seen
 from the above code):
\end_layout

\begin_layout LyX-Code
ClassNode cn = new ClassNode();
\end_layout

\begin_layout LyX-Code
ClassReader cr = new ClassReader(...);
\end_layout

\begin_layout LyX-Code
cr.accept(cn, 0);
\end_layout

\begin_layout Standard
Symetrically a 
\family typewriter
ClassNode
\family default
 can be converted to its byte array representation by composing it with
 a 
\family typewriter
ClassWriter
\family default
, so that the events generated by the 
\family typewriter
ClassNode
\family default
's 
\family typewriter
accept
\family default
 method are consumed by the 
\family typewriter
ClassWriter
\family default
:
\end_layout

\begin_layout LyX-Code
ClassWriter cw = new ClassWriter(0);
\end_layout

\begin_layout LyX-Code
cn.accept(cw);
\end_layout

\begin_layout LyX-Code
byte[] b = cw.toByteArray();
\end_layout

\begin_layout Subsection
Patterns
\end_layout

\begin_layout Standard
Transforming a class with the tree API can be done by putting these elements
 together:
\end_layout

\begin_layout LyX-Code
ClassNode cn = new ClassNode(ASM4);
\end_layout

\begin_layout LyX-Code
ClassReader cr = new ClassReader(...);
\end_layout

\begin_layout LyX-Code
cr.accept(cn, 0);
\end_layout

\begin_layout LyX-Code
...
 // here transform cn as you want
\end_layout

\begin_layout LyX-Code
ClassWriter cw = new ClassWriter(0);
\end_layout

\begin_layout LyX-Code
cn.accept(cw);
\end_layout

\begin_layout LyX-Code
byte[] b = cw.toByteArray();
\end_layout

\begin_layout Standard
It is also possible to use a tree based class transformer like a class adapter
 with the core API.
 Two common patterns are used for that.
 The first one uses inheritance:
\end_layout

\begin_layout LyX-Code
public class MyClassAdapter 
\series bold
extends ClassNode
\series default
 {
\end_layout

\begin_layout LyX-Code
  public MyClassAdapter(ClassVisitor cv) {
\end_layout

\begin_layout LyX-Code
    super(ASM4);
\end_layout

\begin_layout LyX-Code
    this.cv = cv;
\end_layout

\begin_layout LyX-Code
  }
\end_layout

\begin_layout LyX-Code
  @Override public void visitEnd() {
\end_layout

\begin_layout LyX-Code
    // put your transformation code here
\end_layout

\begin_layout LyX-Code
    
\series bold
accept(cv);
\end_layout

\begin_layout LyX-Code
  }
\end_layout

\begin_layout LyX-Code
}
\end_layout

\begin_layout Standard
When this class adapter is used in a classical transformation chain:
\end_layout

\begin_layout LyX-Code
ClassWriter cw = new ClassWriter(0);
\end_layout

\begin_layout LyX-Code
ClassVisitor ca = new MyClassAdapter(cw);
\end_layout

\begin_layout LyX-Code
ClassReader cr = new ClassReader(...);
\end_layout

\begin_layout LyX-Code
cr.accept(ca, 0);
\end_layout

\begin_layout LyX-Code
byte[] b = cw.toByteArray();
\end_layout

\begin_layout Standard
the events generated by 
\family typewriter
cr
\family default
 are consumed by the 
\family typewriter
ClassNode
\family default
 
\family typewriter
ca
\family default
, which results in the initialization of the fields of this object.
 At the end, when the 
\family typewriter
visitEnd
\family default
 event is consumed, 
\family typewriter
ca
\family default
 performs the transformation and, by calling its 
\family typewriter
accept
\family default
 method, generates new events corresponding to the transformed class, which
 are consumed by 
\family typewriter
cw
\family default
.
 The corresponding sequence diagram is show in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Sequence-diagram-for-MyClassAdapter"

\end_inset

, if we suppose that 
\family typewriter
ca
\family default
 changes the class version.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename figures/classnode.eps
	scale 80

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Sequence-diagram-for-MyClassAdapter"

\end_inset

Sequence diagram for 
\family typewriter
MyClassAdapter
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
When compared to the sequence diagram for 
\family typewriter
ChangeVersionAdapter
\family default
 in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:ChangeVersionAdapter"

\end_inset

, we can see that the events between 
\family typewriter
ca
\family default
 and 
\family typewriter
cw
\family default
 occur after the events between 
\family typewriter
cr
\family default
 and 
\family typewriter
ca
\family default
, instead of simultaneously with a normal class adapter.
 In fact this happens with all tree based transformations, and explains
 why they are less constrained than event based ones.
\end_layout

\begin_layout Standard
The second pattern that can be used to acheive the same result, with a similar
 sequence diagram, uses delegation instead of inheritance:
\end_layout

\begin_layout LyX-Code
public class MyClassAdapter extends ClassVisitor {
\end_layout

\begin_layout LyX-Code
  ClassVisitor next;
\end_layout

\begin_layout LyX-Code
  public MyClassAdapter(ClassVisitor cv) {
\end_layout

\begin_layout LyX-Code
    super(ASM4, 
\series bold
new ClassNode()
\series default
);
\end_layout

\begin_layout LyX-Code
    next = cv;
\end_layout

\begin_layout LyX-Code
  }
\end_layout

\begin_layout LyX-Code
  @Override public void visitEnd() {
\end_layout

\begin_layout LyX-Code
    ClassNode cn = (ClassNode) cv;
\end_layout

\begin_layout LyX-Code
    // put your transformation code here
\end_layout

\begin_layout LyX-Code
    
\series bold
cn.accept(next);
\end_layout

\begin_layout LyX-Code
  }
\end_layout

\begin_layout LyX-Code
}
\end_layout

\begin_layout Standard
This pattern uses two objects instead of one, but works exactly in the same
 way as the first pattern: the received events are used to construct a 
\family typewriter
ClassNode
\family default
, which is transformed and converted back to an event based representation
 when the last event is received.
\end_layout

\begin_layout Standard
Both patterns allow you to compose your tree based class adapters with event
 based adapters.
 They can also be used to compose tree based adapters together, but if you
 only need to compose tree based adapters this is not the best solution:
 in this case using classes such as 
\family typewriter
ClassTransformer
\family default
 will avoid unnecessary conversions between the two representations.
\end_layout

\begin_layout Chapter
Methods
\end_layout

\begin_layout Standard
This chapter explains how to generate and transform methods with the ASM
 tree API.
 It starts with a presentation of the tree API alone, with some illustrative
 examples, and then presents how to compose it with the core API.
 The tree API for generics and annotations is presented in the next chapter.
\end_layout

\begin_layout Section
Interfaces and components
\end_layout

\begin_layout Subsection
Presentation
\begin_inset CommandInset label
LatexCommand label
name "sub:Methods-treeAPI"

\end_inset


\end_layout

\begin_layout Standard
The ASM tree API for generating and transforming methods is based on the
 
\family typewriter
MethodNode
\family default
 class (see Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:The-MethodNode-class"

\end_inset

).
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout LyX-Code
public class 
\series bold
MethodNode
\series default
 ...
 {
\end_layout

\begin_layout LyX-Code
  public int access;
\end_layout

\begin_layout LyX-Code
  public String name;
\end_layout

\begin_layout LyX-Code
  public String desc;
\end_layout

\begin_layout LyX-Code
  public String signature;
\end_layout

\begin_layout LyX-Code
  public List<String> exceptions;
\end_layout

\begin_layout LyX-Code
  public List<AnnotationNode> visibleAnnotations;
\end_layout

\begin_layout LyX-Code
  public List<AnnotationNode> invisibleAnnotations;
\end_layout

\begin_layout LyX-Code
  public List<Attribute> attrs;
\end_layout

\begin_layout LyX-Code
  public Object annotationDefault;
\end_layout

\begin_layout LyX-Code
  public List<AnnotationNode>[] visibleParameterAnnotations;
\end_layout

\begin_layout LyX-Code
  public List<AnnotationNode>[] invisibleParameterAnnotations;
\end_layout

\begin_layout LyX-Code
  public InsnList instructions;
\end_layout

\begin_layout LyX-Code
  public List<TryCatchBlockNode> tryCatchBlocks;
\end_layout

\begin_layout LyX-Code
  public List<LocalVariableNode> localVariables;
\end_layout

\begin_layout LyX-Code
  public int maxStack;
\end_layout

\begin_layout LyX-Code
  public int maxLocals;
\end_layout

\begin_layout LyX-Code
}
\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:The-MethodNode-class"

\end_inset

The 
\family typewriter
MethodNode
\family default

\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
MethodNode@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
texttt{MethodNode}
\end_layout

\end_inset


\end_layout

\end_inset

 class (only fields are shown)
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Most of the fields of this class are similar to the corresponding fields
 in 
\family typewriter
ClassNode
\family default
.
 The most important ones are the last ones, starting from the 
\family typewriter
instructions
\family default
 field.
 This field is a list of instructions, managed with an 
\family typewriter
InsnList
\family default

\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
InsnList@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
texttt{InsnList}
\end_layout

\end_inset


\end_layout

\end_inset

 object, whose public API is the following:
\end_layout

\begin_layout LyX-Code
public class InsnList { // public accessors omitted
\end_layout

\begin_layout LyX-Code
  int size();
\end_layout

\begin_layout LyX-Code
  AbstractInsnNode getFirst();
\end_layout

\begin_layout LyX-Code
  AbstractInsnNode getLast();
\end_layout

\begin_layout LyX-Code
  AbstractInsnNode get(int index);
\end_layout

\begin_layout LyX-Code
  boolean contains(AbstractInsnNode insn);
\end_layout

\begin_layout LyX-Code
  int indexOf(AbstractInsnNode insn);
\end_layout

\begin_layout LyX-Code
  void accept(MethodVisitor mv);
\end_layout

\begin_layout LyX-Code
  ListIterator iterator();
\end_layout

\begin_layout LyX-Code
  ListIterator iterator(int index);
\end_layout

\begin_layout LyX-Code
  AbstractInsnNode[] toArray();
\end_layout

\begin_layout LyX-Code
  void set(AbstractInsnNode location, AbstractInsnNode insn);
\end_layout

\begin_layout LyX-Code
  void add(AbstractInsnNode insn);
\end_layout

\begin_layout LyX-Code
  void add(InsnList insns);
\end_layout

\begin_layout LyX-Code
  void insert(AbstractInsnNode insn);
\end_layout

\begin_layout LyX-Code
  void insert(InsnList insns);
\end_layout

\begin_layout LyX-Code
  void insert(AbstractInsnNode location, AbstractInsnNode insn);
\end_layout

\begin_layout LyX-Code
  void insert(AbstractInsnNode location, InsnList insns);
\end_layout

\begin_layout LyX-Code
  void insertBefore(AbstractInsnNode location, AbstractInsnNode insn);
\end_layout

\begin_layout LyX-Code
  void insertBefore(AbstractInsnNode location, InsnList insns);
\end_layout

\begin_layout LyX-Code
  void remove(AbstractInsnNode insn);
\end_layout

\begin_layout LyX-Code
  void clear();
\end_layout

\begin_layout LyX-Code
}
\end_layout

\begin_layout Standard
An 
\family typewriter
InsnList
\family default
 is a doubly linked list of instructions, 
\emph on
whose links are stored in the
\emph default
 
\family typewriter
AbstractInsnNode
\family default
 
\emph on
objects themselves
\emph default
.
 This point is extremely important because it has many consequences on the
 way instruction objects and instruction lists must be used:
\end_layout

\begin_layout Itemize
An 
\family typewriter
AbstractInsnNode
\family default
 object cannot appear more than once in an instruction list.
\end_layout

\begin_layout Itemize
An 
\family typewriter
AbstractInsnNode
\family default
 object cannot belong to several instruction lists at the same time.
\end_layout

\begin_layout Itemize
As a consequence, adding an 
\family typewriter
AbstractInsnNode
\family default
 to a list requires removing it from the list to which it was belonging,
 if any.
\end_layout

\begin_layout Itemize
As another consequence, adding all the elements of a list into another one
 clears the first list.
\end_layout

\begin_layout Standard
The 
\family typewriter
AbstractInsnNode
\family default

\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
AbstractInsnNode@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
texttt{AbstractInsnNode}
\end_layout

\end_inset


\end_layout

\end_inset

 class is the super class of the classes that represent bytecode instructions.
 Its public API is the following:
\end_layout

\begin_layout LyX-Code
public abstract class AbstractInsnNode {
\end_layout

\begin_layout LyX-Code
  public int getOpcode();
\end_layout

\begin_layout LyX-Code
  public int getType();
\end_layout

\begin_layout LyX-Code
  public AbstractInsnNode getPrevious();
\end_layout

\begin_layout LyX-Code
  public AbstractInsnNode getNext();
\end_layout

\begin_layout LyX-Code
  public void accept(MethodVisitor cv);
\end_layout

\begin_layout LyX-Code
  public AbstractInsnNode clone(Map labels);
\end_layout

\begin_layout LyX-Code
}
\end_layout

\begin_layout Standard
Its sub classes are 
\family typewriter
\emph on
Xxx
\emph default
InsnNode
\family default
 classes corresponding to the 
\family typewriter
visit
\emph on
Xxx
\emph default
Insn
\family default
 methods of the 
\family typewriter
MethodVisitor
\family default
 interface, and are all build in the same way.
 For instance the 
\family typewriter
VarInsnNode
\family default
 class corresponds to the 
\family typewriter
visitVarInsn
\family default
 method and has the following structure:
\end_layout

\begin_layout LyX-Code
public class VarInsnNode extends AbstractInsnNode {
\end_layout

\begin_layout LyX-Code
  public int var;
\end_layout

\begin_layout LyX-Code
  public VarInsnNode(int opcode, int var) {
\end_layout

\begin_layout LyX-Code
    super(opcode);
\end_layout

\begin_layout LyX-Code
    this.var = var;
\end_layout

\begin_layout LyX-Code
  }
\end_layout

\begin_layout LyX-Code
  ...
\end_layout

\begin_layout LyX-Code
}
\end_layout

\begin_layout Standard
Labels and frames, as well as line numbers, although they are not instructions,
 are also represented by sub classes of the 
\family typewriter
AbstractInsnNode
\family default
 classes, namely the 
\family typewriter
LabelNode
\family default
, 
\family typewriter
FrameNode
\family default
 and 
\family typewriter
LineNumberNode
\family default
 classes.
 This allows them to be inserted just before the corresponding real instructions
 in the list, as in the core API (where labels and frames are visited just
 before their corresponding instruction).
 It is therefore easy to find the target of a jump instruction, with the
 
\family typewriter
getNext
\family default
 method provided by the 
\family typewriter
AbstractInsnNode
\family default
 class: this is the first 
\family typewriter
AbstractInsnNode
\family default
 after the target label that is a real instruction.
 Another consequence is that, like with the core API, removing an instruction
 does not break jump instructions, as long as labels remain unchanged.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
All the methods of the 
\family typewriter
InsnList
\family default
 class execute in constant time (i.e.
 do not depend on the size of the list), except the methods based on instruction
s indexes: these methods scan the list to compute their result, and so execute
 in 
\begin_inset Formula $O(n)$
\end_inset

 time, where 
\begin_inset Formula $n$
\end_inset

 is the size of the list (in fact they build a cache to reply to subsequent
 requests in constant time, but this cache is invalidated each time the
 list is modified).
 It is therefore recommended to not use the index based methods.
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Generating methods
\end_layout

\begin_layout Standard
Generating a method
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
methods!generating
\end_layout

\end_inset

 with the tree API consists in creating a 
\family typewriter
MethodNode
\family default
 and in initializing its fields.
 The most interesting part is the generation of the method's code.
 As an example, the 
\family typewriter
checkAndSetF
\family default
 method of section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Frames"

\end_inset

 can be generated as follows:
\end_layout

\begin_layout LyX-Code
MethodNode mn = new MethodNode(...);
\end_layout

\begin_layout LyX-Code
InsnList il = mn.instructions;
\end_layout

\begin_layout LyX-Code
il.add(new VarInsnNode(ILOAD, 1));
\end_layout

\begin_layout LyX-Code
LabelNode label = new LabelNode();
\end_layout

\begin_layout LyX-Code
il.add(new JumpInsnNode(IFLT, label));
\end_layout

\begin_layout LyX-Code
il.add(new VarInsnNode(ALOAD, 0));
\end_layout

\begin_layout LyX-Code
il.add(new VarInsnNode(ILOAD, 1));
\end_layout

\begin_layout LyX-Code
il.add(new FieldInsnNode(PUTFIELD, "pkg/Bean", "f", "I"));
\end_layout

\begin_layout LyX-Code
LabelNode end = new LabelNode();
\end_layout

\begin_layout LyX-Code
il.add(new JumpInsnNode(GOTO, end));
\end_layout

\begin_layout LyX-Code
il.add(label);
\end_layout

\begin_layout LyX-Code
il.add(new FrameNode(F_SAME, 0, null, 0, null));
\end_layout

\begin_layout LyX-Code
il.add(new TypeInsnNode(NEW, "java/lang/IllegalArgumentException"));
\end_layout

\begin_layout LyX-Code
il.add(new InsnNode(DUP));
\end_layout

\begin_layout LyX-Code
il.add(new MethodInsnNode(INVOKESPECIAL,
\end_layout

\begin_layout LyX-Code
    "java/lang/IllegalArgumentException", "<init>", "()V"));
\end_layout

\begin_layout LyX-Code
il.add(new InsnNode(ATHROW));
\end_layout

\begin_layout LyX-Code
il.add(end);
\end_layout

\begin_layout LyX-Code
il.add(new FrameNode(F_SAME, 0, null, 0, null));
\end_layout

\begin_layout LyX-Code
il.add(new InsnNode(RETURN));
\end_layout

\begin_layout LyX-Code
mn.maxStack = 2;
\end_layout

\begin_layout LyX-Code
mn.maxLocals = 2;
\end_layout

\begin_layout Standard
Like with classes, using the tree API to generate methods takes more time
 and consumes more memory than using the core API.
 But it makes it possible to generate their content in any order.
 In particular the instructions can be generated in a different order than
 the sequential one, which can be useful in some cases.
\end_layout

\begin_layout Standard
Consider for example an expression compiler.
 Normaly an expression 
\begin_inset Formula $e_{1}+e_{2}$
\end_inset

 is compiled by emitting code for 
\begin_inset Formula $e_{\text{1}}$
\end_inset

, then emitting code for 
\begin_inset Formula $e_{2}$
\end_inset

, and then emitting code for adding the two values.
 But if 
\begin_inset Formula $e_{\text{1}}$
\end_inset

 and 
\begin_inset Formula $e_{2}$
\end_inset

 are not of the same primitive type, a cast must be inserted just after
 the code for 
\begin_inset Formula $e_{\text{1}}$
\end_inset

, and another one just after the code for 
\begin_inset Formula $e_{\text{2}}$
\end_inset

.
 However the exact casts that must be emitted depend on 
\begin_inset Formula $e_{\text{1}}$
\end_inset

 
\emph on
and
\emph default
 
\begin_inset Formula $e_{\text{2}}$
\end_inset

 types.
 
\end_layout

\begin_layout Standard
Now, if the type of an expression is returned by the method that emits the
 compiled code, we have a problem if we are using the core API: the cast
 that must be inserted after 
\begin_inset Formula $e_{\text{1}}$
\end_inset

 is known only after 
\begin_inset Formula $e_{\text{2}}$
\end_inset

 has been compiled, but this is too late because we cannot insert an instruction
 between previously visited instructions
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
the solution is to compile expressions in two passes: one to compute the
 expression types and the casts that must be inserted, and one to emit the
 compiled code.
\end_layout

\end_inset

.
 With the tree API this problem does not exist.
 For example, one possibility is to use a 
\family typewriter
compile
\family default
 method such as:
\end_layout

\begin_layout LyX-Code
public Type compile(InsnList output) {
\end_layout

\begin_layout LyX-Code
  InsnList il1 = new InsnList();
\end_layout

\begin_layout LyX-Code
  InsnList il2 = new InsnList();
\end_layout

\begin_layout LyX-Code
  Type t1 = e1.compile(il1);
\end_layout

\begin_layout LyX-Code
  Type t2 = e2.compile(il2);
\end_layout

\begin_layout LyX-Code
  Type t = ...; // compute common super type of t1 and t2
\end_layout

\begin_layout LyX-Code
  output.addAll(il1); // done in constant time
\end_layout

\begin_layout LyX-Code
  output.add(...); // cast instruction from t1 to t
\end_layout

\begin_layout LyX-Code
  output.addAll(il2); // done in constant time
\end_layout

\begin_layout LyX-Code
  output.add(...); // cast instruction from t2 to t
\end_layout

\begin_layout LyX-Code
  output.add(new InsnNode(t.getOpcode(IADD)));
\end_layout

\begin_layout LyX-Code
  return t;
\end_layout

\begin_layout LyX-Code
}
\end_layout

\begin_layout Subsection
Transforming methods
\end_layout

\begin_layout Standard
Transforming a method
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
methods!transforming
\end_layout

\end_inset

 with the tree API simply consists in modifying the fields of a 
\family typewriter
MethodNode
\family default
 object, and in particular the 
\family typewriter
instructions
\family default
 list.
 Although this list can be modified in arbitray ways, a common pattern is
 to modify it while iterating over it.
 Indeed, unlike with the general 
\family typewriter
ListIterator
\family default
 contract, the 
\family typewriter
ListIterator
\family default
 returned by an 
\family typewriter
InsnList
\family default
 supports many conccurrent
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
i.e.
 modifications interleaved with calls to 
\family typewriter
Iterator.next
\family default
.
 True, multi-threaded concurrent modifications are not supported.
\end_layout

\end_inset

 list modifications.
 In fact you can use the 
\family typewriter
InsnList
\family default
 methods to remove one or more elements before and including the current
 one, to remove one or more elements after the 
\emph on
next
\emph default
 element (i.e.
 not just after the current element, but after its successor), or to insert
 one or more elements before the current one or after its successor.
 These changes will be reflected in the iterator, i.e.
 the elements inserted (resp.
 removed) after the next element will be seen (resp.
 not seen) in the iterator.
\end_layout

\begin_layout Standard
Another common pattern to modify an instruction list, when you need to insert
 several instructions after an instruction 
\emph on
i
\emph default
 inside a list, is to add these new instructions in a temporary instruction
 list, and to insert this temporary list inside the main one in one step:
\end_layout

\begin_layout LyX-Code
InsnList il = new InsnList();
\end_layout

\begin_layout LyX-Code
il.add(...);
\end_layout

\begin_layout LyX-Code
...
\end_layout

\begin_layout LyX-Code
il.add(...);
\end_layout

\begin_layout LyX-Code
mn.instructions.insert(i, il);
\end_layout

\begin_layout Standard
Inserting the instructions one by one is also possible but more cumbersome,
 because the insertion point must be updated after each insertion.
\end_layout

\begin_layout Subsection
Stateless and statefull transformations
\end_layout

\begin_layout Standard
Let's take some examples to see concretely how methods can be transformed
 with the tree API.
 In order to see the differences between the core and the tree API, it is
 interesting to reimplement the 
\family typewriter
AddTimerAdapter
\family default
 example of section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Stateless-transformations"

\end_inset

 and the 
\family typewriter
RemoveGetFieldPutFieldAdapter
\family default
 of section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Statefull-transformations"

\end_inset

.
 The timer example can be implemented as follows:
\end_layout

\begin_layout LyX-Code
public class AddTimerTransformer extends ClassTransformer {
\end_layout

\begin_layout LyX-Code
  public AddTimerTransformer(ClassTransformer ct) {
\end_layout

\begin_layout LyX-Code
    super(ct);
\end_layout

\begin_layout LyX-Code
  }
\end_layout

\begin_layout LyX-Code
  @Override public void transform(ClassNode cn) {
\end_layout

\begin_layout LyX-Code
    for (MethodNode mn : (List<MethodNode>) cn.methods) {      
\end_layout

\begin_layout LyX-Code
      if ("<init>".equals(mn.name) || "<clinit>".equals(mn.name)) {
\end_layout

\begin_layout LyX-Code
        continue;
\end_layout

\begin_layout LyX-Code
      }
\end_layout

\begin_layout LyX-Code
      
\series bold
InsnList insns = mn.instructions;
\end_layout

\begin_layout LyX-Code
      if (insns.size() == 0) {
\end_layout

\begin_layout LyX-Code
        continue;
\end_layout

\begin_layout LyX-Code
      }
\end_layout

\begin_layout LyX-Code
 
\series bold
     Iterator<AbstractInsnNode> j = insns.iterator();
\end_layout

\begin_layout LyX-Code
 
\series bold
     while (j.hasNext()) {
\end_layout

\begin_layout LyX-Code
 
\series bold
       AbstractInsnNode in = j.next();
\end_layout

\begin_layout LyX-Code
        int op = in.getOpcode();
\end_layout

\begin_layout LyX-Code
        if ((op >= IRETURN && op <= RETURN) || op == ATHROW) {
\end_layout

\begin_layout LyX-Code
          InsnList il = new InsnList();
\end_layout

\begin_layout LyX-Code
          il.add(new FieldInsnNode(GETSTATIC, cn.name, "timer", "J"));
\end_layout

\begin_layout LyX-Code
          il.add(new MethodInsnNode(INVOKESTATIC, "java/lang/System",
\end_layout

\begin_layout LyX-Code
              "currentTimeMillis", "()J"));
\end_layout

\begin_layout LyX-Code
          il.add(new InsnNode(LADD));
\end_layout

\begin_layout LyX-Code
          il.add(new FieldInsnNode(PUTSTATIC, cn.name, "timer", "J"));
\end_layout

\begin_layout LyX-Code
          
\series bold
insns.insert(in.getPrevious(), il);
\end_layout

\begin_layout LyX-Code
        }
\end_layout

\begin_layout LyX-Code
      }
\end_layout

\begin_layout LyX-Code
      InsnList il = new InsnList();
\end_layout

\begin_layout LyX-Code
      il.add(new FieldInsnNode(GETSTATIC, cn.name, "timer", "J"));
\end_layout

\begin_layout LyX-Code
      il.add(new MethodInsnNode(INVOKESTATIC, "java/lang/System",
\end_layout

\begin_layout LyX-Code
          "currentTimeMillis", "()J"));
\end_layout

\begin_layout LyX-Code
      il.add(new InsnNode(LSUB));
\end_layout

\begin_layout LyX-Code
      il.add(new FieldInsnNode(PUTSTATIC, cn.name, "timer", "J"));
\end_layout

\begin_layout LyX-Code
      
\series bold
insns.insert(il);
\end_layout

\begin_layout LyX-Code
      mn.maxStack += 4;
\end_layout

\begin_layout LyX-Code
    }
\end_layout

\begin_layout LyX-Code
    int acc = ACC_PUBLIC + ACC_STATIC;
\end_layout

\begin_layout LyX-Code
    cn.fields.add(new FieldNode(acc, "timer", "J", null, null));
\end_layout

\begin_layout LyX-Code
    super.transform(cn);
\end_layout

\begin_layout LyX-Code
  }
\end_layout

\begin_layout LyX-Code
}
\end_layout

\begin_layout Standard
You can see here the pattern discussed in the previous section for inserting
 several instructions in the instruction list, which consists in using a
 temporary instruction list.
 This example also shows that it is possible to insert instructions before
 the current one while iterating over an instruction list.
 Note that the amount of code that is necessary to implement this adapter
 is approximatively the same with the core and tree APIs.
 
\end_layout

\begin_layout Standard
The method adapter that removes field self assignments (see section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Statefull-transformations"

\end_inset

) can be implemented as follows (if we suppose that 
\family typewriter
MethodTransformer
\family default
 is similar to the 
\family typewriter
ClassTransformer
\family default
 class of the previous chapter):
\end_layout

\begin_layout LyX-Code
public class RemoveGetFieldPutFieldTransformer extends
\end_layout

\begin_layout LyX-Code
    MethodTransformer {
\end_layout

\begin_layout LyX-Code
  public RemoveGetFieldPutFieldTransformer(MethodTransformer mt) {
\end_layout

\begin_layout LyX-Code
    super(mt);
\end_layout

\begin_layout LyX-Code
  }
\end_layout

\begin_layout LyX-Code
  @Override public void transform(MethodNode mn) {
\end_layout

\begin_layout LyX-Code
    
\series bold
InsnList insns = mn.instructions;
\end_layout

\begin_layout LyX-Code
 
\series bold
   Iterator<AbstractInsnNode> i = insns.iterator();
\end_layout

\begin_layout LyX-Code
 
\series bold
   while (i.hasNext()) {
\end_layout

\begin_layout LyX-Code
 
\series bold
     AbstractInsnNode i1 = i.next();
\end_layout

\begin_layout LyX-Code
      if (isALOAD0(i1)) {
\end_layout

\begin_layout LyX-Code
        AbstractInsnNode i2 = getNext(i1);
\end_layout

\begin_layout LyX-Code
        if (i2 != null && isALOAD0(i2)) {
\end_layout

\begin_layout LyX-Code
          AbstractInsnNode i3 = getNext(i2);
\end_layout

\begin_layout LyX-Code
          if (i3 != null && i3.getOpcode() == GETFIELD) {
\end_layout

\begin_layout LyX-Code
            AbstractInsnNode i4 = getNext(i3);
\end_layout

\begin_layout LyX-Code
            if (i4 != null && i4.getOpcode() == PUTFIELD) {
\end_layout

\begin_layout LyX-Code
              if (sameField(i3, i4)) {
\end_layout

\begin_layout LyX-Code
                
\series bold
while (i.next() != i4) {
\end_layout

\begin_layout LyX-Code
 
\series bold
               }
\end_layout

\begin_layout LyX-Code
 
\series bold
               insns.remove(i1);
\end_layout

\begin_layout LyX-Code
 
\series bold
               insns.remove(i2);
\end_layout

\begin_layout LyX-Code
 
\series bold
               insns.remove(i3);
\end_layout

\begin_layout LyX-Code
 
\series bold
               insns.remove(i4);
\end_layout

\begin_layout LyX-Code
              }
\end_layout

\begin_layout LyX-Code
            }
\end_layout

\begin_layout LyX-Code
          }
\end_layout

\begin_layout LyX-Code
        }
\end_layout

\begin_layout LyX-Code
      }
\end_layout

\begin_layout LyX-Code
    }
\end_layout

\begin_layout LyX-Code
    super.transform(mn);
\end_layout

\begin_layout LyX-Code
  }
\end_layout

\begin_layout LyX-Code
  
\series bold
private static AbstractInsnNode getNext(AbstractInsnNode insn) {
\end_layout

\begin_layout LyX-Code
 
\series bold
   do {
\end_layout

\begin_layout LyX-Code
 
\series bold
     insn = insn.getNext();
\end_layout

\begin_layout LyX-Code
 
\series bold
     if (insn != null && !(insn instanceof LineNumberNode)) {
\end_layout

\begin_layout LyX-Code
 
\series bold
       break;
\end_layout

\begin_layout LyX-Code
 
\series bold
     }
\end_layout

\begin_layout LyX-Code
 
\series bold
   } while (insn != null);
\end_layout

\begin_layout LyX-Code
 
\series bold
   return insn;
\end_layout

\begin_layout LyX-Code
 
\series bold
 }
\end_layout

\begin_layout LyX-Code
  private static boolean isALOAD0(AbstractInsnNode i) {
\end_layout

\begin_layout LyX-Code
    return i.getOpcode() == ALOAD && ((VarInsnNode) i).var == 0;
\end_layout

\begin_layout LyX-Code
  }
\end_layout

\begin_layout LyX-Code
  private static boolean sameField(AbstractInsnNode i,
\end_layout

\begin_layout LyX-Code
      AbstractInsnNode j) {
\end_layout

\begin_layout LyX-Code
    return ((FieldInsnNode) i).name.equals(((FieldInsnNode) j).name);
\end_layout

\begin_layout LyX-Code
  }
\end_layout

\begin_layout LyX-Code
}
\end_layout

\begin_layout Standard
Here again we can see that it is possible to remove instructions in an instructi
on list while iterating over it.
 Note however the 
\family typewriter
while (i.next() != i4)
\family default
 loop: this is necessary to place the iterator 
\emph on
after
\emph default
 the instructions that must be removed (since it is not possible to remove
 the instruction just after the current one).
 Both the visitor and tree based implementations can detect labels and frames
 in the middle of the sequence to be detected, and in this case do not remove
 it.
 But ignoring the line numbers inside the sequence requires more code with
 the tree based API (see the 
\family typewriter
getNext
\family default
 method) than with the core API.
 The major difference between the two implementations, however, is that
 no state machine is needed with the tree API.
 In particular the special case of three or more successive 
\family typewriter
ALOAD 0
\family default
 instructions, which can easily be overlooked, is no longer a problem.
\end_layout

\begin_layout Standard
With the above implementation, a given instruction may be examined more
 than once since, at each step of the 
\family typewriter
while
\family default
 loop, 
\family typewriter
i2
\family default
, 
\family typewriter
i3
\family default
 and 
\family typewriter
i4
\family default
, which will be examined in future iterations, may also be examined at this
 iteration.
 It is in fact possible to use a more efficient implementation, where each
 instruction is examined at most once:
\end_layout

\begin_layout LyX-Code
public class RemoveGetFieldPutFieldTransformer2 extends
\end_layout

\begin_layout LyX-Code
    MethodTransformer {
\end_layout

\begin_layout LyX-Code
  ...
\end_layout

\begin_layout LyX-Code
  @Override public void transform(MethodNode mn) {
\end_layout

\begin_layout LyX-Code
    InsnList insns = mn.instructions;
\end_layout

\begin_layout LyX-Code
    Iterator i = insns.iterator();
\end_layout

\begin_layout LyX-Code
    while (i.hasNext()) {
\end_layout

\begin_layout LyX-Code
      AbstractInsnNode i1 = (AbstractInsnNode) i.next();
\end_layout

\begin_layout LyX-Code
      if (isALOAD0(i1)) {
\end_layout

\begin_layout LyX-Code
        AbstractInsnNode i2 = getNext(i);
\end_layout

\begin_layout LyX-Code
        if (i2 != null && isALOAD0(i2)) {
\end_layout

\begin_layout LyX-Code
          AbstractInsnNode i3 = getNext(i);
\end_layout

\begin_layout LyX-Code
          
\series bold
while (i3 != null && isALOAD0(i3)) {
\end_layout

\begin_layout LyX-Code
 
\series bold
           i1 = i2;
\end_layout

\begin_layout LyX-Code
 
\series bold
           i2 = i3;
\end_layout

\begin_layout LyX-Code
 
\series bold
           i3 = getNext(i);
\end_layout

\begin_layout LyX-Code
 
\series bold
         }
\end_layout

\begin_layout LyX-Code
          if (i3 != null && i3.getOpcode() == GETFIELD) {
\end_layout

\begin_layout LyX-Code
            AbstractInsnNode i4 = getNext(i);
\end_layout

\begin_layout LyX-Code
            if (i4 != null && i4.getOpcode() == PUTFIELD) {
\end_layout

\begin_layout LyX-Code
              if (sameField(i3, i4)) {
\end_layout

\begin_layout LyX-Code
                insns.remove(i1);
\end_layout

\begin_layout LyX-Code
                insns.remove(i2);
\end_layout

\begin_layout LyX-Code
                insns.remove(i3);
\end_layout

\begin_layout LyX-Code
                insns.remove(i4);
\end_layout

\begin_layout LyX-Code
              }
\end_layout

\begin_layout LyX-Code
            }
\end_layout

\begin_layout LyX-Code
          }
\end_layout

\begin_layout LyX-Code
        }
\end_layout

\begin_layout LyX-Code
      }
\end_layout

\begin_layout LyX-Code
    }
\end_layout

\begin_layout LyX-Code
    super.transform(mn);
\end_layout

\begin_layout LyX-Code
  }
\end_layout

\begin_layout LyX-Code
  private static AbstractInsnNode getNext(Iterator i) {
\end_layout

\begin_layout LyX-Code
    while (i.hasNext()) {
\end_layout

\begin_layout LyX-Code
      AbstractInsnNode in = (AbstractInsnNode) i.next();
\end_layout

\begin_layout LyX-Code
      if (!(in instanceof LineNumberNode)) {
\end_layout

\begin_layout LyX-Code
        return in;
\end_layout

\begin_layout LyX-Code
      }
\end_layout

\begin_layout LyX-Code
    }
\end_layout

\begin_layout LyX-Code
    return null;
\end_layout

\begin_layout LyX-Code
  }
\end_layout

\begin_layout LyX-Code
  ...
\end_layout

\begin_layout LyX-Code
}
\end_layout

\begin_layout Standard
The difference with the previous implementation is the 
\family typewriter
getNext
\family default
 method, which now acts on the list iterator.
 When the sequence is recognized the iterator is just after it, so the 
\family typewriter
while (i.next() != i4)
\family default
 loop is no longer necessary.
 But here the special case of three or more successive 
\family typewriter
ALOAD 0
\family default
 instructions shows up again (see the 
\family typewriter
while (i3 != null)
\family default
 loop).
\end_layout

\begin_layout Subsection
Global transformations
\begin_inset CommandInset label
LatexCommand label
name "sub:Global-transformations"

\end_inset


\end_layout

\begin_layout Standard
All the method transformations that we have seen so far were 
\emph on
local
\emph default
, even the statefull ones, in the sense that the transformation of an instructio
n 
\emph on
i
\emph default
 only depended on instructions at a fixed distance from 
\emph on
i
\emph default
.
 There are however 
\emph on
global
\emph default
 transformations, where the transformation of an instruction 
\emph on
i
\emph default
 may depend on instructions that can be at an arbitrary distance of 
\emph on
i
\emph default
.
 For these transformations the tree API is really helpful, i.e., using the
 core API to implement them would be really complicated.
\end_layout

\begin_layout Standard
One example is a transformation that replaces a jump to a 
\family typewriter
GOTO
\family default
 
\family typewriter
\emph on
label
\family default
\emph default
 instruction with a jump to 
\family typewriter
\emph on
label
\family default
\emph default
, and that replaces a 
\family typewriter
GOTO
\family default
 to a 
\family typewriter
RETURN
\family default
 instruction with this 
\family typewriter
RETURN
\family default
 instruction.
 Indeed the target of a jump instruction can be at an arbitrary distance
 of this instruction, before or after it.
 Such a transformation can be implemented as follows:
\end_layout

\begin_layout LyX-Code
public class OptimizeJumpTransformer extends MethodTransformer {
\end_layout

\begin_layout LyX-Code
  public OptimizeJumpTransformer(MethodTransformer mt) {
\end_layout

\begin_layout LyX-Code
    super(mt);
\end_layout

\begin_layout LyX-Code
  }
\end_layout

\begin_layout LyX-Code
  @Override public void transform(MethodNode mn) {
\end_layout

\begin_layout LyX-Code
    InsnList insns = mn.instructions;
\end_layout

\begin_layout LyX-Code
    Iterator<AbstractInsnNode> i = insns.iterator();
\end_layout

\begin_layout LyX-Code
    while (i.hasNext()) {
\end_layout

\begin_layout LyX-Code
      AbstractInsnNode in = i.next();
\end_layout

\begin_layout LyX-Code
      if (in instanceof JumpInsnNode) {
\end_layout

\begin_layout LyX-Code
        LabelNode label = ((JumpInsnNode) in).label;
\end_layout

\begin_layout LyX-Code
        AbstractInsnNode target;
\end_layout

\begin_layout LyX-Code
        // while target == goto l, replace label with l  
\end_layout

\begin_layout LyX-Code
        while (true) {
\end_layout

\begin_layout LyX-Code
          target = label;
\end_layout

\begin_layout LyX-Code
          while (target != null && target.getOpcode() < 0) {
\end_layout

\begin_layout LyX-Code
            target = target.getNext();
\end_layout

\begin_layout LyX-Code
          }
\end_layout

\begin_layout LyX-Code
          if (target != null && target.getOpcode() == GOTO) {
\end_layout

\begin_layout LyX-Code
            label = ((JumpInsnNode) target).label;
\end_layout

\begin_layout LyX-Code
          } else {
\end_layout

\begin_layout LyX-Code
            break;
\end_layout

\begin_layout LyX-Code
          }
\end_layout

\begin_layout LyX-Code
        }
\end_layout

\begin_layout LyX-Code
        // update target
\end_layout

\begin_layout LyX-Code
        ((JumpInsnNode) in).label = label;
\end_layout

\begin_layout LyX-Code
        // if possible, replace jump with target instruction
\end_layout

\begin_layout LyX-Code
        if (in.getOpcode() == GOTO && target != null) {
\end_layout

\begin_layout LyX-Code
          int op = target.getOpcode();
\end_layout

\begin_layout LyX-Code
          if ((op >= IRETURN && op <= RETURN) || op == ATHROW) {
\end_layout

\begin_layout LyX-Code
            // replace 'in' with clone of 'target'
\end_layout

\begin_layout LyX-Code
            insns.set(in, target.
\series bold
clone
\series default
(null));
\end_layout

\begin_layout LyX-Code
          }
\end_layout

\begin_layout LyX-Code
        }
\end_layout

\begin_layout LyX-Code
      }
\end_layout

\begin_layout LyX-Code
    }
\end_layout

\begin_layout LyX-Code
    super.transform(mn);
\end_layout

\begin_layout LyX-Code
  }
\end_layout

\begin_layout LyX-Code
}
\end_layout

\begin_layout Standard
This code works as follows: when a jump instruction 
\family typewriter
in
\family default
 is found, its target is stored in 
\family typewriter
label
\family default
.
 Then the instruction that comes just after this label is searched for with
 the innermost while loop (
\family typewriter
AbstractInsnNode
\family default
 objects that do not represent real instructions, such as 
\family typewriter
FrameNode
\family default
 or 
\family typewriter
LabelNode
\family default
, have a negative 
\begin_inset Quotes eld
\end_inset

opcode
\begin_inset Quotes erd
\end_inset

).
 As long as this instruction is a 
\family typewriter
GOTO
\family default
, 
\family typewriter
label
\family default
 is replaced with the target of this instruction, and the previous steps
 are repeated.
 Finally the target label of 
\family typewriter
in
\family default
 is replaced with this updated 
\family typewriter
label
\family default
 value and, if 
\family typewriter
in
\family default
 is itself a 
\family typewriter
GOTO
\family default
 and if its updated target is a 
\family typewriter
RETURN
\family default
 instruction, 
\family typewriter
in
\family default
 is replaced with a 
\emph on
clone
\emph default
 of this return instruction (recall that an instruction object cannot appear
 more than once in an instruction list).
\end_layout

\begin_layout Standard
The effect of this transformation on the 
\family typewriter
checkAndSetF
\family default
 method defined in section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Frames"

\end_inset

 is shown below:
\end_layout

\begin_layout LyX-Code
// before                  // after
\end_layout

\begin_layout LyX-Code
  ILOAD 1                    ILOAD 1
\end_layout

\begin_layout LyX-Code
  IFLT 
\shape slanted
label
\shape default
                 IFLT 
\shape slanted
label
\end_layout

\begin_layout LyX-Code
  ALOAD 0                    ALOAD 0
\end_layout

\begin_layout LyX-Code
  ILOAD 1                    ILOAD 1
\end_layout

\begin_layout LyX-Code
  PUTFIELD ...
               PUTFIELD ...
\end_layout

\begin_layout LyX-Code
  GOTO 
\shape slanted
end
\shape default
                   
\series bold
RETURN
\end_layout

\begin_layout LyX-Code

\shape slanted
label:                     label:
\end_layout

\begin_layout LyX-Code
F_SAME                     F_SAME
\end_layout

\begin_layout LyX-Code
  NEW ...
                    NEW ...
\end_layout

\begin_layout LyX-Code
  DUP                        DUP
\end_layout

\begin_layout LyX-Code
  INVOKESPECIAL ...
          INVOKESPECIAL ...
\end_layout

\begin_layout LyX-Code
  ATHROW                     ATHROW
\end_layout

\begin_layout LyX-Code

\shape slanted
end:                       end:
\end_layout

\begin_layout LyX-Code
F_SAME                     F_SAME
\end_layout

\begin_layout LyX-Code
  RETURN                     RETURN
\end_layout

\begin_layout Standard
Note that, although this transformation changes the jump instructions (more
 formally the control flow graph), it does 
\emph on
not
\emph default
 need to update the method's frames
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
frames!updating
\end_layout

\end_inset

.
 Indeed the state of the execution frame remains the same at each instruction
 and, since no new jump target is introduced, no new frame must be visited.
 It may happen, however, that a frame is no longer needed.
 For instance, in the above example, the 
\family typewriter
\emph on
end
\family default
\emph default
 label is no longer used after transformation, as well as the 
\family typewriter
F_SAME
\family default
 frame and the 
\family typewriter
RETURN
\family default
 instruction after it.
 Hopefully it is perfectly legal to visit more frames than is strictly necessary
, as well as to include unused code -- called 
\emph on
dead
\emph default

\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
dead code
\end_layout

\end_inset

 or 
\emph on
unreachable
\emph default

\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
unreachable code
\end_layout

\end_inset

 code -- in a method.
 The above method adapter is therefore correct, even if it could be improved
 to remove dead code and frames.
\end_layout

\begin_layout Section
Components composition
\end_layout

\begin_layout Standard
So far we have only seen how to create and transform 
\family typewriter
MethodNode
\family default
 objects, but we haven't seen the link with the byte array representation
 of classes.
 Like for classes, this link is done by composing the core API and tree
 API components, as explained in this section.
\end_layout

\begin_layout Subsection
Presentation
\end_layout

\begin_layout Standard
In addition to the fields shown in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:The-MethodNode-class"

\end_inset

 the 
\family typewriter
MethodNode
\family default
 class extends the 
\family typewriter
MethodVisitor
\family default
 class, and also provides two 
\family typewriter
accept
\family default
 methods that take a 
\family typewriter
MethodVisitor
\family default
 or a 
\family typewriter
ClassVisitor
\family default
 as parameter.
 The 
\family typewriter
accept
\family default
 methods generate events based on the 
\family typewriter
MethodNode
\family default
 field values, while the 
\family typewriter
MethodVisitor
\family default
 methods perform the inverse operation, i.e.
 set the 
\family typewriter
MethodNode
\family default
 fields based on the received events.
\end_layout

\begin_layout Subsection
Patterns
\begin_inset CommandInset label
LatexCommand label
name "sub:MethodAPICompositionPatterns"

\end_inset


\end_layout

\begin_layout Standard
Like for classes, it is possible to use a tree based method transformer
 like a method adapter with the core API.
 The two patterns that can be used for classes are indeed also valid for
 methods, and work exactly in the same way.
 The pattern based on inheritance is the following:
\end_layout

\begin_layout LyX-Code
public class MyMethodAdapter 
\series bold
extends MethodNode
\series default
 {
\end_layout

\begin_layout LyX-Code
  public MyMethodAdapter(int access, String name, String desc, 
\end_layout

\begin_layout LyX-Code
      String signature, String[] exceptions, MethodVisitor mv) {
\end_layout

\begin_layout LyX-Code
    super(ASM4, access, name, desc, signature, exceptions);
\end_layout

\begin_layout LyX-Code
    this.mv = mv;
\end_layout

\begin_layout LyX-Code
  }
\end_layout

\begin_layout LyX-Code
  @Override public void visitEnd() {
\end_layout

\begin_layout LyX-Code
    // put your transformation code here
\end_layout

\begin_layout LyX-Code
    
\series bold
accept(mv);
\end_layout

\begin_layout LyX-Code
  }
\end_layout

\begin_layout LyX-Code
}
\end_layout

\begin_layout Standard
While the pattern based on delegation is:
\end_layout

\begin_layout LyX-Code
public class MyMethodAdapter extends MethodVisitor {
\end_layout

\begin_layout LyX-Code
  MethodVisitor next;
\end_layout

\begin_layout LyX-Code
  public MyMethodAdapter(int access, String name, String desc, 
\end_layout

\begin_layout LyX-Code
      String signature, String[] exceptions, MethodVisitor mv) {
\end_layout

\begin_layout LyX-Code
    super(ASM4, 
\end_layout

\begin_layout LyX-Code

\series bold
       new MethodNode(access, name, desc, signature, exceptions)
\series default
);
\end_layout

\begin_layout LyX-Code
    next = mv;
\end_layout

\begin_layout LyX-Code
  }
\end_layout

\begin_layout LyX-Code
  @Override public void visitEnd() {
\end_layout

\begin_layout LyX-Code
    MethodNode mn = (MethodNode) mv;
\end_layout

\begin_layout LyX-Code
    // put your transformation code here
\end_layout

\begin_layout LyX-Code
    
\series bold
mn.accept(next);
\end_layout

\begin_layout LyX-Code
  }
\end_layout

\begin_layout LyX-Code
}
\end_layout

\begin_layout Standard
A variant of the first pattern is to use it with an anonymous inner class
 directly in the 
\family typewriter
visitMethod
\family default
 of a 
\family typewriter
ClassAdapter
\family default
:
\end_layout

\begin_layout LyX-Code
public MethodVisitor visitMethod(int access, String name,
\end_layout

\begin_layout LyX-Code
    String desc, String signature, String[] exceptions) {
\end_layout

\begin_layout LyX-Code
  return 
\series bold
new MethodNode
\series default
(ASM4, access, name, desc, signature, exceptions) 
\end_layout

\begin_layout LyX-Code
  {
\end_layout

\begin_layout LyX-Code
    @Override public void visitEnd() {
\end_layout

\begin_layout LyX-Code
      // put your transformation code here
\end_layout

\begin_layout LyX-Code
      
\series bold
accept(cv);
\end_layout

\begin_layout LyX-Code
    }
\end_layout

\begin_layout LyX-Code
  };
\end_layout

\begin_layout LyX-Code
}
\end_layout

\begin_layout Standard
These patterns show that it is possible to use the tree API only for methods,
 and the core API for classes.
 
\emph on
In practice this strategy is often used
\emph default
.
\end_layout

\begin_layout Chapter
Method Analysis
\end_layout

\begin_layout Standard
This chapter presents the ASM API for analyzing the code of methods, which
 is based on the tree API.
 It starts with a presentation of code analysis algorithms, and then presents
 the corresponding ASM API, with some examples.
\end_layout

\begin_layout Section
Presentation
\end_layout

\begin_layout Standard
Code analysis is a very large topic, and many algorithms exist for analyzing
 code.
 It would be impossible and out of the scope of this document to present
 them all here.
 In fact the goal of this section is just to give an overview of the algorithms
 that are used in ASM.
 A better presentation of this topic can be found in books about compilers.
 The next sections present two important types of code analysis techniques,
 namely data flow and control flow analysis:
\end_layout

\begin_layout Itemize
A 
\emph on
data flow
\emph default

\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
data flow analysis
\end_layout

\end_inset

 analysis consists in computing the state of the execution frames of a method,
 for each instruction of this method.
 This state can be represented in a more or less abstract way.
 For example reference values can be represented by a single value, by one
 value per class, by three possible values in the { null, not null, may
 be null } set, etc.
\end_layout

\begin_layout Itemize
A 
\emph on
control flow
\emph default

\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
control flow analysis
\end_layout

\end_inset

 analysis consists in computing the control flow graph of a method, and
 in performing analyses on this graph.
 The 
\emph on
control flow graph
\emph default

\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
control flow graph
\end_layout

\end_inset

 is a graph whose nodes are instructions, and whose oriented edges connect
 two instructions 
\begin_inset Formula $i\rightarrow j$
\end_inset

 if 
\begin_inset Formula $j$
\end_inset

 can be executed just after 
\begin_inset Formula $i$
\end_inset

.
\end_layout

\begin_layout Subsection
Data flow analyses
\end_layout

\begin_layout Standard
Two types of data flow analyses can be performed:
\end_layout

\begin_layout Itemize
a 
\emph on
forward
\emph default
 analysis computes, for each instruction, the state of the execution frame
 after this instruction, from the state before its execution.
\end_layout

\begin_layout Itemize
a 
\emph on
backward
\emph default
 analysis computes, for each instruction, the state of the execution frame
 
\emph on
before
\emph default
 this instruction, from the state after its execution.
\end_layout

\begin_layout Standard
A forward data flow analysis is performed by simulating the execution of
 each bytecode instruction of a method on its execution frame, which generally
 consists in:
\end_layout

\begin_layout Itemize
popping values from the stack, 
\end_layout

\begin_layout Itemize
combining them, 
\end_layout

\begin_layout Itemize
and pushing the result on the stack.
 
\end_layout

\begin_layout Standard
This looks like what an interpreter or the Java Virtual Machine does, but
 in fact it is completely different because the goal is to simulate 
\emph on
all potential execution paths
\emph default
 in a method, 
\emph on
for all possible argument values
\emph default
, instead of the single execution path determined by some specific method
 argument values.
 One consequence is that, for branch instructions, 
\emph on
both
\emph default
 branches are simulated (while a real interpreter follows only one branch,
 depending on the actual condition value).
\end_layout

\begin_layout Standard
Another consequence is that the manipulated values are in fact 
\emph on
sets
\emph default
 of possible values.
 These sets can be very large, such as 
\begin_inset Quotes eld
\end_inset

all possible values
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

all the integers
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

all possible objects
\begin_inset Quotes erd
\end_inset

 or 
\begin_inset Quotes eld
\end_inset

all possible 
\family typewriter
String
\family default
 objects
\begin_inset Quotes erd
\end_inset

, in which case they can also be called 
\emph on
types
\emph default
.
 They can also be more precise, such as 
\begin_inset Quotes eld
\end_inset

all positive integers
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

all integers between 0 and 10
\begin_inset Quotes erd
\end_inset

 or 
\begin_inset Quotes eld
\end_inset

all possible non 
\family typewriter
null
\family default
 objects
\begin_inset Quotes erd
\end_inset

.
 Simulating the execution of an instruction 
\emph on
i
\emph default
 consists in finding the set of all possible results of 
\emph on
i
\emph default
, for all combinations of values in its operand value sets.
 For instance, if integers are represented by three sets P = 
\begin_inset Quotes eld
\end_inset

positive or null
\begin_inset Quotes erd
\end_inset

, N = 
\begin_inset Quotes eld
\end_inset

negative or null
\begin_inset Quotes erd
\end_inset

, and A = 
\begin_inset Quotes eld
\end_inset

all integers
\begin_inset Quotes erd
\end_inset

, simulating the 
\family typewriter
IADD
\family default
 instruction means returning P if both operands are P, N if both operands
 are N, and A in all other cases.
\end_layout

\begin_layout Standard
A last consequence is the need to compute 
\emph on
unions
\emph default
 of sets of values: for example the set of possible values corresponding
 to 
\family typewriter
(b ? e1 : e2)
\family default
 is the union of the possible values of 
\family typewriter
e1
\family default
 and of the possible values of 
\family typewriter
e2
\family default
.
 More generally this operation is needed each time the control flow graph
 contains two or more edges with a common destination.
 In the previous example, where integers are represented by the three sets
 P, N, and A, computing the union of two of these sets is easy: it is always
 A, unless the two sets are equal.
\end_layout

\begin_layout Subsection
Control flow analyses
\begin_inset CommandInset label
LatexCommand label
name "sub:Control-flow-analyses"

\end_inset


\end_layout

\begin_layout Standard
A control flow analysis is an analysis based on the control flow graph of
 a method.
 As an example, the control flow graph of the 
\family typewriter
checkAndSetF
\family default
 method in section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Bytecode-sequence-examples"

\end_inset

 is given below (with labels included in the graph like real instructions):
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename figures/controlflowgraph.eps
	scale 80

\end_inset


\end_layout

\begin_layout Standard
This graph can be decomposed in four 
\emph on
basic blocks
\emph default

\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
basic block
\end_layout

\end_inset

 (shown above with rectangles), a basic block being a sequence of instructions
 such that each instruction except the last one has exactly one successor,
 and such that no instruction except the first one can be the target of
 a jump.
\end_layout

\begin_layout Section
Interfaces and components
\end_layout

\begin_layout Standard
The ASM API for code analysis is in the 
\family typewriter
org.objectweb.asm.tree.analysis
\family default
 package.
 As the package name implies, it is based on the tree API.
 In fact this package provides a framework for doing forward data flow analyses.
\end_layout

\begin_layout Standard
In order to be able to perform various data flow analyses, with more or
 less precise sets of values, the data flow analysis algorithm is split
 in two parts: one is fixed and is provided by the framework, the other
 is variable and provided by users.
 More precisely:
\end_layout

\begin_layout Itemize
The overall data flow analysis algorithm, and the task of popping from the
 stack, and pushing back to the stack, the appropriate number of values,
 is implemented once and for all in the 
\family typewriter
Analyzer
\family default

\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
Analyzer@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
texttt{Analyzer}
\end_layout

\end_inset


\end_layout

\end_inset

 and 
\family typewriter
Frame
\family default

\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
Frame@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
texttt{Frame}
\end_layout

\end_inset


\end_layout

\end_inset

 classes.
\end_layout

\begin_layout Itemize
The task of combining values and of computing unions of value sets is performed
 by user defined subclasses of the 
\family typewriter
Interpreter
\family default

\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
Interpreter@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
texttt{Interpreter}
\end_layout

\end_inset


\end_layout

\end_inset

 and 
\family typewriter
Value
\family default

\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
Value@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
texttt{Value}
\end_layout

\end_inset


\end_layout

\end_inset

 abstract classes.
 Several predefined subclasses are provided, and are explained in the next
 sections.
\end_layout

\begin_layout Standard
Although the primary goal of the framework is to perform data flow analyses,
 the 
\family typewriter
Analyzer
\family default
 class can also construct the control flow graph of the analyzed method.
 This can be done by overriding the 
\family typewriter
newControlFlowEdge
\family default
 and 
\family typewriter
newControlFlowExceptionEdge
\family default
 methods of this class, which by default do nothing.
 The result can be used for doing control flow analyses.
\end_layout

\begin_layout Subsection
Basic data flow analysis
\end_layout

\begin_layout Standard
The 
\family typewriter
BasicInterpreter
\family default

\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
BasicInterpreter@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
texttt{BasicInterpreter}
\end_layout

\end_inset


\end_layout

\end_inset

 class is one of the predefined subclass of the 
\family typewriter
Interpreter
\family default
 abstract class.
 It simulates the effect of bytecode instructions by using seven sets of
 values, defined in the 
\family typewriter
BasicValue
\family default
 class:
\end_layout

\begin_layout Itemize

\family typewriter
UNINITIALIZED_VALUE
\family default
 means 
\begin_inset Quotes eld
\end_inset

all possible values
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Itemize

\family typewriter
INT_VALUE
\family default
 means 
\begin_inset Quotes eld
\end_inset

all 
\family typewriter
int
\family default
, 
\family typewriter
short
\family default
, 
\family typewriter
byte
\family default
, 
\family typewriter
boolean
\family default
 or 
\family typewriter
char
\family default
 values
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Itemize

\family typewriter
FLOAT_VALUE
\family default
 means 
\begin_inset Quotes eld
\end_inset

all 
\family typewriter
float
\family default
 values
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Itemize

\family typewriter
LONG_VALUE
\family default
 means 
\begin_inset Quotes eld
\end_inset

all 
\family typewriter
long
\family default
 values
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Itemize

\family typewriter
DOUBLE_VALUE
\family default
 means 
\begin_inset Quotes eld
\end_inset

all 
\family typewriter
double
\family default
 values
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Itemize

\family typewriter
REFERENCE_VALUE
\family default
 means 
\begin_inset Quotes eld
\end_inset

all object and array values
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Itemize

\family typewriter
RETURNADDRESS_VALUE
\family default
 is used for subroutines (see Appendix 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Subroutines"

\end_inset

).
\end_layout

\begin_layout Standard
This interpreter is not very useful in itself (the method frames already
 provide such an information, with more details -- see section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Frames"

\end_inset

), but it can be used as an 
\begin_inset Quotes eld
\end_inset

empty
\begin_inset Quotes erd
\end_inset

 
\family typewriter
Interpreter
\family default
 implementation in order to construct an 
\family typewriter
Analyzer
\family default
.
 This analyzer can then be used to detect unreachable code in a method.
 Indeed, even by following both branches in jumps instructions, it is not
 possible to reach code that cannot be reached from the first instruction.
 The consequence is that, after an analysis, and whatever the 
\family typewriter
Interpreter
\family default
 implementation, the computed frames -- returned by the 
\family typewriter
Analyzer.getFrames
\family default
 method -- are 
\family typewriter
null
\family default
 for instructions that cannot be reached.
 This property can be used to implement a 
\family typewriter
RemoveDeadCodeAdapter
\family default

\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
dead code!removing
\end_layout

\end_inset

 class very easily (there are more efficient ways, but they require to write
 more code):
\end_layout

\begin_layout LyX-Code
public class RemoveDeadCodeAdapter extends MethodVisitor {
\end_layout

\begin_layout LyX-Code
  String owner;
\end_layout

\begin_layout LyX-Code
  MethodVisitor next;
\end_layout

\begin_layout LyX-Code
  public RemoveDeadCodeAdapter(String owner, int access, String name,
\end_layout

\begin_layout LyX-Code
      String desc, MethodVisitor mv) {
\end_layout

\begin_layout LyX-Code
    super(ASM4, new MethodNode(access, name, desc, null, null));
\end_layout

\begin_layout LyX-Code
    this.owner = owner;
\end_layout

\begin_layout LyX-Code
    next = mv;
\end_layout

\begin_layout LyX-Code
  }
\end_layout

\begin_layout LyX-Code
  @Override public void visitEnd() {
\end_layout

\begin_layout LyX-Code
    MethodNode mn = (MethodNode) mv;
\end_layout

\begin_layout LyX-Code
    
\series bold
Analyzer<BasicValue> a = 
\end_layout

\begin_layout LyX-Code

\series bold
        new Analyzer<BasicValue>(new BasicInterpreter());
\end_layout

\begin_layout LyX-Code
    try {
\end_layout

\begin_layout LyX-Code
      
\series bold
a.analyze(owner, mn);
\end_layout

\begin_layout LyX-Code
 
\series bold
     Frame<BasicValue>[] frames = a.getFrames();
\end_layout

\begin_layout LyX-Code
      AbstractInsnNode[] insns = mn.instructions.toArray();
\end_layout

\begin_layout LyX-Code
      for (int i = 0; i < frames.length; ++i) {
\end_layout

\begin_layout LyX-Code
        
\series bold
if (frames[i] == null && !(insns[i] instanceof LabelNode)) {
\end_layout

\begin_layout LyX-Code
 
\series bold
         mn.instructions.remove(insns[i]);
\end_layout

\begin_layout LyX-Code
 
\series bold
       }
\end_layout

\begin_layout LyX-Code
      }
\end_layout

\begin_layout LyX-Code
    } catch (AnalyzerException ignored) {
\end_layout

\begin_layout LyX-Code
    }
\end_layout

\begin_layout LyX-Code
    mn.accept(next);
\end_layout

\begin_layout LyX-Code
  }
\end_layout

\begin_layout LyX-Code
}
\end_layout

\begin_layout Standard
When combined with the 
\family typewriter
OptimizeJumpAdapter
\family default
 of section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Global-transformations"

\end_inset

, the dead code introduced by the jump optimizer is removed.
 For example, using this adapter chain on the 
\family typewriter
checkAndSetF
\family default
 method gives:
\end_layout

\begin_layout LyX-Code
// after OptimizeJump      // after RemoveDeadCode
\end_layout

\begin_layout LyX-Code
  ILOAD 1                    ILOAD 1
\end_layout

\begin_layout LyX-Code
  IFLT 
\shape slanted
label
\shape default
                 IFLT 
\shape slanted
label
\end_layout

\begin_layout LyX-Code
  ALOAD 0                    ALOAD 0
\end_layout

\begin_layout LyX-Code
  ILOAD 1                    ILOAD 1
\end_layout

\begin_layout LyX-Code
  PUTFIELD ...
               PUTFIELD ...
\end_layout

\begin_layout LyX-Code
  RETURN                   
\series bold
 
\series default
 RETURN
\end_layout

\begin_layout LyX-Code

\shape slanted
label:                     label:
\end_layout

\begin_layout LyX-Code
F_SAME                     F_SAME
\end_layout

\begin_layout LyX-Code
  NEW ...
                    NEW ...
\end_layout

\begin_layout LyX-Code
  DUP                        DUP
\end_layout

\begin_layout LyX-Code
  INVOKESPECIAL ...
          INVOKESPECIAL ...
\end_layout

\begin_layout LyX-Code
  ATHROW                     ATHROW
\end_layout

\begin_layout LyX-Code

\shape slanted
end:                       end:
\end_layout

\begin_layout LyX-Code
F_SAME
\end_layout

\begin_layout LyX-Code
  RETURN
\end_layout

\begin_layout Standard
Note that dead labels are not removed.
 This is done on purpose: indeed it does not change the resulting code,
 but avoids removing a label that, although not reachable, might be referenced
 in a 
\family typewriter
LocalVariableNode
\family default
, for instance.
\end_layout

\begin_layout Subsection
Basic data flow verifier
\end_layout

\begin_layout Standard
The 
\family typewriter
BasicVerifier
\family default

\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
BasicVerifier@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
texttt{BasicVerifier}
\end_layout

\end_inset


\end_layout

\end_inset

 class extends the 
\family typewriter
BasicInterpreter
\family default
 class.
 It uses the same seven sets but, unlike 
\family typewriter
BasicInterpreter
\family default
, checks that instructions are used correctly.
 For instance it checks that the operands of an 
\family typewriter
IADD
\family default
 instruction are 
\family typewriter
INTEGER_VALUE
\family default
 values (while 
\family typewriter
BasicInterpreter
\family default
 just returns the result, i.e.
 
\family typewriter
INTEGER_VALUE
\family default
).
 This class can be used for debugging purposes during the development of
 a class generator or adapter, as explained in section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:MethodTools"

\end_inset

.
 For instance this class can detect that the 
\family typewriter
ISTORE
\family default
 
\family typewriter
1
\family default
 
\family typewriter
ALOAD
\family default
 
\family typewriter
1
\family default
 sequence is invalid.
 It can be included in a utility method adapter like this (in practice it
 is simpler to use the 
\family typewriter
CheckMethodAdapter
\family default
 class, which can be configured to use a 
\family typewriter
BasicVerifier
\family default
):
\end_layout

\begin_layout LyX-Code
public class BasicVerifierAdapter extends MethodVisitor {
\end_layout

\begin_layout LyX-Code
  String owner;
\end_layout

\begin_layout LyX-Code
  MethodVisitor next;
\end_layout

\begin_layout LyX-Code
  public BasicVerifierAdapter(String owner, int access, String name,
\end_layout

\begin_layout LyX-Code
      String desc, MethodVisitor mv) {
\end_layout

\begin_layout LyX-Code
    super(ASM4, new MethodNode(access, name, desc, null, null));
\end_layout

\begin_layout LyX-Code
    this.owner = owner;
\end_layout

\begin_layout LyX-Code
    next = mv;
\end_layout

\begin_layout LyX-Code
  }
\end_layout

\begin_layout LyX-Code
  @Override public void visitEnd() {
\end_layout

\begin_layout LyX-Code
    MethodNode mn = (MethodNode) mv;
\end_layout

\begin_layout LyX-Code
    
\series bold
Analyzer<BasicValue> a = 
\end_layout

\begin_layout LyX-Code

\series bold
        new Analyzer<BasicValue(new BasicVerifier());
\end_layout

\begin_layout LyX-Code
 
\series bold
   try {
\end_layout

\begin_layout LyX-Code
 
\series bold
     a.analyze(owner, mn);
\end_layout

\begin_layout LyX-Code
 
\series bold
   } catch (AnalyzerException e) {
\end_layout

\begin_layout LyX-Code
 
\series bold
     throw new RuntimeException(e.getMessage());
\end_layout

\begin_layout LyX-Code
 
\series bold
   }
\end_layout

\begin_layout LyX-Code
    mn.accept(next);
\end_layout

\begin_layout LyX-Code
  }
\end_layout

\begin_layout LyX-Code
}
\end_layout

\begin_layout Subsection
Simple data flow verifier
\end_layout

\begin_layout Standard
The 
\family typewriter
SimpleVerifier
\family default

\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
SimpleVerifier@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
texttt{SimpleVerifier}
\end_layout

\end_inset


\end_layout

\end_inset

 class extends the 
\family typewriter
BasicVerifier
\family default
 class.
 It uses more sets to simulate the execution of bytecode instructions: indeed
 each class is represented by its own set, representing all possible objects
 of this class.
 It can therefore detect more errors, such as the fact of calling a method
 defined in the 
\family typewriter
String
\family default
 class on an object whose possible values are 
\begin_inset Quotes eld
\end_inset

all objects of type 
\family typewriter
Thread
\family default

\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Standard
This class uses the Java reflection API in order to perform verifications
 and computations related to the class hierarchy.
 It therefore loads the classes referenced by a method into the JVM.
 This default behavior can be changed by overriding the protected methods
 of this class.
\end_layout

\begin_layout Standard
Like 
\family typewriter
BasicVerifier
\family default
, this class could be used during the development of a class generator or
 adapter in order find bugs more easily.
 But it can also be used for other purposes.
 One example is a transformation that removes unnecessary casts in methods:
 if this analyzer finds that the operand of a 
\family typewriter
CHECKCAST
\family default
 
\family typewriter
to
\family default
 instruction is the set of values 
\begin_inset Quotes eld
\end_inset

all objects of type 
\family typewriter
from
\family default

\begin_inset Quotes erd
\end_inset

, and if 
\family typewriter
to
\family default
 is a super class of 
\family typewriter
from
\family default
, then the 
\family typewriter
CHECKCAST
\family default
 instruction is unnecessary and can be removed.
 The implementation of this transformation is the following:
\end_layout

\begin_layout LyX-Code
public class RemoveUnusedCastTransformer extends MethodTransformer {
\end_layout

\begin_layout LyX-Code
  String owner;
\end_layout

\begin_layout LyX-Code
  public RemoveUnusedCastTransformer(String owner,
\end_layout

\begin_layout LyX-Code
      MethodTransformer mt) {
\end_layout

\begin_layout LyX-Code
    super(mt);
\end_layout

\begin_layout LyX-Code
    this.owner = owner;
\end_layout

\begin_layout LyX-Code
  }
\end_layout

\begin_layout LyX-Code
  @Override public MethodNode transform(MethodNode mn) {
\end_layout

\begin_layout LyX-Code
    
\series bold
Analyzer<BasicValue> a = 
\end_layout

\begin_layout LyX-Code

\series bold
        new Analyzer<BasicValue>(new SimpleVerifier());
\end_layout

\begin_layout LyX-Code
    try {
\end_layout

\begin_layout LyX-Code
      
\series bold
a.analyze(owner, mn);
\end_layout

\begin_layout LyX-Code
 
\series bold
     Frame<BasicValue>[] frames = a.getFrames();
\end_layout

\begin_layout LyX-Code
      AbstractInsnNode[] insns = mn.instructions.toArray();
\end_layout

\begin_layout LyX-Code
      for (int i = 0; i < insns.length; ++i) {
\end_layout

\begin_layout LyX-Code
        AbstractInsnNode insn = insns[i];
\end_layout

\begin_layout LyX-Code
        
\series bold
if (insn.getOpcode() == CHECKCAST) {
\end_layout

\begin_layout LyX-Code
          Frame f = frames[i];
\end_layout

\begin_layout LyX-Code
          if (f != null && f.getStackSize() > 0) {
\end_layout

\begin_layout LyX-Code
            
\series bold
Object operand = f.getStack(f.getStackSize() - 1);
\end_layout

\begin_layout LyX-Code
            Class<?> to = getClass(((TypeInsnNode) insn).desc);
\end_layout

\begin_layout LyX-Code
            Class<?> from = getClass(((BasicValue) operand).getType());
\end_layout

\begin_layout LyX-Code
            
\series bold
if (to.isAssignableFrom(from)) {
\end_layout

\begin_layout LyX-Code
 
\series bold
             mn.instructions.remove(insn);
\end_layout

\begin_layout LyX-Code
 
\series bold
           }
\end_layout

\begin_layout LyX-Code
          }
\end_layout

\begin_layout LyX-Code
        }
\end_layout

\begin_layout LyX-Code
      }
\end_layout

\begin_layout LyX-Code
    } catch (AnalyzerException ignored) {
\end_layout

\begin_layout LyX-Code
    }
\end_layout

\begin_layout LyX-Code
    return mt == null ? mn : mt.transform(mn);
\end_layout

\begin_layout LyX-Code
  }
\end_layout

\begin_layout LyX-Code
  private static Class<?> getClass(String desc) {
\end_layout

\begin_layout LyX-Code
    try {
\end_layout

\begin_layout LyX-Code
      return Class.forName(desc.replace('/', '.'));
\end_layout

\begin_layout LyX-Code
    } catch (ClassNotFoundException e) {
\end_layout

\begin_layout LyX-Code
      throw new RuntimeException(e.toString());
\end_layout

\begin_layout LyX-Code
    }
\end_layout

\begin_layout LyX-Code
  }
\end_layout

\begin_layout LyX-Code
  private static Class<?> getClass(Type t) {
\end_layout

\begin_layout LyX-Code
    if (t.getSort() == Type.OBJECT) {
\end_layout

\begin_layout LyX-Code
      return getClass(t.getInternalName());
\end_layout

\begin_layout LyX-Code
    }
\end_layout

\begin_layout LyX-Code
    return getClass(t.getDescriptor());
\end_layout

\begin_layout LyX-Code
  }
\end_layout

\begin_layout LyX-Code
}
\end_layout

\begin_layout Standard
For Java 6 classes (or classes upgraded to Java 6 with 
\family typewriter
COMPUTE_FRAMES
\family default
), however, it is simpler and much more efficient to use an 
\family typewriter
AnalyzerAdapter
\family default
 for doing this with the core API:
\end_layout

\begin_layout LyX-Code
public class RemoveUnusedCastAdapter extends MethodVisitor {
\end_layout

\begin_layout LyX-Code
  
\series bold
public AnalyzerAdapter aa;
\end_layout

\begin_layout LyX-Code
  public RemoveUnusedCastAdapter(MethodVisitor mv) {
\end_layout

\begin_layout LyX-Code
    super(ASM4, mv);
\end_layout

\begin_layout LyX-Code
  }
\end_layout

\begin_layout LyX-Code
  @Override public void visitTypeInsn(int opcode, String desc) {
\end_layout

\begin_layout LyX-Code
    
\series bold
if (opcode == CHECKCAST) {
\end_layout

\begin_layout LyX-Code
      Class<?> to = getClass(desc);
\end_layout

\begin_layout LyX-Code
      if (aa.stack != null && aa.stack.size() > 0) {
\end_layout

\begin_layout LyX-Code
        
\series bold
Object operand = aa.stack.get(aa.stack.size() - 1);
\end_layout

\begin_layout LyX-Code
        if (operand instanceof String) {
\end_layout

\begin_layout LyX-Code
          Class<?> from = getClass((String) operand);
\end_layout

\begin_layout LyX-Code
          
\series bold
if (to.isAssignableFrom(from)) {
\end_layout

\begin_layout LyX-Code
 
\series bold
           return;
\end_layout

\begin_layout LyX-Code
 
\series bold
         }
\end_layout

\begin_layout LyX-Code
        }
\end_layout

\begin_layout LyX-Code
      }
\end_layout

\begin_layout LyX-Code
    }
\end_layout

\begin_layout LyX-Code
    mv.visitTypeInsn(opcode, desc);
\end_layout

\begin_layout LyX-Code
  }
\end_layout

\begin_layout LyX-Code
  private static Class getClass(String desc) {
\end_layout

\begin_layout LyX-Code
    try {
\end_layout

\begin_layout LyX-Code
      return Class.forName(desc.replace('/', '.'));
\end_layout

\begin_layout LyX-Code
    } catch (ClassNotFoundException e) {
\end_layout

\begin_layout LyX-Code
      throw new RuntimeException(e.toString());
\end_layout

\begin_layout LyX-Code
    }
\end_layout

\begin_layout LyX-Code
  }
\end_layout

\begin_layout LyX-Code
}
\end_layout

\begin_layout Subsection
User defined data flow analysis
\end_layout

\begin_layout Standard
Let's suppose that we would like to detect field accesses and method calls
 on potentially 
\family typewriter
null
\family default
 objects, such as in the following source code fragment (where the first
 line prevents some compilers from detecting the bug, which would otherwise
 be detected as an 
\begin_inset Quotes eld
\end_inset

o may not have been initialized
\begin_inset Quotes erd
\end_inset

 error):
\end_layout

\begin_layout LyX-Code
Object o = null;
\end_layout

\begin_layout LyX-Code
while (...) {
\end_layout

\begin_layout LyX-Code
  o = ...;
\end_layout

\begin_layout LyX-Code
}
\end_layout

\begin_layout LyX-Code
o.m(...); // potential NullPointerException!
\end_layout

\begin_layout Standard
Then we need a data flow analysis that can tell us that, at the 
\family typewriter
INVOKEVIRTUAL
\family default
 instruction corresponding to the last line, the bottom stack value, correspondi
ng to 
\family typewriter
o
\family default
, may be 
\family typewriter
null
\family default
.
 In order to do that we need to distinguish three sets for reference values:
 the 
\family typewriter
NULL
\family default
 set containing the 
\family typewriter
null
\family default
 value, the 
\family typewriter
NONNULL
\family default
 set containing all non null reference values, and the 
\family typewriter
MAYBENULL
\family default
 set containing all the reference values.
 Then we just need to consider that 
\family typewriter
ACONST_NULL
\family default
 pushes the 
\family typewriter
NULL
\family default
 set on the operand stack, while all other instructions that push a reference
 value on the stack push the 
\family typewriter
NONNULL
\family default
 set (in other words we consider that the result of any field access or
 method call is not 
\family typewriter
null
\family default
 -- we cannot do better without a global analysis of all the classes of
 the program).
 The 
\family typewriter
MAYBENULL
\family default
 set is necessary to represent the union of the 
\family typewriter
NULL
\family default
 and 
\family typewriter
NONNULL
\family default
 sets.
\end_layout

\begin_layout Standard
The above rules must be implemented in a custom 
\family typewriter
Interpreter
\family default
 subclass.
 It would be possible to implement it from scratch, but it is also possible,
 and much easier, to implement it by extending the 
\family typewriter
BasicInterpreter
\family default

\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
BasicInterpreter@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
texttt{BasicInterpreter}
\end_layout

\end_inset


\end_layout

\end_inset

 class.
 Indeed, if we consider that 
\family typewriter
BasicValue.REFERENCE_VALUE
\family default
 corresponds to the 
\family typewriter
NONNULL
\family default
 set, then we just need to override the method that simulates the execution
 of 
\family typewriter
ACONST_NULL
\family default
, so that it returns 
\family typewriter
NULL
\family default
, as well as the method that computes set unions:
\end_layout

\begin_layout LyX-Code
class IsNullInterpreter extends BasicInterpreter {
\end_layout

\begin_layout LyX-Code
  public final static BasicValue NULL = new BasicValue(null);
\end_layout

\begin_layout LyX-Code
  public final static BasicValue MAYBENULL = new BasicValue(null);
\end_layout

\begin_layout LyX-Code
  public IsNullInterpreter() {
\end_layout

\begin_layout LyX-Code
    super(ASM4);
\end_layout

\begin_layout LyX-Code
  }
\end_layout

\begin_layout LyX-Code
  @Override public BasicValue newOperation(AbstractInsnNode insn) {
\end_layout

\begin_layout LyX-Code
    
\series bold
if (insn.getOpcode() == ACONST_NULL) {
\end_layout

\begin_layout LyX-Code
 
\series bold
     return NULL;
\end_layout

\begin_layout LyX-Code
 
\series bold
   }
\end_layout

\begin_layout LyX-Code
    return super.newOperation(insn);
\end_layout

\begin_layout LyX-Code
  }
\end_layout

\begin_layout LyX-Code
  @Override public BasicValue merge(BasicValue v, BasicValue w) {
\end_layout

\begin_layout LyX-Code
    
\series bold
if (isRef(v) && isRef(w) && v != w) {
\end_layout

\begin_layout LyX-Code
 
\series bold
     return MAYBENULL;
\end_layout

\begin_layout LyX-Code
 
\series bold
   }
\end_layout

\begin_layout LyX-Code
    return super.merge(v, w);
\end_layout

\begin_layout LyX-Code
  }
\end_layout

\begin_layout LyX-Code
  private boolean isRef(Value v) {
\end_layout

\begin_layout LyX-Code
    return v == REFERENCE_VALUE || v == NULL || v == MAYBENULL;
\end_layout

\begin_layout LyX-Code
  }
\end_layout

\begin_layout LyX-Code
}
\end_layout

\begin_layout Standard
It is then easy to use this 
\family typewriter
IsNullnterpreter
\family default
 in order to detect instructions that can lead to potential null pointer
 exceptions:
\end_layout

\begin_layout LyX-Code
public class NullDereferenceAnalyzer {
\end_layout

\begin_layout LyX-Code
  public List<AbstractInsnNode> findNullDereferences(String owner,
\end_layout

\begin_layout LyX-Code
      MethodNode mn) throws AnalyzerException {
\end_layout

\begin_layout LyX-Code
    List<AbstractInsnNode> result = new ArrayList<AbstractInsnNode>();
\end_layout

\begin_layout LyX-Code
    
\series bold
Analyzer<BasicValue> a = 
\end_layout

\begin_layout LyX-Code

\series bold
        new Analyzer<BasicValue>(new IsNullInterpreter());
\end_layout

\begin_layout LyX-Code
 
\series bold
   a.analyze(owner, mn);
\end_layout

\begin_layout LyX-Code
    Frame<BasicValue>[] frames = a.getFrames();
\end_layout

\begin_layout LyX-Code
    AbstractInsnNode[] insns = mn.instructions.toArray();
\end_layout

\begin_layout LyX-Code
    for (int i = 0; i < insns.length; ++i) {
\end_layout

\begin_layout LyX-Code
      AbstractInsnNode insn = insns[i];
\end_layout

\begin_layout LyX-Code
      if (frames[i] != null) {
\end_layout

\begin_layout LyX-Code
        
\series bold
Value v = getTarget(insn, frames[i]);
\end_layout

\begin_layout LyX-Code
 
\series bold
       if (v == NULL || v == MAYBENULL) {
\end_layout

\begin_layout LyX-Code
 
\series bold
         result.add(insn);
\end_layout

\begin_layout LyX-Code
 
\series bold
       }
\end_layout

\begin_layout LyX-Code
      }
\end_layout

\begin_layout LyX-Code
    }
\end_layout

\begin_layout LyX-Code
    return result;
\end_layout

\begin_layout LyX-Code
  }
\end_layout

\begin_layout LyX-Code
  private static BasicValue getTarget(AbstractInsnNode insn,
\end_layout

\begin_layout LyX-Code
      Frame<BasicValue> f) {
\end_layout

\begin_layout LyX-Code
    switch (insn.getOpcode()) {
\end_layout

\begin_layout LyX-Code
    case GETFIELD:
\end_layout

\begin_layout LyX-Code
    case ARRAYLENGTH:
\end_layout

\begin_layout LyX-Code
    case MONITORENTER:
\end_layout

\begin_layout LyX-Code
    case MONITOREXIT:
\end_layout

\begin_layout LyX-Code
      return getStackValue(f, 0);
\end_layout

\begin_layout LyX-Code
    case PUTFIELD:
\end_layout

\begin_layout LyX-Code
      return getStackValue(f, 1);
\end_layout

\begin_layout LyX-Code
    case INVOKEVIRTUAL:
\end_layout

\begin_layout LyX-Code
    case INVOKESPECIAL:
\end_layout

\begin_layout LyX-Code
    case INVOKEINTERFACE:
\end_layout

\begin_layout LyX-Code
      String desc = ((MethodInsnNode) insn).desc;
\end_layout

\begin_layout LyX-Code
      return getStackValue(f, Type.getArgumentTypes(desc).length);
\end_layout

\begin_layout LyX-Code
    }
\end_layout

\begin_layout LyX-Code
    return null;
\end_layout

\begin_layout LyX-Code
  }
\end_layout

\begin_layout LyX-Code
  private static BasicValue getStackValue(Frame<BasicValue> f, 
\end_layout

\begin_layout LyX-Code
      int index) {
\end_layout

\begin_layout LyX-Code
    int top = f.getStackSize() - 1;
\end_layout

\begin_layout LyX-Code
    return index <= top ? f.getStack(top - index) : null;
\end_layout

\begin_layout LyX-Code
  }
\end_layout

\begin_layout LyX-Code
}
\end_layout

\begin_layout Standard
The 
\family typewriter
findNullDereferences
\family default
 method analyzes the given method node with an 
\family typewriter
IsNullInterpreter
\family default
.
 It then tests, for each instruction, if the set of possible values of its
 reference operand (if any) is the 
\family typewriter
NULL
\family default
 or the 
\family typewriter
NONNULL
\family default
 set.
 If it is the case this instruction may lead to a null pointer exception,
 so it is added to the list of such instructions that is returned by this
 method.
 
\end_layout

\begin_layout Standard
The 
\family typewriter
getTarget
\family default
 method returns the 
\family typewriter
Value
\family default
 corresponding to the object operand of 
\family typewriter
insn
\family default
, in the frame 
\family typewriter
f
\family default
, or 
\family typewriter
null
\family default
 if 
\family typewriter
insn
\family default
 does not have an object operand.
 Its main role is to compute the offset of this value from the top of the
 operand stack, which depends on the type of instruction.
\end_layout

\begin_layout Subsection
Control flow analysis
\end_layout

\begin_layout Standard
Control flow analyses can have many applications.
 A simple example is to compute the 
\emph on
cyclomatic complexity
\emph default
 of methods.
 This metric is defined as the number of edges in the control flow graph,
 minus the number of nodes, plus two.
 For instance the cyclomatic complexity of the 
\family typewriter
checkAndSetF
\family default
 method, whose control flow graph is shown in section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Control-flow-analyses"

\end_inset

, is 
\begin_inset Formula $11-12+2=1$
\end_inset

.
 This metric gives a good indication of the 
\begin_inset Quotes eld
\end_inset

complexity
\begin_inset Quotes erd
\end_inset

 of a method (there is a correlation between this number and the average
 number of bugs in a method).
 It also gives the recommended number of test cases that are necessary to
 
\begin_inset Quotes eld
\end_inset

correctly
\begin_inset Quotes erd
\end_inset

 test a method.
\end_layout

\begin_layout Standard
The algorithm to compute this metric can be implemented with the ASM analysis
 framework (there are more efficient ways, based on the core API alone,
 but they require to write more code).
 The first step consits in constructing the control flow graph.
 As we said at the begining of this chapter, this can be done by overriding
 the 
\family typewriter
newControlFlowEdge
\family default
 method of the 
\family typewriter
Analyzer
\family default
 class.
 This class represents nodes as 
\family typewriter
Frame
\family default
 objects.
 If we want to store the graph in these objects, we need to extend the 
\family typewriter
Frame
\family default
 class:
\end_layout

\begin_layout LyX-Code
class Node<V extends Value> extends Frame<V> {
\end_layout

\begin_layout LyX-Code
  Set< Node<V> > successors = new HashSet< Node<V> >();
\end_layout

\begin_layout LyX-Code
  public Node(int nLocals, int nStack) {
\end_layout

\begin_layout LyX-Code
    super(nLocals, nStack);
\end_layout

\begin_layout LyX-Code
  }
\end_layout

\begin_layout LyX-Code
  public Node(Frame<? extends V> src) {
\end_layout

\begin_layout LyX-Code
    super(src);
\end_layout

\begin_layout LyX-Code
  }
\end_layout

\begin_layout LyX-Code
}
\end_layout

\begin_layout Standard
Then we can provide an 
\family typewriter
Analyzer
\family default
 subclass that constructs our control flow graph, and use its result to
 compute the number of edges, the number of nodes, and finally the cyclomatic
 complexity:
\end_layout

\begin_layout LyX-Code
public class CyclomaticComplexity {
\end_layout

\begin_layout LyX-Code
  public int getCyclomaticComplexity(String owner, MethodNode mn)
\end_layout

\begin_layout LyX-Code
      throws AnalyzerException {
\end_layout

\begin_layout LyX-Code
    Analyzer<BasicValue> a = 
\end_layout

\begin_layout LyX-Code

\series bold
        new Analyzer<BasicValue>(new BasicInterpreter()) {
\end_layout

\begin_layout LyX-Code
 
\series bold
     protected Frame<BasicValue> newFrame(int nLocals, int nStack) {
\end_layout

\begin_layout LyX-Code
 
\series bold
       return new Node<BasicValue>(nLocals, nStack);
\end_layout

\begin_layout LyX-Code
 
\series bold
     }
\end_layout

\begin_layout LyX-Code
 
\series bold
     protected Frame<BasicValue> newFrame(
\end_layout

\begin_layout LyX-Code

\series bold
          Frame<? extends BasicValue> src) {
\end_layout

\begin_layout LyX-Code
 
\series bold
       return new Node<BasicValue>(src);
\end_layout

\begin_layout LyX-Code
 
\series bold
     }
\end_layout

\begin_layout LyX-Code
 
\series bold
     protected void newControlFlowEdge(int src, int dst) {
\end_layout

\begin_layout LyX-Code
 
\series bold
       Node<BasicValue> s = (Node<BasicValue>) getFrames()[src];
\end_layout

\begin_layout LyX-Code
 
\series bold
       s.successors.add((Node<BasicValue>) getFrames()[dst]);
\end_layout

\begin_layout LyX-Code
 
\series bold
     }
\end_layout

\begin_layout LyX-Code
 
\series bold
   };
\end_layout

\begin_layout LyX-Code
    
\series bold
a.analyze(owner, mn);
\end_layout

\begin_layout LyX-Code
    Frame<BasicValue>[] frames = a.getFrames();
\end_layout

\begin_layout LyX-Code
    int edges = 0;
\end_layout

\begin_layout LyX-Code
    int nodes = 0;
\end_layout

\begin_layout LyX-Code
    for (int i = 0; i < frames.length; ++i) {
\end_layout

\begin_layout LyX-Code
      if (frames[i] != null) {
\end_layout

\begin_layout LyX-Code
        edges += ((Node<BasicValue>) frames[i]).successors.size();
\end_layout

\begin_layout LyX-Code
        nodes += 1;
\end_layout

\begin_layout LyX-Code
      }
\end_layout

\begin_layout LyX-Code
    }
\end_layout

\begin_layout LyX-Code
    return edges - nodes + 2;
\end_layout

\begin_layout LyX-Code
  }
\end_layout

\begin_layout LyX-Code
}
\end_layout

\begin_layout Chapter
Metadata
\end_layout

\begin_layout Standard
This chapter presents the tree API for compiled Java classes metadata, such
 as annotations.
 It is very short because these metadata have already been presented in
 chapter 
\begin_inset CommandInset ref
LatexCommand ref
reference "cha:Metadata"

\end_inset

, and because the tree API is simple once the corresponding core API is
 known.
\end_layout

\begin_layout Section
Generics
\end_layout

\begin_layout Standard
The tree API does not provide any support for generic types! Indeed it represent
s generic types with signatures, as in the core API, but does not provide
 a 
\family typewriter
SignatureNode
\family default
 class corresponding to 
\family typewriter
SignatureVisitor
\family default
, although this would be possible (in fact it would be convenient to use
 several 
\family typewriter
Node
\family default
 classes to distinguish between type, method and class signatures, at least).
\end_layout

\begin_layout Section
Annotations
\end_layout

\begin_layout Standard
The tree API for annotations is based on the 
\family typewriter
AnnotationNode
\family default

\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
AnnotationNode@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
texttt{AnnotationNode}
\end_layout

\end_inset


\end_layout

\end_inset

 class, whose public API is the following:
\end_layout

\begin_layout LyX-Code
public class AnnotationNode extends AnnotationVisitor {
\end_layout

\begin_layout LyX-Code
  public String desc;
\end_layout

\begin_layout LyX-Code
  public List<Object> values;
\end_layout

\begin_layout LyX-Code
  public AnnotationNode(String desc);
\end_layout

\begin_layout LyX-Code
  public AnnotationNode(int api, String desc);
\end_layout

\begin_layout LyX-Code
  ...
 // methods of the AnnotationVisitor interface
\end_layout

\begin_layout LyX-Code
  public void accept(AnnotationVisitor av);
\end_layout

\begin_layout LyX-Code
}
\end_layout

\begin_layout Standard
The 
\family typewriter
desc
\family default
 field contains the annotation type, while the 
\family typewriter
values
\family default
 field contains the name value pairs, where each name is followed by its
 associated value (the representation of values is described in the Javadoc).
\end_layout

\begin_layout Standard
As you can see the 
\family typewriter
AnnotationNode
\family default
 class extends the 
\family typewriter
AnnotationVisitor
\family default
 class, and also provides an 
\family typewriter
accept
\family default
 method that takes as parameter an object of this type, like the 
\family typewriter
ClassNode
\family default
 and 
\family typewriter
MethodNode
\family default
 classes with the class and method visitor classes.
 The patterns that we have seen for classes and methods can therefore also
 be used for composing the core and tree API components for annotations.
 For example the 
\begin_inset Quotes eld
\end_inset

anonymous inner class
\begin_inset Quotes erd
\end_inset

 variant of the pattern based on inheritance (see section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:MethodAPICompositionPatterns"

\end_inset

), adapted to annotations, gives:
\end_layout

\begin_layout LyX-Code
public AnnotationVisitor visitAnnotation(String desc, boolean visible) {
\end_layout

\begin_layout LyX-Code
  return 
\series bold
new AnnotationNode(ASM4, desc)
\series default
 {
\end_layout

\begin_layout LyX-Code
    @Override public void visitEnd() {
\end_layout

\begin_layout LyX-Code
      // put your annotation transformation code here
\end_layout

\begin_layout LyX-Code
      
\series bold
accept
\series default
(cv.visitAnnotation(desc, visible));
\end_layout

\begin_layout LyX-Code
    }
\end_layout

\begin_layout LyX-Code
  };
\end_layout

\begin_layout LyX-Code
}
\end_layout

\begin_layout Section
Debug
\end_layout

\begin_layout Standard
The source file from which a class was compiled is stored in the 
\family typewriter
sourceFile
\family default
 field in 
\family typewriter
ClassNode
\family default
.
 The information about source line numbers is stored in 
\family typewriter
LineNumberNode
\family default
 objects, whose class inherits from 
\family typewriter
AbstractInsnNode
\family default
.
 Similarly to the core API, where information about line numbers is visited
 at the same time as instructions, 
\family typewriter
LineNumberNode
\family default
 objects are part of the instruction list.
 Finally the name and type of source local variables is stored in the 
\family typewriter
MethodNode
\family default
's 
\family typewriter
localVariables
\family default
 field, which is a list of 
\family typewriter
LocalVariableNode
\family default
 objects.
\end_layout

\begin_layout Chapter
Backward compatibility
\begin_inset CommandInset label
LatexCommand label
name "chap:Backward-compatibility2"

\end_inset


\end_layout

\begin_layout Section
Introduction
\end_layout

\begin_layout Standard
As with the core API, a new mechanism has been introduced in the tree API
 in ASM 4.0, in order to ensure backward compatibility in the future ASM
 versions.
 However, here again, this property can not be ensured by ASM alone.
 It requires users to follow a few simple guidelines when writing their
 code.
 The goal of this chapter is to present these guidelines, and to give an
 idea of the internal mechanism used in the ASM tree API to ensure backward
 compatibility.
\end_layout

\begin_layout Section
Guidelines
\end_layout

\begin_layout Standard
This section presents the guidelines that you must follow when using the
 ASM tree API, in order to ensure that your code will remain valid with
 any future ASM versions (in the sense of the contract defined in section
 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Backward-compatibility-contract"

\end_inset

).
\end_layout

\begin_layout Standard
First of all, if you write a class generator using the tree API, there is
 no guideline to follow (as with the core API).
 You can create the 
\family typewriter
ClassNode
\family default
 and other elements with any constructor, and use any method of these classes.
\end_layout

\begin_layout Standard
If, on the other hand, you write a class analyzer or a class adapter with
 the tree API, 
\emph on
i.e.
\emph default
, if you use a 
\family typewriter
ClassNode
\family default
 or other similar classes populated directly or indirectly via a 
\family typewriter
ClassReader.accept()
\family default
, or if you override one of these classes, then you must follow a few guidelines
, presented below.
\end_layout

\begin_layout Subsection
Basic rules
\end_layout

\begin_layout Subsubsection*
Creating class nodes
\end_layout

\begin_layout Standard
We consider here the case where you create a 
\family typewriter
ClassNode
\family default
, populate it via a 
\family typewriter
ClassReader
\family default
, and then analyze or transform it before optionally writing the result
 with a 
\family typewriter
ClassWriter
\family default
 (the discussion and guidelines are the same for the other node classes;
 analyzing or transforming a 
\family typewriter
ClassNode
\family default
 created by someone else is discussed in the next section).
 In this case there is only one guideline:
\end_layout

\begin_layout Description
Guideline
\begin_inset space ~
\end_inset

3: to write a class analyzer or adapter with the tree API of ASM version
 
\emph on
X
\emph default
, create your 
\family typewriter
ClassNode
\family default
 by using the constructor with this exact version as argument (as opposed
 to the default constructor, without parameters).
\end_layout

\begin_layout Standard
The goal of this guideline is to throw an error as soon as an unknown feature
 is encountered when populating the 
\family typewriter
ClassNode
\family default
 via a 
\family typewriter
ClassReader
\family default
 (as defined in the backward compatibility contract).
 If you do not follow it, your analysis or transformation code may fail
 later when encountering an unknown element, or it may succeed but produce
 a wrong result because it should not have ignored these unknown elements.
 In other words, the last clause of the contract may not be ensured if this
 guideline is not followed.
\end_layout

\begin_layout Standard
How does this work? Internally, 
\family typewriter
ClassNode
\family default
 is implemented as follows in ASM 4.0 (we reuse here the example of section
 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:BackwardCompatibility-An-example"

\end_inset

):
\end_layout

\begin_layout LyX-Code
public class ClassNode extends ClassVisitor {
\end_layout

\begin_layout LyX-Code
  public ClassNode() {
\end_layout

\begin_layout LyX-Code
    super(ASM4, null); 
\end_layout

\begin_layout LyX-Code
  } 
\end_layout

\begin_layout LyX-Code
  public ClassNode(int api) { 
\end_layout

\begin_layout LyX-Code
    super(api, null); 
\end_layout

\begin_layout LyX-Code
  } 
\end_layout

\begin_layout LyX-Code
  ...
 
\end_layout

\begin_layout LyX-Code
  public void visitSource(String source, String debug) {
\end_layout

\begin_layout LyX-Code
    // store source and debug in local fields ...
\end_layout

\begin_layout LyX-Code
  }
\end_layout

\begin_layout LyX-Code
}
\end_layout

\begin_layout Standard
In ASM 5.0, this code becomes:
\end_layout

\begin_layout LyX-Code
public class ClassNode extends ClassVisitor { 
\end_layout

\begin_layout LyX-Code
  ...
 
\end_layout

\begin_layout LyX-Code
  public void visitSource(String source, String debug) { 
\end_layout

\begin_layout LyX-Code
    if (api < ASM5) { 
\end_layout

\begin_layout LyX-Code
      // store source and debug in local fields ...
 
\end_layout

\begin_layout LyX-Code
    } else { 
\end_layout

\begin_layout LyX-Code
      visitSource(null, source, debug); 
\end_layout

\begin_layout LyX-Code
    } 
\end_layout

\begin_layout LyX-Code
  }
\end_layout

\begin_layout LyX-Code
  public void visitSource(Sring author, String source, String debug) { 
\end_layout

\begin_layout LyX-Code
    if (api < ASM5) {
\end_layout

\begin_layout LyX-Code
      if (author == null) 
\end_layout

\begin_layout LyX-Code
        visitSource(source, debug); 
\end_layout

\begin_layout LyX-Code
      else 
\end_layout

\begin_layout LyX-Code
        throw new RuntimeException(); 
\end_layout

\begin_layout LyX-Code
    } else { 
\end_layout

\begin_layout LyX-Code
      // store author, source and debug in local fields ...
 
\end_layout

\begin_layout LyX-Code
    }
\end_layout

\begin_layout LyX-Code
  } 
\end_layout

\begin_layout LyX-Code
  public void visitLicense(String license) { 
\end_layout

\begin_layout LyX-Code
    if (api < ASM5) throw new RuntimeException(); 
\end_layout

\begin_layout LyX-Code
    // store license in local fields ...
 
\end_layout

\begin_layout LyX-Code
  }
\end_layout

\begin_layout LyX-Code
}
\end_layout

\begin_layout Standard
If you use ASM 4.0, creating a 
\family typewriter
ClassNode(ASM4)
\family default
 does nothing special.
 But if you upgrade to ASM 5.0, without changing your code, you will get
 a 
\family typewriter
ClassNode
\family default
 5.0 whose 
\family typewriter
api
\family default
 field will be 
\family typewriter
ASM4
\family default
 < 
\family typewriter
ASM5
\family default
.
 It is then easy to see that if the input class contains a non null author
 or license attribute, populating the 
\family typewriter
ClassNode
\family default
 via a 
\family typewriter
ClassReader
\family default
 will fail, as defined in our contract.
 If you also upgrade your code, changing the 
\family typewriter
api
\family default
 field to 
\family typewriter
ASM5
\family default
 and also updating the rest of the code to take these new attributes into
 account, then no errors will be thrown when populating the node.
\end_layout

\begin_layout Standard
Note that the 
\family typewriter
ClassNode
\family default
 5.0 code is very similar to the 
\family typewriter
ClassVisitor
\family default
 5.0 code.
 This is to ensure a proper semantics if you define subclasses of 
\family typewriter
ClassNode
\family default
 (similarly to subclasses of 
\family typewriter
ClassVisitor
\family default
 - see section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Tree-Inheritance-rules"

\end_inset

).
\end_layout

\begin_layout Subsubsection*
Using existing class nodes
\end_layout

\begin_layout Standard
If your class analyzer or adapter receives a 
\family typewriter
ClassNode
\family default
 created by someone else, then you cannot be sure of the ASM version that
 was passed to its constructor when it was created, if any.
 You could check the 
\family typewriter
api
\family default
 field yourself, but if you find that this version is higher than the version
 you support, simply rejecting the class would be too conservative.
 Indeed, it may happen that this class does not contain any unknown feature.
 On the other hand, you cannot test if unknown features are present or not
 (in our example scenario, how could you test, when writing code for ASM
 4.0, that the unknown 
\family typewriter
license
\family default
 field is not present in your 
\family typewriter
ClassNode
\family default
, since you do not know at this stage that such a field will be added in
 the future?).
 The 
\family typewriter
ClassNode.check()
\family default
 method is designed to solve this issue.
 This leads to the following guideline:
\end_layout

\begin_layout Description
Guideline
\begin_inset space ~
\end_inset

4: to write a class analyzer or adapter with the tree API of ASM version
 
\emph on
X
\emph default
, using a 
\family typewriter
ClassNode
\family default
 created by someone else, call its 
\family typewriter
check()
\family default
 method with this exact version as argument before using the 
\family typewriter
ClassNode
\family default
 in any way.
\end_layout

\begin_layout Standard
The goal is the same as for guideline 3: the last clause of the contract
 may not be ensured if this guideline is not followed.
 How does this work? Internally, the check method is implemented as follows
 in ASM 4.0
\end_layout

\begin_layout LyX-Code
public class ClassNode extends ClassVisitor { 
\end_layout

\begin_layout LyX-Code
  ...
 
\end_layout

\begin_layout LyX-Code
  public void check(int api) { 
\end_layout

\begin_layout LyX-Code
    // nothing to do 
\end_layout

\begin_layout LyX-Code
  }
\end_layout

\begin_layout LyX-Code
}
\end_layout

\begin_layout Standard
In ASM 5.0 this code becomes:
\end_layout

\begin_layout LyX-Code
public class ClassNode extends ClassVisitor { 
\end_layout

\begin_layout LyX-Code
  ...
\end_layout

\begin_layout LyX-Code
  public void check(int api) {
\end_layout

\begin_layout LyX-Code
    if (api < ASM5 && (author != null || license != null)) {
\end_layout

\begin_layout LyX-Code
      throw new RuntimeException();
\end_layout

\begin_layout LyX-Code
    }
\end_layout

\begin_layout LyX-Code
  }
\end_layout

\begin_layout LyX-Code
}
\end_layout

\begin_layout Standard
If your code is written for ASM 4.0, and if you get a 
\family typewriter
ClassNode
\family default
 4.0, whose 
\family typewriter
api
\family default
 field will be 
\family typewriter
ASM4
\family default
, there will be no problem and 
\family typewriter
check
\family default
 does nothing.
 But if you get a 
\family typewriter
ClassNode
\family default
 5.0, the 
\family typewriter
check(ASM4)
\family default
 method will fail if this node actually contains a non null 
\family typewriter
author
\family default
 or 
\family typewriter
license
\family default
, i.e.
 if it contains new features that were unknown in ASM 4.0.
\end_layout

\begin_layout Description
Note: this guideline can also be used if you create the 
\family typewriter
ClassNode
\family default
 yourself.
 Then you don't need to follow guideline 3, 
\emph on
i.e.
\emph default
, you don't need to specify an ASM version in the ClassNode constructor.
 The checks will occur instead in the 
\family typewriter
check
\family default
 method (but this may be less efficient that doing the checks earlier, when
 populating the 
\family typewriter
ClassNode
\family default
).
\end_layout

\begin_layout Subsection
Inheritance rules
\begin_inset CommandInset label
LatexCommand label
name "sub:Tree-Inheritance-rules"

\end_inset


\end_layout

\begin_layout Standard
If you want to provide subclasses of 
\family typewriter
ClassNode
\family default
 or other similar node classes, then guidelines 1 and 2 apply.
 Note that, in the special case, often used, of a 
\family typewriter
MethodNode
\family default
 anonymous subclass whose 
\family typewriter
visitEnd()
\family default
 method is overriden:
\end_layout

\begin_layout LyX-Code
class MyClassVisitor extends ClassVisitor { 
\end_layout

\begin_layout LyX-Code
  ...
\end_layout

\begin_layout LyX-Code
  public MethodVisitor visitMethod(...) { 
\end_layout

\begin_layout LyX-Code
    final MethodVisitor mv = super.visitMethod(...);
\end_layout

\begin_layout LyX-Code
    if (mv != null) { 
\end_layout

\begin_layout LyX-Code
      return new MethodNode(
\series bold
ASM4
\series default
) { 
\end_layout

\begin_layout LyX-Code
        public void visitEnd() { 
\end_layout

\begin_layout LyX-Code
          // perform a transformation 
\end_layout

\begin_layout LyX-Code
          accept(mv); 
\end_layout

\begin_layout LyX-Code
        }
\end_layout

\begin_layout LyX-Code
      }
\end_layout

\begin_layout LyX-Code
    }
\end_layout

\begin_layout LyX-Code
    return mv;
\end_layout

\begin_layout LyX-Code
  }
\end_layout

\begin_layout LyX-Code
}
\end_layout

\begin_layout Standard
then guideline 2 is automatically enforced (the anonymous class cannot be
 overriden although it is not explicitely declared final).
 You simply need to follow guideline 3, 
\emph on
i.e.
\emph default
, specify an ASM version in the MethodNode constructor (or follow guideline
 4, 
\emph on
i.e.
\emph default
, call 
\family typewriter
check(ASM4)
\family default
 before performing the transformation).
\end_layout

\begin_layout Subsection
Other packages
\end_layout

\begin_layout Standard
The classes in 
\family typewriter
asm.util
\family default
 and 
\family typewriter
asm.commons
\family default
 have two variants of each constructor: one with and one without an ASM
 version parameter.
\end_layout

\begin_layout Standard
If you simply want to instantiate and use as is the 
\family typewriter
ASMifier
\family default
, 
\family typewriter
Textifier
\family default
, or 
\family typewriter
Check
\emph on
Xxx
\emph default
Adapter
\family default
 classes in 
\family typewriter
asm.util
\family default
, or any class in the 
\family typewriter
asm.commons
\family default
 package, then you can instantiate them with a constructor without an ASM
 version parameter.
 You could also use a constructor with an ASM version parameter, but this
 would unnecessarily restrict these components to the specified ASM version
 (while using the no-arg constructor is equivalent to say 
\begin_inset Quotes eld
\end_inset

use the latest ASM version
\begin_inset Quotes erd
\end_inset

).
 This is why the constructors using an ASM version parameter are declared
 
\family typewriter
protected
\family default
.
\end_layout

\begin_layout Standard
If, on the other hand, you want to override the 
\family typewriter
ASMifier
\family default
, 
\family typewriter
TextifierVisitor
\family default
, or 
\family typewriter
CheckXxxAdapter
\family default
 classes in 
\family typewriter
asm.util
\family default
, or any class in the 
\family typewriter
asm.commons
\family default
 package, then the guidelines 1 and 2 apply.
 In particular, your constructor 
\emph on
must
\emph default
 call 
\family typewriter
super(...)
\family default
 with the ASM version you want to use as parameter.
\end_layout

\begin_layout Standard
Finally, the same distinction must be made if you want to use vs.
 override the 
\family typewriter
Interpreter
\family default
 class or its subclasses in 
\family typewriter
asm.tree.analysis
\family default
.
 Note also that before using the analysis package you must create a 
\family typewriter
MethodNode
\family default
 or get one from someone else, and that guidelines 3 and 4 must be used
 here before passing this node to an 
\family typewriter
Analyzer
\family default
.
 
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
appendix
\end_layout

\end_inset


\end_layout

\begin_layout Chapter
Appendix
\end_layout

\begin_layout Section
Bytecode instructions
\begin_inset CommandInset label
LatexCommand label
name "app:Bytecode-instructions"

\end_inset


\end_layout

\begin_layout Standard
This section gives a short description of the bytecode instructions.
 For a complete description, see the Java Virtual Machine Specification.
\end_layout

\begin_layout Description
Conventions: a and b represent 
\family typewriter
int
\family default
, 
\family typewriter
float
\family default
, 
\family typewriter
long
\family default
 or 
\family typewriter
double
\family default
 values (
\emph on
e.g.
\emph default
, they mean 
\family typewriter
int
\family default
 for 
\family typewriter
IADD
\family default
 but 
\family typewriter
long
\family default
 for 
\family typewriter
LADD
\family default
), o and p represent objet references, v represents any value (or, for stack
 instructions, a value of size 1), w represents a 
\family typewriter
long
\family default
 or 
\family typewriter
double
\family default
, and i, j and n represent 
\family typewriter
int
\family default
 values.
\end_layout

\begin_layout Subsubsection*
Local variables
\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="6" columns="3">
<features islongtable="true" longtabularalignment="center">
<column alignment="left" valignment="top" width="0">
<column alignment="left" valignment="top" width="0">
<column alignment="left" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Instruction
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Stack before
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Stack after
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
ILOAD
\family default
, 
\family typewriter
LLOAD
\family default
, 
\family typewriter
FLOAD
\family default
, 
\family typewriter
DLOAD
\family default
 
\emph on
var
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
 , a
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
ALOAD
\family default
 
\emph on
var
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
 , o
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
ISTORE
\family default
, 
\family typewriter
LSTORE
\family default
, 
\family typewriter
FSTORE
\family default
, 
\family typewriter
DSTORE
\family default
 
\emph on
var
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
 , a
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
ASTORE
\family default
 
\emph on
var
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
 , o
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
IINC
\family default
 
\emph on
var
\emph default
 
\emph on
incr
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Subsubsection*
Stack
\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="16" columns="3">
<features islongtable="true" longtabularalignment="center">
<column alignment="left" valignment="top" width="0">
<column alignment="left" valignment="top" width="0">
<column alignment="left" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
POP
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
 , v
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
POP2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
 , v
\begin_inset Formula $_{\text{1}}$
\end_inset

 , v
\begin_inset Formula $_{2}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
\end_layout

\end_inset
</cell>
</row>
<row>
<cell multicolumn="1" alignment="left" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
 , w
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
DUP
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
 , v
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
 , v , 
\series bold
v
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
DUP2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
 , v
\begin_inset Formula $_{\text{1}}$
\end_inset

 , v
\begin_inset Formula $_{2}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
 , v
\begin_inset Formula $_{\text{1}}$
\end_inset

 , v
\begin_inset Formula $_{2}$
\end_inset

 , 
\series bold
v
\begin_inset Formula $_{\text{\textbf{1}}}$
\end_inset


\series default
 , 
\series bold
v
\begin_inset Formula $_{\mathbf{2}}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell multicolumn="1" alignment="left" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
 , w
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
 , w, 
\series bold
w
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
SWAP
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
 , v
\begin_inset Formula $_{\text{1}}$
\end_inset

 , v
\begin_inset Formula $_{2}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
 , v
\begin_inset Formula $\mathbf{_{2}}$
\end_inset

 , v
\begin_inset Formula $\mathbf{_{1}}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
DUP_X1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
 , v
\begin_inset Formula $_{\text{1}}$
\end_inset

 , v
\begin_inset Formula $_{2}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
 , 
\series bold
v
\series default

\begin_inset Formula $_{\mathbf{2}}$
\end_inset

 , v
\begin_inset Formula $_{\text{1}}$
\end_inset

 , v
\begin_inset Formula $_{2}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
DUP_X2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
 , v
\begin_inset Formula $_{\text{1}}$
\end_inset

 , v
\begin_inset Formula $_{2}$
\end_inset

 , v
\begin_inset Formula $_{3}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
 , 
\series bold
v
\begin_inset Formula $\mathbf{_{3}}$
\end_inset


\series default
 , v
\begin_inset Formula $_{\text{1}}$
\end_inset

 , v
\begin_inset Formula $_{2}$
\end_inset

 , v
\begin_inset Formula $_{3}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell multicolumn="1" alignment="left" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
 , w , v
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
 , 
\series bold
v
\series default
 , w , v
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
DUP2_X1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
 , v
\begin_inset Formula $_{\text{1}}$
\end_inset

 , v
\begin_inset Formula $_{2}$
\end_inset

 , v
\begin_inset Formula $_{3}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
 , 
\series bold
v
\begin_inset Formula $_{\mathbf{2}}$
\end_inset


\series default
 , 
\series bold
v
\begin_inset Formula $_{\mathbf{3}}$
\end_inset


\series default
 , v
\begin_inset Formula $_{\text{1}}$
\end_inset

 , v
\begin_inset Formula $_{2}$
\end_inset

 , v
\begin_inset Formula $_{3}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell multicolumn="1" alignment="left" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
 , v , w
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
 , 
\series bold
w
\series default
 , v , w
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
DUP2_X2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
 , v
\begin_inset Formula $_{\text{1}}$
\end_inset

 , v
\begin_inset Formula $_{2}$
\end_inset

 , v
\begin_inset Formula $_{3}$
\end_inset

 , v
\begin_inset Formula $_{4}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
 , 
\series bold
v
\begin_inset Formula $\mathbf{_{3}}$
\end_inset


\series default
 , 
\series bold
v
\begin_inset Formula $\mathbf{_{4}}$
\end_inset


\series default
 , v
\begin_inset Formula $_{\text{1}}$
\end_inset

 , v
\begin_inset Formula $_{2}$
\end_inset

 , v
\begin_inset Formula $_{3}$
\end_inset

 , v
\begin_inset Formula $_{4}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell multicolumn="1" alignment="left" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
 , w , v
\begin_inset Formula $_{\text{1}}$
\end_inset

 , v
\begin_inset Formula $_{2}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
 , 
\series bold
v
\begin_inset Formula $\mathbf{_{1}}$
\end_inset


\series default
 , 
\series bold
v
\begin_inset Formula $\mathbf{_{2}}$
\end_inset


\series default
 , w , v
\begin_inset Formula $_{\text{1}}$
\end_inset

 , v
\begin_inset Formula $_{2}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell multicolumn="1" alignment="left" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
....
 , v
\begin_inset Formula $_{\text{1}}$
\end_inset

 , v
\begin_inset Formula $_{2}$
\end_inset

 , w
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
 , 
\series bold
w
\series default
 , v
\begin_inset Formula $_{\text{1}}$
\end_inset

 , v
\begin_inset Formula $_{2}$
\end_inset

 , w
\end_layout

\end_inset
</cell>
</row>
<row>
<cell multicolumn="1" alignment="left" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
 , w
\begin_inset Formula $_{\text{1}}$
\end_inset

 , w
\begin_inset Formula $_{2}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
 , 
\series bold
w
\series default

\begin_inset Formula $_{\mathbf{2}}$
\end_inset

 , w
\begin_inset Formula $_{\text{1}}$
\end_inset

 , w
\begin_inset Formula $_{2}$
\end_inset

 
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Subsubsection*
Constants
\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="8" columns="3">
<features islongtable="true" longtabularalignment="center">
<column alignment="left" valignment="top" width="0">
<column alignment="left" valignment="top" width="0">
<column alignment="left" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
ICONST_
\emph on
n
\family default
\emph default
 
\size footnotesize
(
\family typewriter

\begin_inset Formula $-1\leq n\leq5$
\end_inset


\family default
)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
 , 
\emph on
n
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
LCONST_
\emph on
n
\family default
\emph default
 
\size footnotesize
(
\family typewriter

\begin_inset Formula $0\leq n\leq1$
\end_inset


\family default
)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
 , 
\emph on
nL
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
FCONST_
\emph on
n
\family default
\emph default
 
\size footnotesize
(
\family typewriter

\begin_inset Formula $0\leq n\leq2$
\end_inset


\family default
)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
 , 
\emph on
nF
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
DCONST_
\emph on
n
\family default
\emph default
 
\size footnotesize
(
\family typewriter

\begin_inset Formula $0\leq n\leq1$
\end_inset


\family default
)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
 , 
\emph on
nD
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
BIPUSH
\family default
 
\emph on
b
\emph default
, 
\begin_inset Formula $-128\leq b<127$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
 , 
\emph on
b
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
SIPUSH
\family default
 
\emph on
s
\emph default
, 
\begin_inset Formula $-32768\leq s<32767$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
 , 
\emph on
s
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
LDC
\family default
 
\emph on
cst 
\size footnotesize
\emph default
(
\family typewriter
int
\family default
, 
\family typewriter
float
\family default
, 
\family typewriter
long
\family default
, 
\family typewriter
double
\family default
, 
\family typewriter
String
\family default
 or 
\family typewriter
Type
\family default
)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
 , 
\emph on
cst
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
ACONST_NULL
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
 , 
\family typewriter
null
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Subsubsection*
Arithmetic and logic
\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="15" columns="3">
<features islongtable="true" longtabularalignment="center">
<column alignment="left" valignment="top" width="0">
<column alignment="left" valignment="top" width="0">
<column alignment="left" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
IADD
\family default
, 
\family typewriter
LADD
\family default
, 
\family typewriter
FADD
\family default
, 
\family typewriter
DADD
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
 , a , b
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
 , a 
\family typewriter
+
\family default
 b
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
ISUB
\family default
, 
\family typewriter
LSUB
\family default
, 
\family typewriter
FSUB
\family default
, 
\family typewriter
DSUB
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
 , a , b
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
 , a 
\family typewriter
-
\family default
 b
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
IMUL
\family default
, 
\family typewriter
LMUL
\family default
, 
\family typewriter
FMUL
\family default
, 
\family typewriter
DMUL
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
 , a , b
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
 , a 
\family typewriter
*
\family default
 b
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
IDIV
\family default
, 
\family typewriter
LDIV
\family default
, 
\family typewriter
FDIV
\family default
, 
\family typewriter
DDIV
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
 , a , b
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
 , a 
\family typewriter
/
\family default
 b
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
IREM
\family default
, 
\family typewriter
LREM
\family default
, 
\family typewriter
FREM
\family default
, 
\family typewriter
DREM
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
 , a , b
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
 , a 
\family typewriter
%
\family default
 b
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
INEG
\family default
, 
\family typewriter
LNEG
\family default
, 
\family typewriter
FNEG
\family default
, 
\family typewriter
DNEG
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
 , a
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
 , 
\family typewriter
-
\family default
a
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
ISHL
\family default
, 
\family typewriter
LSHL
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
 , a , n
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
 , a 
\family typewriter
<<
\family default
 n
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
ISHR
\family default
, 
\family typewriter
LSHR
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
 , a , n
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
 , a 
\family typewriter
>>
\family default
 n
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
IUSHR
\family default
, 
\family typewriter
LUSHR
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
 , a , n
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
 , a 
\family typewriter
>>>
\family default
 n
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
IAND
\family default
, 
\family typewriter
LAND
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
 , a , b
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
 , a 
\family typewriter
&
\family default
 b
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
IOR
\family default
, 
\family typewriter
LOR
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
 , a , b
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
 , a 
\family typewriter
|
\family default
 b
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
IXOR
\family default
, 
\family typewriter
LXOR
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
 , a , b
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
 , a 
\family typewriter
^
\family default
 b
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
LCMP
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
 , a , b
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
 ,
\size footnotesize
 a 
\family typewriter
==
\family default
 b 
\family typewriter
?
\family default
 
\family typewriter
0
\family default
 
\family typewriter
:
\family default
 
\family typewriter
(
\family default
a 
\family typewriter
<
\family default
 b 
\family typewriter
?
\family default
 
\family typewriter
-1
\family default
 
\family typewriter
:
\family default
 
\family typewriter
1)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
FCMPL
\family default
, 
\family typewriter
FCMPG
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
 , a , b
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
 , 
\size footnotesize
a 
\family typewriter
==
\family default
 b 
\family typewriter
?
\family default
 
\family typewriter
0
\family default
 
\family typewriter
:
\family default
 
\family typewriter
(
\family default
a 
\family typewriter
<
\family default
 b 
\family typewriter
?
\family default
 
\family typewriter
-1
\family default
 
\family typewriter
:
\family default
 
\family typewriter
1)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
DCMPL
\family default
, 
\family typewriter
DCMPG
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
 , a , b
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
 ,
\size footnotesize
 a 
\family typewriter
==
\family default
 b 
\family typewriter
?
\family default
 
\family typewriter
0
\family default
 
\family typewriter
:
\family default
 
\family typewriter
(
\family default
a 
\family typewriter
<
\family default
 b 
\family typewriter
?
\family default
 
\family typewriter
-1
\family default
 
\family typewriter
:
\family default
 
\family typewriter
1)
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Subsubsection*
Casts
\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="8" columns="3">
<features islongtable="true" longtabularalignment="center">
<column alignment="left" valignment="top" width="0">
<column alignment="left" valignment="top" width="0">
<column alignment="left" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
I2B
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
 , i
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
 , 
\family typewriter
(byte)
\family default
 i
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
I2C
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
 , i
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
 , 
\family typewriter
(char)
\family default
 i
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
I2S
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
 , i
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
 , 
\family typewriter
(short)
\family default
 i
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
L2I
\family default
, 
\family typewriter
F2I
\family default
, 
\family typewriter
D2I
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
 , a
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
 , 
\family typewriter
(int)
\family default
 a
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
I2L
\family default
, 
\family typewriter
F2L
\family default
, 
\family typewriter
D2L
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
 , a
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
 , 
\family typewriter
(long)
\family default
 a
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
I2F
\family default
, 
\family typewriter
L2F
\family default
, 
\family typewriter
D2F
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
 , a
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
 , 
\family typewriter
(float)
\family default
 a
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
I2D
\family default
, 
\family typewriter
L2D
\family default
, 
\family typewriter
F2D
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
 , a
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
 , 
\family typewriter
(double)
\family default
 a
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
CHECKCAST
\family default
 
\emph on
class
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
 , o
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
 , 
\family typewriter
(
\family default
\emph on
class
\family typewriter
\emph default
)
\family default
 o
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Subsubsection*
Objects, fields and methods
\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="13" columns="3">
<features islongtable="true" longtabularalignment="center">
<column alignment="left" valignment="top" width="0">
<column alignment="left" valignment="top" width="0">
<column alignment="left" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
NEW
\family default
 
\emph on
class
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
 , 
\family typewriter
new
\family default
 
\emph on
class
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
GETFIELD
\family default
 
\emph on
c
\emph default
 
\emph on
f
\emph default
 
\emph on
t
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
 , o
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
 , o
\family typewriter
.
\family default
\emph on
f
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
PUTFIELD
\family default
 
\emph on
c
\emph default
 
\emph on
f
\emph default
 
\emph on
t
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
 , o , v
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
GETSTATIC
\family default
 
\emph on
c
\emph default
 
\emph on
f
\emph default
 
\emph on
t
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
 , 
\emph on
c
\family typewriter
\emph default
.
\family default
\emph on
f
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
PUTSTATIC
\family default
 
\emph on
c
\emph default
 
\emph on
f
\emph default
 
\emph on
t
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
 , v
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
INVOKEVIRTUAL
\family default
 
\emph on
c
\emph default
 
\emph on
m
\emph default
 
\emph on
t
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
 , o , v
\begin_inset Formula $_{1}$
\end_inset

 , ...
 , v
\begin_inset Formula $_{n}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
 , o
\family typewriter
.
\family default
\emph on
m
\family typewriter
\emph default
(
\family default
v
\begin_inset Formula $_{1}$
\end_inset


\family typewriter
,
\family default
 ...
 v
\begin_inset Formula $_{n}$
\end_inset


\family typewriter
)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
INVOKESPECIAL
\family default
 
\emph on
c
\emph default
 
\emph on
m
\emph default
 
\emph on
t
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
 , o , v
\begin_inset Formula $_{1}$
\end_inset

 , ...
 , v
\begin_inset Formula $_{n}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
 , o
\family typewriter
.
\family default
\emph on
m
\family typewriter
\emph default
(
\family default
v
\begin_inset Formula $_{1}$
\end_inset


\family typewriter
,
\family default
 ...
 v
\begin_inset Formula $_{n}$
\end_inset


\family typewriter
)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
INVOKESTATIC
\family default
 
\emph on
c
\emph default
 
\emph on
m
\emph default
 
\emph on
t
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
 , v
\begin_inset Formula $_{1}$
\end_inset

 , ...
 , v
\begin_inset Formula $_{n}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
 , 
\emph on
c
\family typewriter
\emph default
.
\family default
\emph on
m
\family typewriter
\emph default
(
\family default
v
\begin_inset Formula $_{1}$
\end_inset


\family typewriter
,
\family default
 ...
 v
\begin_inset Formula $_{n}$
\end_inset


\family typewriter
)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
INVOKEINTERFACE
\family default
 
\emph on
c
\emph default
 
\emph on
m
\emph default
 
\emph on
t
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
 , o , v
\begin_inset Formula $_{1}$
\end_inset

 , ...
 , v
\begin_inset Formula $_{n}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
 , o
\family typewriter
.
\family default
\emph on
m
\family typewriter
\emph default
(
\family default
v
\begin_inset Formula $_{1}$
\end_inset


\family typewriter
,
\family default
 ...
 v
\begin_inset Formula $_{n}$
\end_inset


\family typewriter
)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
INVOKEDYNAMIC
\family default
 
\emph on
m
\emph default
 
\emph on
t bsm
\emph default
 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
 , o , v
\begin_inset Formula $_{1}$
\end_inset

 , ...
 , v
\begin_inset Formula $_{n}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
 , o
\family typewriter
.
\family default
\emph on
m
\family typewriter
\emph default
(
\family default
v
\begin_inset Formula $_{1}$
\end_inset


\family typewriter
,
\family default
 ...
 v
\begin_inset Formula $_{n}$
\end_inset


\family typewriter
)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
INSTANCEOF
\family default
 
\emph on
class
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
 , o
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
 , o 
\family typewriter
instanceof
\family default
 
\emph on
class
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
MONITORENTER
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
 , o
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
MONITOREXIT
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
 , o
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Subsubsection*
Arrays
\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="10" columns="3">
<features islongtable="true" longtabularalignment="center">
<column alignment="left" valignment="top" width="0">
<column alignment="left" valignment="top" width="0">
<column alignment="left" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
NEWARRAY
\family default
 
\emph on
type
\emph default
 
\size footnotesize
(for any primitive type)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
 , n
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
 , 
\family typewriter
new
\family default
 
\emph on
type
\family typewriter
\emph default
[
\family default
n
\family typewriter
]
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
ANEWARRAY
\family default
 
\emph on
class
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
 , n
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
 , 
\family typewriter
new
\family default
 
\emph on
class
\family typewriter
\emph default
[
\family default
n
\family typewriter
]
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
MULTIANEWARRAY
\family default
 
\emph on
[...[t n
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
...
 , i
\begin_inset Formula $_{\text{1}}$
\end_inset

 , ...
 , i
\begin_inset Formula $_{\text{n}}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
...
 , 
\family typewriter
new
\family default
 
\emph on
t
\family typewriter
\emph default
[
\family default
i
\begin_inset Formula $_{\text{1}}$
\end_inset


\family typewriter
]
\family default
...
\family typewriter
[
\family default
i
\begin_inset Formula $_{\text{n}}$
\end_inset


\family typewriter
]
\family default
...
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
BALOAD,
\family default
\size normal
\noun off
\color none
 
\family typewriter
\size default
\noun default
CALOAD
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
,
\family default
\series default
\shape default
\emph default
\bar default
 
\family typewriter
\size default
\noun default
SALOAD
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
 , o , i
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
 , o
\family typewriter
[
\family default
i
\family typewriter
]
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
IALOAD
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none
,
\family default
\series default
\shape default
\emph default
\bar default
 
\family typewriter
\size default
\noun default
LALOAD
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
,
\family default
\series default
\shape default
\emph default
\bar default
 
\family typewriter
\size default
\noun default
FALOAD
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
,
\family default
\series default
\shape default
\emph default
\bar default
 
\family typewriter
\size default
\noun default
DALOAD
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
 , o , i
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
 , o
\family typewriter
[
\family default
i
\family typewriter
]
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
AALOAD
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
 , o , i
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
 , o
\family typewriter
[
\family default
i
\family typewriter
]
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
BASTORE
\family default
, 
\family typewriter
CASTORE
\family default
, 
\family typewriter
SASTORE
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
 , o , i , j
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
IASTORE
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none
,
\family default
\series default
\shape default
\emph default
\bar default
 
\family typewriter
\size default
\noun default
LASTORE
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
,
\family default
\series default
\shape default
\emph default
\bar default
 
\family typewriter
\size default
\noun default
FASTORE
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
,
\family default
\series default
\shape default
\emph default
\bar default
 
\family typewriter
\size default
\noun default
DASTORE
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
 , o , i , a
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
AASTORE
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
 , o , i , p
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
ARRAYLENGTH
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
 , o
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
 , o
\family typewriter
.length
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Subsubsection*
Jumps
\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="19" columns="4">
<features islongtable="true" longtabularalignment="center">
<column alignment="left" valignment="top" width="0">
<column alignment="left" valignment="top" width="0">
<column alignment="left" valignment="top" width="1cm">
<column alignment="left" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
IFEQ
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
 , i
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
jump if i 
\family typewriter
==
\family default
 
\family typewriter
0
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
IFNE
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
 , i
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
jump if i 
\family typewriter
!=
\family default
 
\family typewriter
0
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
IFLT
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
 , i
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
jump if i 
\family typewriter
<
\family default
 
\family typewriter
0
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
IFGE
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
 , i
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
jump if i 
\family typewriter
>=
\family default
 
\family typewriter
0
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
IFGT
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
 , i
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
jump if i 
\family typewriter
>
\family default
 
\family typewriter
0
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
IFLE
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
 , i
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
jump if i 
\family typewriter
<=
\family default
 
\family typewriter
0
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
IF_ICMPEQ
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
 , i , j
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
jump if i 
\family typewriter
==
\family default
 j
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
IF_ICMPNE
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
 , i , j
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
jump if i 
\family typewriter
!=
\family default
 j
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
IF_ICMPLT
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
 , i , j
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
jump if i 
\family typewriter
<
\family default
 j
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
IF_ICMPGE
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
 , i , j
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
jump if i 
\family typewriter
>=
\family default
 j
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
IF_ICMPGT
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
 , i , j
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
jump if i 
\family typewriter
>
\family default
 j
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
IF_ICMPLE
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
 , i , j
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
jump if i 
\family typewriter
<=
\family default
 j
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
IF_ACMPEQ
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
 , o , p
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
jump if o 
\family typewriter
==
\family default
 p
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
IF_ACMPNE
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
 , o , p
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
jump if o 
\family typewriter
!=
\family default
 p
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
IFNULL
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
 , o
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
jump if o 
\family typewriter
==
\family default
 
\family typewriter
null
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
IFNONNULL
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
 , o
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
jump if o 
\family typewriter
!=
\family default
 
\family typewriter
null
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
GOTO
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
jump always
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
TABLESWITCH
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
 , i
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
jump always
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
LOOKUPSWITCH
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
 , i
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
jump always
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Subsubsection*
Return
\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="3">
<features islongtable="true" longtabularalignment="center">
<column alignment="left" valignment="top" width="0">
<column alignment="left" valignment="top" width="0">
<column alignment="left" valignment="top" width="1cm">
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
IRETURN
\family default
, 
\family typewriter
LRETURN
\family default
, 
\family typewriter
FRETURN
\family default
, 
\family typewriter
DRETURN 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
 , a
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset space ~
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
ARETURN
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
 , o
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
RETURN
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
ATHROW
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
 , o
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Section
Subroutines
\begin_inset CommandInset label
LatexCommand label
name "sec:Subroutines"

\end_inset


\end_layout

\begin_layout Standard
In addition two the bytecode instructions presented in the previous section,
 classes whose version is 
\emph on
lower
\emph default
 than or equal to 
\family typewriter
V1_5
\family default
 can also contain the 
\family typewriter
JSR
\family default
 and 
\family typewriter
RET
\family default
 instructions, used for subroutines (
\family typewriter
JSR
\family default
 means Jump to SubRoutine, and 
\family typewriter
RET
\family default
 means RETurn from subroutine).
 Classes whose version is higher than or equal to 
\family typewriter
V1_6
\family default
 must 
\emph on
not
\emph default
 contain these instructions (they have been removed to simplify the new
 verifier architecture introduced in Java 6; this was possible because they
 are not strictly necessary).
\end_layout

\begin_layout Standard
The 
\family typewriter
JSR
\family default
 instruction takes a label as argument, and jumps unconditionaly to this
 label.
 Before doing so however, it pushes on the operand stack a 
\emph on
return address
\emph default
, which is the index of the instruction just after the 
\family typewriter
JSR
\family default
.
 This return address can be manipulated only by the stack instructions such
 as 
\family typewriter
POP
\family default
, 
\family typewriter
DUP
\family default
 or 
\family typewriter
SWAP
\family default
, by the 
\family typewriter
ASTORE
\family default
 instruction, and by the 
\family typewriter
RET
\family default
 instruction.
\end_layout

\begin_layout Standard
The 
\family typewriter
RET
\family default
 instruction takes a local variable index as argument.
 It loads the return address contained in this slot and jumps unconditionaly
 to the corresponding instruction.
 Since the return address can have several possible values, a 
\family typewriter
RET
\family default
 instruction can return to several possible instructions.
\end_layout

\begin_layout Standard
Let's take an example to illustrate this.
 Consider the following code:
\end_layout

\begin_layout LyX-Code
  JSR 
\shape slanted
sub
\end_layout

\begin_layout LyX-Code
  JSR 
\shape slanted
sub
\end_layout

\begin_layout LyX-Code
  RETURN
\end_layout

\begin_layout LyX-Code

\shape slanted
sub
\shape default
:
\end_layout

\begin_layout LyX-Code
  ASTORE 1
\end_layout

\begin_layout LyX-Code
  IINC 0 1
\end_layout

\begin_layout LyX-Code
  RET 1
\end_layout

\begin_layout Standard
The first instruction pushes as return address the index of the second instructi
on, and jumps to the 
\family typewriter
ASTORE
\family default
 instruction.
 This instruction stores the return address in local variable 1.
 Then local variable 0 is incremented by one.
 Finally the RET instruction loads the return address contained in local
 variable 1 and jumps to the corresponding instruction, 
\emph on
i.e.
\emph default
, the second instruction.
\end_layout

\begin_layout Standard
This second instruction is again a 
\family typewriter
JSR
\family default
 instruction: it pushes as return address the index of the third instruction,
 and jumps to the 
\family typewriter
ASTORE
\family default
 instruction.
 When the 
\family typewriter
RET
\family default
 instruction is reached again the return address corresponds now to the
 
\family typewriter
RETURN
\family default
 instruction, and so execution jumps to this 
\family typewriter
RETURN
\family default
 and stops.
\end_layout

\begin_layout Standard
The instructions after the 
\family typewriter
\emph on
sub
\family default
\emph default
 label define what is called a subroutine.
 It is like a little 
\begin_inset Quotes eld
\end_inset

method
\begin_inset Quotes erd
\end_inset

, which can be 
\begin_inset Quotes eld
\end_inset

called
\begin_inset Quotes erd
\end_inset

 from different places, inside a normal method.
 Subroutines were used, prior to Java 6, to compile 
\family typewriter
finally
\family default
 blocks in Java.
 But in fact subroutines are not strictly necessary: it is indeed possible
 to replace each 
\family typewriter
JSR
\family default
 instruction with the body of the corresponding subroutine.
 This 
\emph on
inlining
\emph default
 produces duplicated code but removes the 
\family typewriter
JSR
\family default
 and 
\family typewriter
RET
\family default
 instructions.
 With the above example the result is very simple:
\end_layout

\begin_layout LyX-Code
IINC 0 1
\end_layout

\begin_layout LyX-Code
IINC 0 1
\end_layout

\begin_layout LyX-Code
RETURN
\end_layout

\begin_layout Standard
ASM provides a 
\family typewriter
JSRInlinerAdapter
\family default
 class which can perform this transformation automatically, in the 
\family typewriter
org.objectweb.asm.commons
\family default
 package.
 You can use it to remove 
\family typewriter
JSR
\family default
 and 
\family typewriter
RET
\family default
 instructions in order to simplify code analysis, or to transform classes
 from version 1.5 or less to 1.6 or higher.
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
cleardoublepage
\end_layout

\end_inset


\end_layout

\begin_layout Section
Attributes
\end_layout

\begin_layout Standard
As explained in section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Class-Structure-Overview"

\end_inset

, it is possible to associate arbitrary 
\emph on
attributes
\emph default

\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
attributes
\end_layout

\end_inset

 to classes, fields and methods.
 This extensibility mechanism is very useful to extend the class file format
 when new features are introduced.
 For example it has been used to extend this format in order to support
 annotations, generics, stack map frames, etc.
 This mechanism can also be used by users, as opposed to Sun, but since
 the introduction of annotations in Java 5, 
\emph on
it is much easier to use annotations than attributes
\emph default
.
 That being said, if you 
\emph on
really
\emph default
 need to use your own attributes, or if you must manage non standard attributes
 defined by others, this can be done in ASM with the 
\family typewriter
Attribute
\family default
 class.
\end_layout

\begin_layout Standard
By default, the 
\family typewriter
ClassReader
\family default
 class creates an 
\family typewriter
Attribute
\family default
 instance for each non standard attribute it finds, and calls the 
\family typewriter
visitAttribute
\family default
 method (of the 
\family typewriter
ClassVisitor
\family default
, 
\family typewriter
FieldVisitor
\family default
 or 
\family typewriter
MethodVisitor
\family default
 class, depending on the context) with this instance as argument.
 This instance contains the raw content of the attribute, in the form of
 a private byte array.
 The 
\family typewriter
ClassWriter
\family default
 class, when visiting such unknow attributes, just copies this raw byte
 array in the class it constructs.
 
\emph on
This default behavior is safe only if the optimization described in section
\emph default
 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Transforming-classes-CoreAPI"

\end_inset

 
\emph on
is used
\emph default
 (this gives another reason to use this optimization, besides the performance
 gain).
 Without this option the raw content may become inconsistent with the new
 constant pool created by the class writer, resulting in a corrupted class
 file.
\end_layout

\begin_layout Standard
By default non standard attributes are therefore copied as is in transformed
 classes, and their content is completely opaque to ASM and to users.
 If you need access to this content, you must first define an 
\family typewriter
Attribute
\family default
 sub class that is able to decode the raw content, and to reencode it.
 You must also pass a prototype instance of this class in the 
\family typewriter
ClassReader.accept
\family default
 method, so that this class can decode attributes of this type.
 Let's take an example to illustrate this.
 The following class can be used to support an imaginary 
\begin_inset Quotes eld
\end_inset

Comment
\begin_inset Quotes erd
\end_inset

 attribute, whose raw content is a 
\family typewriter
short
\family default
 value that references an UTF8 string stored in the constant pool:
\end_layout

\begin_layout LyX-Code
class CommentAttribute extends Attribute {
\end_layout

\begin_layout LyX-Code
  private String comment;
\end_layout

\begin_layout LyX-Code
  public CommentAttribute(final String comment) {
\end_layout

\begin_layout LyX-Code
    super("Comment");
\end_layout

\begin_layout LyX-Code
    this.comment = comment;
\end_layout

\begin_layout LyX-Code
  }
\end_layout

\begin_layout LyX-Code
  public String getComment() {
\end_layout

\begin_layout LyX-Code
    return comment;
\end_layout

\begin_layout LyX-Code
  }
\end_layout

\begin_layout LyX-Code
  @Override 
\end_layout

\begin_layout LyX-Code
  public boolean isUnknown() {
\end_layout

\begin_layout LyX-Code
    return false;
\end_layout

\begin_layout LyX-Code
  }
\end_layout

\begin_layout LyX-Code
  @Override 
\end_layout

\begin_layout LyX-Code
 
\series bold
 protected Attribute read(ClassReader cr, int off, int len,
\end_layout

\begin_layout LyX-Code
 
\series bold
     char[] buf, int codeOff, Label[] labels) {
\end_layout

\begin_layout LyX-Code
 
\series bold
   return new CommentAttribute(cr.readUTF8(off, buf));
\end_layout

\begin_layout LyX-Code
 
\series bold
 }
\end_layout

\begin_layout LyX-Code
  @Override 
\end_layout

\begin_layout LyX-Code
 
\series bold
 protected ByteVector write(ClassWriter cw, byte[] code, int len,
\end_layout

\begin_layout LyX-Code
 
\series bold
     int maxStack, int maxLocals) {
\end_layout

\begin_layout LyX-Code
 
\series bold
   return new ByteVector().putShort(cw.newUTF8(comment));
\end_layout

\begin_layout LyX-Code
 
\series bold
 }
\end_layout

\begin_layout LyX-Code
}
\end_layout

\begin_layout Standard
The most important methods are the 
\family typewriter
read
\family default
 and 
\family typewriter
write
\family default
 methods.
 The 
\family typewriter
read
\family default
 method decodes the raw content of attributes of this type, and the 
\family typewriter
write
\family default
 method performs the inverse operation.
 Note that the 
\family typewriter
read
\family default
 method must return a 
\emph on
new
\emph default
 attribute instance.
 In order to decode attributes of this type when reading a class, you must
 use:
\end_layout

\begin_layout LyX-Code
ClassReader cr = ...;
\end_layout

\begin_layout LyX-Code
ClassVisitor cv = ...;
\end_layout

\begin_layout LyX-Code
cr.accept(cv, new Attribute[] { new CommentAttribute("") }, 0);
\end_layout

\begin_layout Standard
The 
\begin_inset Quotes eld
\end_inset

Comment
\begin_inset Quotes erd
\end_inset

 attributes will then be recognized, and a 
\family typewriter
CommentAttribute
\family default
 instance will be created for each of them (while unknown ones continue
 to be represented by 
\family typewriter
Attribute
\family default
 instances).
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
cleardoublepage
\end_layout

\end_inset


\end_layout

\begin_layout Section
Guidelines
\end_layout

\begin_layout Standard
We recall here the guidelines that must be followed in order to ensure that
 your code will be backward compatible with older ASM versions (see chapters
 
\begin_inset CommandInset ref
LatexCommand ref
reference "chap:Backward-compatibility"

\end_inset

 and 
\begin_inset CommandInset ref
LatexCommand ref
reference "chap:Backward-compatibility2"

\end_inset

).
\end_layout

\begin_layout Description
Guideline
\begin_inset space ~
\end_inset

1: to write a 
\family typewriter
ClassVisitor
\family default
 subclass for ASM version 
\emph on
X
\emph default
, call the 
\family typewriter
ClassVisitor
\family default
 constructor with this exact version as argument, and 
\emph on
never override or call methods that are deprecated
\emph default
 in this version of the 
\family typewriter
ClassVisitor
\family default
 class (or that are introduced in later versions).
\end_layout

\begin_layout Description
Guideline
\begin_inset space ~
\end_inset

2: do not use inheritance of visitors, use delegation instead (i.e.
 visitor chains).
 A good practice is to make your visitor classes final by default to ensure
 this.
\end_layout

\begin_layout Description
Guideline
\begin_inset space ~
\end_inset

3: to write a class analyzer or adapter with the tree API of ASM version
 
\emph on
X
\emph default
, create your 
\family typewriter
ClassNode
\family default
 by using the constructor with this exact version as argument (as opposed
 to the default constructor, without parameters).
\end_layout

\begin_layout Description
Guideline
\begin_inset space ~
\end_inset

4: to write a class analyzer or adapter with the tree API of ASM version
 
\emph on
X
\emph default
, using a 
\family typewriter
ClassNode
\family default
 created by someone else, call its 
\family typewriter
check()
\family default
 method with this exact version as argument before using the 
\family typewriter
ClassNode
\family default
 in any way.
\end_layout

\begin_layout Standard
Guidelines 1 and 2 also apply for subclasses of 
\family typewriter
ClassNode
\family default
, 
\family typewriter
MethodNode
\family default
, etc, of 
\family typewriter
Interpreter
\family default
 and its subclasses in 
\family typewriter
asm.tree.analysis
\family default
, of the 
\family typewriter
ASMifier
\family default
, 
\family typewriter
Texifier
\family default
, or 
\family typewriter
Check
\emph on
Xxx
\emph default
Adapter
\family default
 classes in 
\family typewriter
asm.util
\family default
, and of any class in the 
\family typewriter
asm.commons
\family default
 package.
 Finally, there are two exceptions to guideline 2:
\end_layout

\begin_layout Itemize
you can use inheritance of visitors if you fully control the inheritance
 chain yourself, and release all the classes of the hierarchy at the same
 time.
 You must then ensure that all the classes in the hierarchy are written
 for the same ASM version.
 Still, make the leaf classes of your hierarchy final.
\end_layout

\begin_layout Itemize
you can use inheritance of 
\begin_inset Quotes eld
\end_inset

visitors
\begin_inset Quotes erd
\end_inset

 if no class except the leaf ones override any visit method (for instance,
 if you use intermediate classes between 
\family typewriter
ClassVisitor
\family default
 and the concrete visitor classes only to introduce convenience methods).
 Still, make the leaf classes of your hierarchy final (unless they do not
 override any visit method either; in this case provide a constructor taking
 an ASM version as argument so that subclasses can specify for which version
 they are written).
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
cleardoublepage
\end_layout

\end_inset


\end_layout

\begin_layout Section
Performances
\end_layout

\begin_layout Standard
The figure below gives the relative performances of the core and tree APIs,
 of the 
\family typewriter
ClassWriter
\family default
 options, and of the analysis framework (shorter is faster): 
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename figures/perfs.eps
	scale 120
	scaleBeforeRotation
	rotateAngle 90
	rotateOrigin center

\end_inset


\end_layout

\begin_layout Standard
The reference time 100 corresponds to a 
\family typewriter
ClassReader
\family default
 chained directly to a 
\family typewriter
ClassWriter
\family default
.
 The 
\begin_inset Quotes eld
\end_inset

add timer
\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset

remove sequence
\begin_inset Quotes erd
\end_inset

 tests correspond to 
\family typewriter
AddTimerAdapter
\family default
 and 
\family typewriter
RemoveGetFieldPutFieldAdapter
\family default
 (
\emph on
italic
\emph default
 means that the optimization described in section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Transforming-classes-CoreAPI"

\end_inset

 is used, 
\series bold
bold
\series default
 means that the tree API is used).
 The total transformation time is decomposed into three parts: class parsing
 (bottom), class transformation or analysis (middle) and class writing (top).
 For each test the measured value is the time needed to parse, transform
 and write a 
\emph on
byte array
\emph default
, 
\emph on
i.e.
\emph default
, the time needed to load classes from disk and to load them inside the
 JVM is 
\emph on
not
\emph default
 taken into account.
 The results were obtained by running each test ten times, on the 12700+
 classes of JDK 1.5 
\family typewriter
rt.jar
\family default
, and by using the performance of the best run.
\end_layout

\begin_layout Standard
A quick analysis of these results shows that:
\end_layout

\begin_layout Itemize
90% of the transformation time is due to class parsing and writing.
\end_layout

\begin_layout Itemize
The 
\begin_inset Quotes eld
\end_inset

copy constant pool
\begin_inset Quotes erd
\end_inset

 optimization gives a 15-20% speed up.
\end_layout

\begin_layout Itemize
Tree based transformations are about 30% slower than visitor based ones.
\end_layout

\begin_layout Itemize
The 
\family typewriter
COMPUTE_MAXS
\family default
 option does not cost too much.
\end_layout

\begin_layout Itemize
The 
\family typewriter
COMPUTE_FRAMES
\family default
 option costs a lot 
\begin_inset Formula $\Rightarrow$
\end_inset

 do incremental frame updates.
\end_layout

\begin_layout Itemize
The cost of the analysis package is very high!
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
clearpage
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset index_print
LatexCommand printindex
type "idx"

\end_inset


\end_layout

\end_body
\end_document
